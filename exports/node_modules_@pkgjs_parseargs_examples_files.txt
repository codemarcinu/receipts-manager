=== Directory: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\@pkgjs\parseargs\examples ===


================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\@pkgjs\parseargs\examples\is-default-value.js
================================================================================

'use strict';

// This example shows how to understand if a default value is used or not.

// 1. const { parseArgs } = require('node:util'); // from node
// 2. const { parseArgs } = require('@pkgjs/parseargs'); // from package
const { parseArgs } = require('..'); // in repo

const options = {
  file: { short: 'f', type: 'string', default: 'FOO' },
};

const { values, tokens } = parseArgs({ options, tokens: true });

const isFileDefault = !tokens.some((token) => token.kind === 'option' &&
 token.name === 'file'
);

console.log(values);
console.log(`Is the file option [${values.file}] the default value? ${isFileDefault}`);

// Try the following:
//    node is-default-value.js
//    node is-default-value.js -f FILE
//    node is-default-value.js --file FILE

================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\@pkgjs\parseargs\examples\limit-long-syntax.js
================================================================================

'use strict';

// This is an example of using tokens to add a custom behaviour.
//
// Require the use of `=` for long options and values by blocking
// the use of space separated values.
// So allow `--foo=bar`, and not allow `--foo bar`.
//
// Note: this is not a common behaviour, most CLIs allow both forms.

// 1. const { parseArgs } = require('node:util'); // from node
// 2. const { parseArgs } = require('@pkgjs/parseargs'); // from package
const { parseArgs } = require('..'); // in repo

const options = {
  file: { short: 'f', type: 'string' },
  log: { type: 'string' },
};

const { values, tokens } = parseArgs({ options, tokens: true });

const badToken = tokens.find((token) => token.kind === 'option' &&
  token.value != null &&
  token.rawName.startsWith('--') &&
  !token.inlineValue
);
if (badToken) {
  throw new Error(`Option value for '${badToken.rawName}' must be inline, like '${badToken.rawName}=VALUE'`);
}

console.log(values);

// Try the following:
//    node limit-long-syntax.js -f FILE --log=LOG
//    node limit-long-syntax.js --file FILE

================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\@pkgjs\parseargs\examples\negate.js
================================================================================

'use strict';

// This example is used in the documentation.

// How might I add my own support for --no-foo?

// 1. const { parseArgs } = require('node:util'); // from node
// 2. const { parseArgs } = require('@pkgjs/parseargs'); // from package
const { parseArgs } = require('..'); // in repo

const options = {
  'color': { type: 'boolean' },
  'no-color': { type: 'boolean' },
  'logfile': { type: 'string' },
  'no-logfile': { type: 'boolean' },
};
const { values, tokens } = parseArgs({ options, tokens: true });

// Reprocess the option tokens and overwrite the returned values.
tokens
  .filter((token) => token.kind === 'option')
  .forEach((token) => {
    if (token.name.startsWith('no-')) {
      // Store foo:false for --no-foo
      const positiveName = token.name.slice(3);
      values[positiveName] = false;
      delete values[token.name];
    } else {
      // Resave value so last one wins if both --foo and --no-foo.
      values[token.name] = token.value ?? true;
    }
  });

const color = values.color;
const logfile = values.logfile ?? 'default.log';

console.log({ logfile, color });

// Try the following:
//    node negate.js
//    node negate.js --no-logfile --no-color
//    negate.js --logfile=test.log --color
//    node negate.js --no-logfile --logfile=test.log --color --no-color

================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\@pkgjs\parseargs\examples\no-repeated-options.js
================================================================================

'use strict';

// This is an example of using tokens to add a custom behaviour.
//
// Throw an error if an option is used more than once.

// 1. const { parseArgs } = require('node:util'); // from node
// 2. const { parseArgs } = require('@pkgjs/parseargs'); // from package
const { parseArgs } = require('..'); // in repo

const options = {
  ding: { type: 'boolean', short: 'd' },
  beep: { type: 'boolean', short: 'b' }
};
const { values, tokens } = parseArgs({ options, tokens: true });

const seenBefore = new Set();
tokens.forEach((token) => {
  if (token.kind !== 'option') return;
  if (seenBefore.has(token.name)) {
    throw new Error(`option '${token.name}' used multiple times`);
  }
  seenBefore.add(token.name);
});

console.log(values);

// Try the following:
//    node no-repeated-options --ding --beep
//    node no-repeated-options --beep -b
//    node no-repeated-options -ddd

================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\@pkgjs\parseargs\examples\ordered-options.mjs
================================================================================

// This is an example of using tokens to add a custom behaviour.
//
// This adds a option order check so that --some-unstable-option
// may only be used after --enable-experimental-options
//
// Note: this is not a common behaviour, the order of different options
// does not usually matter.

import { parseArgs } from '../index.js';

function findTokenIndex(tokens, target) {
  return tokens.findIndex((token) => token.kind === 'option' &&
    token.name === target
  );
}

const experimentalName = 'enable-experimental-options';
const unstableName = 'some-unstable-option';

const options = {
  [experimentalName]: { type: 'boolean' },
  [unstableName]: { type: 'boolean' },
};

const { values, tokens } = parseArgs({ options, tokens: true });

const experimentalIndex = findTokenIndex(tokens, experimentalName);
const unstableIndex = findTokenIndex(tokens, unstableName);
if (unstableIndex !== -1 &&
  ((experimentalIndex === -1) || (unstableIndex < experimentalIndex))) {
  throw new Error(`'--${experimentalName}' must be specified before '--${unstableName}'`);
}

console.log(values);

/* eslint-disable max-len */
// Try the following:
//    node ordered-options.mjs
//    node ordered-options.mjs --some-unstable-option
//    node ordered-options.mjs --some-unstable-option --enable-experimental-options
//    node ordered-options.mjs --enable-experimental-options --some-unstable-option

================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\@pkgjs\parseargs\examples\simple-hard-coded.js
================================================================================

'use strict';

// This example is used in the documentation.

// 1. const { parseArgs } = require('node:util'); // from node
// 2. const { parseArgs } = require('@pkgjs/parseargs'); // from package
const { parseArgs } = require('..'); // in repo

const args = ['-f', '--bar', 'b'];
const options = {
  foo: {
    type: 'boolean',
    short: 'f'
  },
  bar: {
    type: 'string'
  }
};
const {
  values,
  positionals
} = parseArgs({ args, options });
console.log(values, positionals);

// Try the following:
//    node simple-hard-coded.js
