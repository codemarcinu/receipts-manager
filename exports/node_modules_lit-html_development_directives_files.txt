=== Directory: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives ===


================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\async-append.d.ts
================================================================================

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
import { ChildPart } from '../lit-html.js';
import { DirectiveParameters, PartInfo } from '../directive.js';
import { AsyncReplaceDirective } from './async-replace.js';
declare class AsyncAppendDirective extends AsyncReplaceDirective {
    private __childPart;
    constructor(partInfo: PartInfo);
    update(part: ChildPart, params: DirectiveParameters<this>): symbol;
    protected commitValue(value: unknown, index: number): void;
}
/**
 * A directive that renders the items of an async iterable[1], appending new
 * values after previous values, similar to the built-in support for iterables.
 * This directive is usable only in child expressions.
 *
 * Async iterables are objects with a [Symbol.asyncIterator] method, which
 * returns an iterator who's `next()` method returns a Promise. When a new
 * value is available, the Promise resolves and the value is appended to the
 * Part controlled by the directive. If another value other than this
 * directive has been set on the Part, the iterable will no longer be listened
 * to and new values won't be written to the Part.
 *
 * [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of
 *
 * @param value An async iterable
 * @param mapper An optional function that maps from (value, index) to another
 *     value. Useful for generating templates for each item in the iterable.
 */
export declare const asyncAppend: (value: AsyncIterable<unknown>, _mapper?: ((v: unknown, index?: number) => unknown) | undefined) => import("../directive.js").DirectiveResult<typeof AsyncAppendDirective>;
/**
 * The type of the class that powers this directive. Necessary for naming the
 * directive's return type.
 */
export type { AsyncAppendDirective };
//# sourceMappingURL=async-append.d.ts.map
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\async-append.d.ts.map
================================================================================

{"version":3,"file":"async-append.d.ts","sourceRoot":"","sources":["../../src/directives/async-append.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAEH,OAAO,EAAC,SAAS,EAAC,MAAM,gBAAgB,CAAC;AACzC,OAAO,EAEL,mBAAmB,EACnB,QAAQ,EAET,MAAM,iBAAiB,CAAC;AACzB,OAAO,EAAC,qBAAqB,EAAC,MAAM,oBAAoB,CAAC;AAOzD,cAAM,oBAAqB,SAAQ,qBAAqB;IACtD,OAAO,CAAC,WAAW,CAAa;gBAGpB,QAAQ,EAAE,QAAQ;IAQrB,MAAM,CAAC,IAAI,EAAE,SAAS,EAAE,MAAM,EAAE,mBAAmB,CAAC,IAAI,CAAC;cAM/C,WAAW,CAAC,KAAK,EAAE,OAAO,EAAE,KAAK,EAAE,MAAM;CAU7D;AAED;;;;;;;;;;;;;;;;;GAiBG;AACH,eAAO,MAAM,WAAW,4KAAkC,CAAC;AAE3D;;;GAGG;AACH,YAAY,EAAC,oBAAoB,EAAC,CAAC"}
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\async-append.js
================================================================================

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
import { directive, PartType, } from '../directive.js';
import { AsyncReplaceDirective } from './async-replace.js';
import { clearPart, insertPart, setChildPartValue, } from '../directive-helpers.js';
class AsyncAppendDirective extends AsyncReplaceDirective {
    // Override AsyncReplace to narrow the allowed part type to ChildPart only
    constructor(partInfo) {
        super(partInfo);
        if (partInfo.type !== PartType.CHILD) {
            throw new Error('asyncAppend can only be used in child expressions');
        }
    }
    // Override AsyncReplace to save the part since we need to append into it
    update(part, params) {
        this.__childPart = part;
        return super.update(part, params);
    }
    // Override AsyncReplace to append rather than replace
    commitValue(value, index) {
        // When we get the first value, clear the part. This lets the
        // previous value display until we can replace it.
        if (index === 0) {
            clearPart(this.__childPart);
        }
        // Create and insert a new part and set its value to the next value
        const newPart = insertPart(this.__childPart);
        setChildPartValue(newPart, value);
    }
}
/**
 * A directive that renders the items of an async iterable[1], appending new
 * values after previous values, similar to the built-in support for iterables.
 * This directive is usable only in child expressions.
 *
 * Async iterables are objects with a [Symbol.asyncIterator] method, which
 * returns an iterator who's `next()` method returns a Promise. When a new
 * value is available, the Promise resolves and the value is appended to the
 * Part controlled by the directive. If another value other than this
 * directive has been set on the Part, the iterable will no longer be listened
 * to and new values won't be written to the Part.
 *
 * [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of
 *
 * @param value An async iterable
 * @param mapper An optional function that maps from (value, index) to another
 *     value. Useful for generating templates for each item in the iterable.
 */
export const asyncAppend = directive(AsyncAppendDirective);
//# sourceMappingURL=async-append.js.map
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\async-append.js.map
================================================================================

{"version":3,"file":"async-append.js","sourceRoot":"","sources":["../../src/directives/async-append.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAGH,OAAO,EACL,SAAS,EAGT,QAAQ,GACT,MAAM,iBAAiB,CAAC;AACzB,OAAO,EAAC,qBAAqB,EAAC,MAAM,oBAAoB,CAAC;AACzD,OAAO,EACL,SAAS,EACT,UAAU,EACV,iBAAiB,GAClB,MAAM,yBAAyB,CAAC;AAEjC,MAAM,oBAAqB,SAAQ,qBAAqB;IAGtD,0EAA0E;IAC1E,YAAY,QAAkB;QAC5B,KAAK,CAAC,QAAQ,CAAC,CAAC;QAChB,IAAI,QAAQ,CAAC,IAAI,KAAK,QAAQ,CAAC,KAAK,EAAE,CAAC;YACrC,MAAM,IAAI,KAAK,CAAC,mDAAmD,CAAC,CAAC;QACvE,CAAC;IACH,CAAC;IAED,yEAAyE;IAChE,MAAM,CAAC,IAAe,EAAE,MAAiC;QAChE,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC;QACxB,OAAO,KAAK,CAAC,MAAM,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;IACpC,CAAC;IAED,sDAAsD;IACnC,WAAW,CAAC,KAAc,EAAE,KAAa;QAC1D,6DAA6D;QAC7D,kDAAkD;QAClD,IAAI,KAAK,KAAK,CAAC,EAAE,CAAC;YAChB,SAAS,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;QAC9B,CAAC;QACD,mEAAmE;QACnE,MAAM,OAAO,GAAG,UAAU,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;QAC7C,iBAAiB,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;IACpC,CAAC;CACF;AAED;;;;;;;;;;;;;;;;;GAiBG;AACH,MAAM,CAAC,MAAM,WAAW,GAAG,SAAS,CAAC,oBAAoB,CAAC,CAAC","sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {ChildPart} from '../lit-html.js';\nimport {\n  directive,\n  DirectiveParameters,\n  PartInfo,\n  PartType,\n} from '../directive.js';\nimport {AsyncReplaceDirective} from './async-replace.js';\nimport {\n  clearPart,\n  insertPart,\n  setChildPartValue,\n} from '../directive-helpers.js';\n\nclass AsyncAppendDirective extends AsyncReplaceDirective {\n  private __childPart!: ChildPart;\n\n  // Override AsyncReplace to narrow the allowed part type to ChildPart only\n  constructor(partInfo: PartInfo) {\n    super(partInfo);\n    if (partInfo.type !== PartType.CHILD) {\n      throw new Error('asyncAppend can only be used in child expressions');\n    }\n  }\n\n  // Override AsyncReplace to save the part since we need to append into it\n  override update(part: ChildPart, params: DirectiveParameters<this>) {\n    this.__childPart = part;\n    return super.update(part, params);\n  }\n\n  // Override AsyncReplace to append rather than replace\n  protected override commitValue(value: unknown, index: number) {\n    // When we get the first value, clear the part. This lets the\n    // previous value display until we can replace it.\n    if (index === 0) {\n      clearPart(this.__childPart);\n    }\n    // Create and insert a new part and set its value to the next value\n    const newPart = insertPart(this.__childPart);\n    setChildPartValue(newPart, value);\n  }\n}\n\n/**\n * A directive that renders the items of an async iterable[1], appending new\n * values after previous values, similar to the built-in support for iterables.\n * This directive is usable only in child expressions.\n *\n * Async iterables are objects with a [Symbol.asyncIterator] method, which\n * returns an iterator who's `next()` method returns a Promise. When a new\n * value is available, the Promise resolves and the value is appended to the\n * Part controlled by the directive. If another value other than this\n * directive has been set on the Part, the iterable will no longer be listened\n * to and new values won't be written to the Part.\n *\n * [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of\n *\n * @param value An async iterable\n * @param mapper An optional function that maps from (value, index) to another\n *     value. Useful for generating templates for each item in the iterable.\n */\nexport const asyncAppend = directive(AsyncAppendDirective);\n\n/**\n * The type of the class that powers this directive. Necessary for naming the\n * directive's return type.\n */\nexport type {AsyncAppendDirective};\n"]}
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\async-replace.d.ts
================================================================================

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
import { ChildPart } from '../lit-html.js';
import { AsyncDirective, DirectiveParameters } from '../async-directive.js';
type Mapper<T> = (v: T, index?: number) => unknown;
export declare class AsyncReplaceDirective extends AsyncDirective {
    private __value?;
    private __weakThis;
    private __pauser;
    render<T>(value: AsyncIterable<T>, _mapper?: Mapper<T>): symbol;
    update(_part: ChildPart, [value, mapper]: DirectiveParameters<this>): symbol;
    protected commitValue(value: unknown, _index: number): void;
    disconnected(): void;
    reconnected(): void;
}
/**
 * A directive that renders the items of an async iterable[1], replacing
 * previous values with new values, so that only one value is ever rendered
 * at a time. This directive may be used in any expression type.
 *
 * Async iterables are objects with a `[Symbol.asyncIterator]` method, which
 * returns an iterator who's `next()` method returns a Promise. When a new
 * value is available, the Promise resolves and the value is rendered to the
 * Part controlled by the directive. If another value other than this
 * directive has been set on the Part, the iterable will no longer be listened
 * to and new values won't be written to the Part.
 *
 * [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of
 *
 * @param value An async iterable
 * @param mapper An optional function that maps from (value, index) to another
 *     value. Useful for generating templates for each item in the iterable.
 */
export declare const asyncReplace: (value: AsyncIterable<unknown>, _mapper?: Mapper<unknown> | undefined) => import("../directive.js").DirectiveResult<typeof AsyncReplaceDirective>;
export {};
//# sourceMappingURL=async-replace.d.ts.map
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\async-replace.d.ts.map
================================================================================

{"version":3,"file":"async-replace.d.ts","sourceRoot":"","sources":["../../src/directives/async-replace.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAEH,OAAO,EAAC,SAAS,EAAW,MAAM,gBAAgB,CAAC;AACnD,OAAO,EACL,cAAc,EAEd,mBAAmB,EACpB,MAAM,uBAAuB,CAAC;AAG/B,KAAK,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,EAAE,KAAK,CAAC,EAAE,MAAM,KAAK,OAAO,CAAC;AAEnD,qBAAa,qBAAsB,SAAQ,cAAc;IACvD,OAAO,CAAC,OAAO,CAAC,CAAyB;IACzC,OAAO,CAAC,UAAU,CAA2B;IAC7C,OAAO,CAAC,QAAQ,CAAgB;IAIhC,MAAM,CAAC,CAAC,EAAE,KAAK,EAAE,aAAa,CAAC,CAAC,CAAC,EAAE,OAAO,CAAC,EAAE,MAAM,CAAC,CAAC,CAAC;IAI7C,MAAM,CACb,KAAK,EAAE,SAAS,EAChB,CAAC,KAAK,EAAE,MAAM,CAAC,EAAE,mBAAmB,CAAC,IAAI,CAAC;IAqD5C,SAAS,CAAC,WAAW,CAAC,KAAK,EAAE,OAAO,EAAE,MAAM,EAAE,MAAM;IAI3C,YAAY;IAKZ,WAAW;CAIrB;AAED;;;;;;;;;;;;;;;;;GAiBG;AACH,eAAO,MAAM,YAAY,mJAAmC,CAAC"}
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\async-replace.js
================================================================================

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
import { noChange } from '../lit-html.js';
import { AsyncDirective, directive, } from '../async-directive.js';
import { Pauser, PseudoWeakRef, forAwaitOf } from './private-async-helpers.js';
export class AsyncReplaceDirective extends AsyncDirective {
    constructor() {
        super(...arguments);
        this.__weakThis = new PseudoWeakRef(this);
        this.__pauser = new Pauser();
    }
    // @ts-expect-error value not used, but we want a nice parameter for docs
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    render(value, _mapper) {
        return noChange;
    }
    update(_part, [value, mapper]) {
        // If our initial render occurs while disconnected, ensure that the pauser
        // and weakThis are in the disconnected state
        if (!this.isConnected) {
            this.disconnected();
        }
        // If we've already set up this particular iterable, we don't need
        // to do anything.
        if (value === this.__value) {
            return noChange;
        }
        this.__value = value;
        let i = 0;
        const { __weakThis: weakThis, __pauser: pauser } = this;
        // Note, the callback avoids closing over `this` so that the directive
        // can be gc'ed before the promise resolves; instead `this` is retrieved
        // from `weakThis`, which can break the hard reference in the closure when
        // the directive disconnects
        forAwaitOf(value, async (v) => {
            // The while loop here handles the case that the connection state
            // thrashes, causing the pauser to resume and then get re-paused
            while (pauser.get()) {
                await pauser.get();
            }
            // If the callback gets here and there is no `this`, it means that the
            // directive has been disconnected and garbage collected and we don't
            // need to do anything else
            const _this = weakThis.deref();
            if (_this !== undefined) {
                // Check to make sure that value is the still the current value of
                // the part, and if not bail because a new value owns this part
                if (_this.__value !== value) {
                    return false;
                }
                // As a convenience, because functional-programming-style
                // transforms of iterables and async iterables requires a library,
                // we accept a mapper function. This is especially convenient for
                // rendering a template for each item.
                if (mapper !== undefined) {
                    v = mapper(v, i);
                }
                _this.commitValue(v, i);
                i++;
            }
            return true;
        });
        return noChange;
    }
    // Override point for AsyncAppend to append rather than replace
    commitValue(value, _index) {
        this.setValue(value);
    }
    disconnected() {
        this.__weakThis.disconnect();
        this.__pauser.pause();
    }
    reconnected() {
        this.__weakThis.reconnect(this);
        this.__pauser.resume();
    }
}
/**
 * A directive that renders the items of an async iterable[1], replacing
 * previous values with new values, so that only one value is ever rendered
 * at a time. This directive may be used in any expression type.
 *
 * Async iterables are objects with a `[Symbol.asyncIterator]` method, which
 * returns an iterator who's `next()` method returns a Promise. When a new
 * value is available, the Promise resolves and the value is rendered to the
 * Part controlled by the directive. If another value other than this
 * directive has been set on the Part, the iterable will no longer be listened
 * to and new values won't be written to the Part.
 *
 * [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of
 *
 * @param value An async iterable
 * @param mapper An optional function that maps from (value, index) to another
 *     value. Useful for generating templates for each item in the iterable.
 */
export const asyncReplace = directive(AsyncReplaceDirective);
//# sourceMappingURL=async-replace.js.map
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\async-replace.js.map
================================================================================

{"version":3,"file":"async-replace.js","sourceRoot":"","sources":["../../src/directives/async-replace.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAEH,OAAO,EAAY,QAAQ,EAAC,MAAM,gBAAgB,CAAC;AACnD,OAAO,EACL,cAAc,EACd,SAAS,GAEV,MAAM,uBAAuB,CAAC;AAC/B,OAAO,EAAC,MAAM,EAAE,aAAa,EAAE,UAAU,EAAC,MAAM,4BAA4B,CAAC;AAI7E,MAAM,OAAO,qBAAsB,SAAQ,cAAc;IAAzD;;QAEU,eAAU,GAAG,IAAI,aAAa,CAAC,IAAI,CAAC,CAAC;QACrC,aAAQ,GAAG,IAAI,MAAM,EAAE,CAAC;IA4ElC,CAAC;IA1EC,yEAAyE;IACzE,6DAA6D;IAC7D,MAAM,CAAI,KAAuB,EAAE,OAAmB;QACpD,OAAO,QAAQ,CAAC;IAClB,CAAC;IAEQ,MAAM,CACb,KAAgB,EAChB,CAAC,KAAK,EAAE,MAAM,CAA4B;QAE1C,0EAA0E;QAC1E,6CAA6C;QAC7C,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE,CAAC;YACtB,IAAI,CAAC,YAAY,EAAE,CAAC;QACtB,CAAC;QACD,kEAAkE;QAClE,kBAAkB;QAClB,IAAI,KAAK,KAAK,IAAI,CAAC,OAAO,EAAE,CAAC;YAC3B,OAAO,QAAQ,CAAC;QAClB,CAAC;QACD,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC;QACrB,IAAI,CAAC,GAAG,CAAC,CAAC;QACV,MAAM,EAAC,UAAU,EAAE,QAAQ,EAAE,QAAQ,EAAE,MAAM,EAAC,GAAG,IAAI,CAAC;QACtD,sEAAsE;QACtE,wEAAwE;QACxE,0EAA0E;QAC1E,4BAA4B;QAC5B,UAAU,CAAC,KAAK,EAAE,KAAK,EAAE,CAAU,EAAE,EAAE;YACrC,iEAAiE;YACjE,gEAAgE;YAChE,OAAO,MAAM,CAAC,GAAG,EAAE,EAAE,CAAC;gBACpB,MAAM,MAAM,CAAC,GAAG,EAAE,CAAC;YACrB,CAAC;YACD,sEAAsE;YACtE,qEAAqE;YACrE,2BAA2B;YAC3B,MAAM,KAAK,GAAG,QAAQ,CAAC,KAAK,EAAE,CAAC;YAC/B,IAAI,KAAK,KAAK,SAAS,EAAE,CAAC;gBACxB,kEAAkE;gBAClE,+DAA+D;gBAC/D,IAAI,KAAK,CAAC,OAAO,KAAK,KAAK,EAAE,CAAC;oBAC5B,OAAO,KAAK,CAAC;gBACf,CAAC;gBAED,yDAAyD;gBACzD,kEAAkE;gBAClE,iEAAiE;gBACjE,sCAAsC;gBACtC,IAAI,MAAM,KAAK,SAAS,EAAE,CAAC;oBACzB,CAAC,GAAG,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;gBACnB,CAAC;gBAED,KAAK,CAAC,WAAW,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;gBACxB,CAAC,EAAE,CAAC;YACN,CAAC;YACD,OAAO,IAAI,CAAC;QACd,CAAC,CAAC,CAAC;QACH,OAAO,QAAQ,CAAC;IAClB,CAAC;IAED,+DAA+D;IACrD,WAAW,CAAC,KAAc,EAAE,MAAc;QAClD,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;IACvB,CAAC;IAEQ,YAAY;QACnB,IAAI,CAAC,UAAU,CAAC,UAAU,EAAE,CAAC;QAC7B,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,CAAC;IACxB,CAAC;IAEQ,WAAW;QAClB,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;QAChC,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE,CAAC;IACzB,CAAC;CACF;AAED;;;;;;;;;;;;;;;;;GAiBG;AACH,MAAM,CAAC,MAAM,YAAY,GAAG,SAAS,CAAC,qBAAqB,CAAC,CAAC","sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {ChildPart, noChange} from '../lit-html.js';\nimport {\n  AsyncDirective,\n  directive,\n  DirectiveParameters,\n} from '../async-directive.js';\nimport {Pauser, PseudoWeakRef, forAwaitOf} from './private-async-helpers.js';\n\ntype Mapper<T> = (v: T, index?: number) => unknown;\n\nexport class AsyncReplaceDirective extends AsyncDirective {\n  private __value?: AsyncIterable<unknown>;\n  private __weakThis = new PseudoWeakRef(this);\n  private __pauser = new Pauser();\n\n  // @ts-expect-error value not used, but we want a nice parameter for docs\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  render<T>(value: AsyncIterable<T>, _mapper?: Mapper<T>) {\n    return noChange;\n  }\n\n  override update(\n    _part: ChildPart,\n    [value, mapper]: DirectiveParameters<this>\n  ) {\n    // If our initial render occurs while disconnected, ensure that the pauser\n    // and weakThis are in the disconnected state\n    if (!this.isConnected) {\n      this.disconnected();\n    }\n    // If we've already set up this particular iterable, we don't need\n    // to do anything.\n    if (value === this.__value) {\n      return noChange;\n    }\n    this.__value = value;\n    let i = 0;\n    const {__weakThis: weakThis, __pauser: pauser} = this;\n    // Note, the callback avoids closing over `this` so that the directive\n    // can be gc'ed before the promise resolves; instead `this` is retrieved\n    // from `weakThis`, which can break the hard reference in the closure when\n    // the directive disconnects\n    forAwaitOf(value, async (v: unknown) => {\n      // The while loop here handles the case that the connection state\n      // thrashes, causing the pauser to resume and then get re-paused\n      while (pauser.get()) {\n        await pauser.get();\n      }\n      // If the callback gets here and there is no `this`, it means that the\n      // directive has been disconnected and garbage collected and we don't\n      // need to do anything else\n      const _this = weakThis.deref();\n      if (_this !== undefined) {\n        // Check to make sure that value is the still the current value of\n        // the part, and if not bail because a new value owns this part\n        if (_this.__value !== value) {\n          return false;\n        }\n\n        // As a convenience, because functional-programming-style\n        // transforms of iterables and async iterables requires a library,\n        // we accept a mapper function. This is especially convenient for\n        // rendering a template for each item.\n        if (mapper !== undefined) {\n          v = mapper(v, i);\n        }\n\n        _this.commitValue(v, i);\n        i++;\n      }\n      return true;\n    });\n    return noChange;\n  }\n\n  // Override point for AsyncAppend to append rather than replace\n  protected commitValue(value: unknown, _index: number) {\n    this.setValue(value);\n  }\n\n  override disconnected() {\n    this.__weakThis.disconnect();\n    this.__pauser.pause();\n  }\n\n  override reconnected() {\n    this.__weakThis.reconnect(this);\n    this.__pauser.resume();\n  }\n}\n\n/**\n * A directive that renders the items of an async iterable[1], replacing\n * previous values with new values, so that only one value is ever rendered\n * at a time. This directive may be used in any expression type.\n *\n * Async iterables are objects with a `[Symbol.asyncIterator]` method, which\n * returns an iterator who's `next()` method returns a Promise. When a new\n * value is available, the Promise resolves and the value is rendered to the\n * Part controlled by the directive. If another value other than this\n * directive has been set on the Part, the iterable will no longer be listened\n * to and new values won't be written to the Part.\n *\n * [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of\n *\n * @param value An async iterable\n * @param mapper An optional function that maps from (value, index) to another\n *     value. Useful for generating templates for each item in the iterable.\n */\nexport const asyncReplace = directive(AsyncReplaceDirective);\n"]}
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\cache.d.ts
================================================================================

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
import { ChildPart } from '../lit-html.js';
import { Directive, DirectiveParameters, PartInfo } from '../directive.js';
declare class CacheDirective extends Directive {
    private _templateCache;
    private _value?;
    constructor(partInfo: PartInfo);
    render(v: unknown): unknown[];
    update(containerPart: ChildPart, [v]: DirectiveParameters<this>): unknown[];
}
/**
 * Enables fast switching between multiple templates by caching the DOM nodes
 * and TemplateInstances produced by the templates.
 *
 * Example:
 *
 * ```js
 * let checked = false;
 *
 * html`
 *   ${cache(checked ? html`input is checked` : html`input is not checked`)}
 * `
 * ```
 */
export declare const cache: (v: unknown) => import("../directive.js").DirectiveResult<typeof CacheDirective>;
/**
 * The type of the class that powers this directive. Necessary for naming the
 * directive's return type.
 */
export type { CacheDirective };
//# sourceMappingURL=cache.d.ts.map
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\cache.d.ts.map
================================================================================

{"version":3,"file":"cache.d.ts","sourceRoot":"","sources":["../../src/directives/cache.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAEH,OAAO,EAEL,SAAS,EAKV,MAAM,gBAAgB,CAAC;AACxB,OAAO,EAEL,SAAS,EACT,mBAAmB,EACnB,QAAQ,EACT,MAAM,iBAAiB,CAAC;AAoBzB,cAAM,cAAe,SAAQ,SAAS;IACpC,OAAO,CAAC,cAAc,CAAiD;IACvE,OAAO,CAAC,MAAM,CAAC,CAA0C;gBAE7C,QAAQ,EAAE,QAAQ;IAI9B,MAAM,CAAC,CAAC,EAAE,OAAO;IAMR,MAAM,CAAC,aAAa,EAAE,SAAS,EAAE,CAAC,CAAC,CAAC,EAAE,mBAAmB,CAAC,IAAI,CAAC;CAiDzE;AAED;;;;;;;;;;;;;GAaG;AACH,eAAO,MAAM,KAAK,kFAA4B,CAAC;AAE/C;;;GAGG;AACH,YAAY,EAAC,cAAc,EAAC,CAAC"}
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\cache.js
================================================================================

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
import { render, nothing, } from '../lit-html.js';
import { directive, Directive, } from '../directive.js';
import { clearPart, getCommittedValue, insertPart, isCompiledTemplateResult, isTemplateResult, setCommittedValue, } from '../directive-helpers.js';
/**
 * The template strings array contents are not compatible between the two
 * template result types as the compiled template contains a prepared string;
 * only use the returned template strings array as a cache key.
 */
const getStringsFromTemplateResult = (result) => isCompiledTemplateResult(result) ? result['_$litType$'].h : result.strings;
class CacheDirective extends Directive {
    constructor(partInfo) {
        super(partInfo);
        this._templateCache = new WeakMap();
    }
    render(v) {
        // Return an array of the value to induce lit-html to create a ChildPart
        // for the value that we can move into the cache.
        return [v];
    }
    update(containerPart, [v]) {
        const _valueKey = isTemplateResult(this._value)
            ? getStringsFromTemplateResult(this._value)
            : null;
        const vKey = isTemplateResult(v) ? getStringsFromTemplateResult(v) : null;
        // If the previous value is a TemplateResult and the new value is not,
        // or is a different Template as the previous value, move the child part
        // into the cache.
        if (_valueKey !== null && (vKey === null || _valueKey !== vKey)) {
            // This is always an array because we return [v] in render()
            const partValue = getCommittedValue(containerPart);
            const childPart = partValue.pop();
            let cachedContainerPart = this._templateCache.get(_valueKey);
            if (cachedContainerPart === undefined) {
                const fragment = document.createDocumentFragment();
                cachedContainerPart = render(nothing, fragment);
                cachedContainerPart.setConnected(false);
                this._templateCache.set(_valueKey, cachedContainerPart);
            }
            // Move into cache
            setCommittedValue(cachedContainerPart, [childPart]);
            insertPart(cachedContainerPart, undefined, childPart);
        }
        // If the new value is a TemplateResult and the previous value is not,
        // or is a different Template as the previous value, restore the child
        // part from the cache.
        if (vKey !== null) {
            if (_valueKey === null || _valueKey !== vKey) {
                const cachedContainerPart = this._templateCache.get(vKey);
                if (cachedContainerPart !== undefined) {
                    // Move the cached part back into the container part value
                    const partValue = getCommittedValue(cachedContainerPart);
                    const cachedPart = partValue.pop();
                    // Move cached part back into DOM
                    clearPart(containerPart);
                    insertPart(containerPart, undefined, cachedPart);
                    setCommittedValue(containerPart, [cachedPart]);
                }
            }
            // Because vKey is non null, v must be a TemplateResult.
            this._value = v;
        }
        else {
            this._value = undefined;
        }
        return this.render(v);
    }
}
/**
 * Enables fast switching between multiple templates by caching the DOM nodes
 * and TemplateInstances produced by the templates.
 *
 * Example:
 *
 * ```js
 * let checked = false;
 *
 * html`
 *   ${cache(checked ? html`input is checked` : html`input is not checked`)}
 * `
 * ```
 */
export const cache = directive(CacheDirective);
//# sourceMappingURL=cache.js.map
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\cache.js.map
================================================================================

{"version":3,"file":"cache.js","sourceRoot":"","sources":["../../src/directives/cache.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAEH,OAAO,EAIL,MAAM,EACN,OAAO,GAER,MAAM,gBAAgB,CAAC;AACxB,OAAO,EACL,SAAS,EACT,SAAS,GAGV,MAAM,iBAAiB,CAAC;AACzB,OAAO,EACL,SAAS,EACT,iBAAiB,EACjB,UAAU,EACV,wBAAwB,EACxB,gBAAgB,EAChB,iBAAiB,GAClB,MAAM,yBAAyB,CAAC;AAEjC;;;;GAIG;AACH,MAAM,4BAA4B,GAAG,CACnC,MAA+C,EACzB,EAAE,CACxB,wBAAwB,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC;AAE7E,MAAM,cAAe,SAAQ,SAAS;IAIpC,YAAY,QAAkB;QAC5B,KAAK,CAAC,QAAQ,CAAC,CAAC;QAJV,mBAAc,GAAG,IAAI,OAAO,EAAkC,CAAC;IAKvE,CAAC;IAED,MAAM,CAAC,CAAU;QACf,wEAAwE;QACxE,iDAAiD;QACjD,OAAO,CAAC,CAAC,CAAC,CAAC;IACb,CAAC;IAEQ,MAAM,CAAC,aAAwB,EAAE,CAAC,CAAC,CAA4B;QACtE,MAAM,SAAS,GAAG,gBAAgB,CAAC,IAAI,CAAC,MAAM,CAAC;YAC7C,CAAC,CAAC,4BAA4B,CAAC,IAAI,CAAC,MAAM,CAAC;YAC3C,CAAC,CAAC,IAAI,CAAC;QACT,MAAM,IAAI,GAAG,gBAAgB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,4BAA4B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;QAE1E,sEAAsE;QACtE,wEAAwE;QACxE,kBAAkB;QAClB,IAAI,SAAS,KAAK,IAAI,IAAI,CAAC,IAAI,KAAK,IAAI,IAAI,SAAS,KAAK,IAAI,CAAC,EAAE,CAAC;YAChE,4DAA4D;YAC5D,MAAM,SAAS,GAAG,iBAAiB,CAAC,aAAa,CAAqB,CAAC;YACvE,MAAM,SAAS,GAAG,SAAS,CAAC,GAAG,EAAG,CAAC;YACnC,IAAI,mBAAmB,GAAG,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;YAC7D,IAAI,mBAAmB,KAAK,SAAS,EAAE,CAAC;gBACtC,MAAM,QAAQ,GAAG,QAAQ,CAAC,sBAAsB,EAAE,CAAC;gBACnD,mBAAmB,GAAG,MAAM,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;gBAChD,mBAAmB,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC;gBACxC,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,SAAS,EAAE,mBAAmB,CAAC,CAAC;YAC1D,CAAC;YACD,kBAAkB;YAClB,iBAAiB,CAAC,mBAAmB,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;YACpD,UAAU,CAAC,mBAAmB,EAAE,SAAS,EAAE,SAAS,CAAC,CAAC;QACxD,CAAC;QACD,sEAAsE;QACtE,sEAAsE;QACtE,uBAAuB;QACvB,IAAI,IAAI,KAAK,IAAI,EAAE,CAAC;YAClB,IAAI,SAAS,KAAK,IAAI,IAAI,SAAS,KAAK,IAAI,EAAE,CAAC;gBAC7C,MAAM,mBAAmB,GAAG,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;gBAC1D,IAAI,mBAAmB,KAAK,SAAS,EAAE,CAAC;oBACtC,0DAA0D;oBAC1D,MAAM,SAAS,GAAG,iBAAiB,CACjC,mBAAmB,CACA,CAAC;oBACtB,MAAM,UAAU,GAAG,SAAS,CAAC,GAAG,EAAG,CAAC;oBACpC,iCAAiC;oBACjC,SAAS,CAAC,aAAa,CAAC,CAAC;oBACzB,UAAU,CAAC,aAAa,EAAE,SAAS,EAAE,UAAU,CAAC,CAAC;oBACjD,iBAAiB,CAAC,aAAa,EAAE,CAAC,UAAU,CAAC,CAAC,CAAC;gBACjD,CAAC;YACH,CAAC;YACD,wDAAwD;YACxD,IAAI,CAAC,MAAM,GAAG,CAA4C,CAAC;QAC7D,CAAC;aAAM,CAAC;YACN,IAAI,CAAC,MAAM,GAAG,SAAS,CAAC;QAC1B,CAAC;QACD,OAAO,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;IACxB,CAAC;CACF;AAED;;;;;;;;;;;;;GAaG;AACH,MAAM,CAAC,MAAM,KAAK,GAAG,SAAS,CAAC,cAAc,CAAC,CAAC","sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {\n  TemplateResult,\n  ChildPart,\n  RootPart,\n  render,\n  nothing,\n  CompiledTemplateResult,\n} from '../lit-html.js';\nimport {\n  directive,\n  Directive,\n  DirectiveParameters,\n  PartInfo,\n} from '../directive.js';\nimport {\n  clearPart,\n  getCommittedValue,\n  insertPart,\n  isCompiledTemplateResult,\n  isTemplateResult,\n  setCommittedValue,\n} from '../directive-helpers.js';\n\n/**\n * The template strings array contents are not compatible between the two\n * template result types as the compiled template contains a prepared string;\n * only use the returned template strings array as a cache key.\n */\nconst getStringsFromTemplateResult = (\n  result: TemplateResult | CompiledTemplateResult\n): TemplateStringsArray =>\n  isCompiledTemplateResult(result) ? result['_$litType$'].h : result.strings;\n\nclass CacheDirective extends Directive {\n  private _templateCache = new WeakMap<TemplateStringsArray, RootPart>();\n  private _value?: TemplateResult | CompiledTemplateResult;\n\n  constructor(partInfo: PartInfo) {\n    super(partInfo);\n  }\n\n  render(v: unknown) {\n    // Return an array of the value to induce lit-html to create a ChildPart\n    // for the value that we can move into the cache.\n    return [v];\n  }\n\n  override update(containerPart: ChildPart, [v]: DirectiveParameters<this>) {\n    const _valueKey = isTemplateResult(this._value)\n      ? getStringsFromTemplateResult(this._value)\n      : null;\n    const vKey = isTemplateResult(v) ? getStringsFromTemplateResult(v) : null;\n\n    // If the previous value is a TemplateResult and the new value is not,\n    // or is a different Template as the previous value, move the child part\n    // into the cache.\n    if (_valueKey !== null && (vKey === null || _valueKey !== vKey)) {\n      // This is always an array because we return [v] in render()\n      const partValue = getCommittedValue(containerPart) as Array<ChildPart>;\n      const childPart = partValue.pop()!;\n      let cachedContainerPart = this._templateCache.get(_valueKey);\n      if (cachedContainerPart === undefined) {\n        const fragment = document.createDocumentFragment();\n        cachedContainerPart = render(nothing, fragment);\n        cachedContainerPart.setConnected(false);\n        this._templateCache.set(_valueKey, cachedContainerPart);\n      }\n      // Move into cache\n      setCommittedValue(cachedContainerPart, [childPart]);\n      insertPart(cachedContainerPart, undefined, childPart);\n    }\n    // If the new value is a TemplateResult and the previous value is not,\n    // or is a different Template as the previous value, restore the child\n    // part from the cache.\n    if (vKey !== null) {\n      if (_valueKey === null || _valueKey !== vKey) {\n        const cachedContainerPart = this._templateCache.get(vKey);\n        if (cachedContainerPart !== undefined) {\n          // Move the cached part back into the container part value\n          const partValue = getCommittedValue(\n            cachedContainerPart\n          ) as Array<ChildPart>;\n          const cachedPart = partValue.pop()!;\n          // Move cached part back into DOM\n          clearPart(containerPart);\n          insertPart(containerPart, undefined, cachedPart);\n          setCommittedValue(containerPart, [cachedPart]);\n        }\n      }\n      // Because vKey is non null, v must be a TemplateResult.\n      this._value = v as TemplateResult | CompiledTemplateResult;\n    } else {\n      this._value = undefined;\n    }\n    return this.render(v);\n  }\n}\n\n/**\n * Enables fast switching between multiple templates by caching the DOM nodes\n * and TemplateInstances produced by the templates.\n *\n * Example:\n *\n * ```js\n * let checked = false;\n *\n * html`\n *   ${cache(checked ? html`input is checked` : html`input is not checked`)}\n * `\n * ```\n */\nexport const cache = directive(CacheDirective);\n\n/**\n * The type of the class that powers this directive. Necessary for naming the\n * directive's return type.\n */\nexport type {CacheDirective};\n"]}
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\choose.d.ts
================================================================================

/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
/**
 * Chooses and evaluates a template function from a list based on matching
 * the given `value` to a case.
 *
 * Cases are structured as `[caseValue, func]`. `value` is matched to
 * `caseValue` by strict equality. The first match is selected. Case values
 * can be of any type including primitives, objects, and symbols.
 *
 * This is similar to a switch statement, but as an expression and without
 * fallthrough.
 *
 * @example
 *
 * ```ts
 * render() {
 *   return html`
 *     ${choose(this.section, [
 *       ['home', () => html`<h1>Home</h1>`],
 *       ['about', () => html`<h1>About</h1>`]
 *     ],
 *     () => html`<h1>Error</h1>`)}
 *   `;
 * }
 * ```
 */
export declare const choose: <T, V, K extends T = T>(value: T, cases: Array<[K, () => V]>, defaultCase?: () => V) => V | undefined;
//# sourceMappingURL=choose.d.ts.map
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\choose.d.ts.map
================================================================================

{"version":3,"file":"choose.d.ts","sourceRoot":"","sources":["../../src/directives/choose.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAEH;;;;;;;;;;;;;;;;;;;;;;;;GAwBG;AACH,eAAO,MAAM,MAAM,GAAI,CAAC,EAAE,CAAC,EAAE,CAAC,SAAS,CAAC,aAC/B,CAAC,SACD,KAAK,CAAC,CAAC,CAAC,EAAE,MAAM,CAAC,CAAC,CAAC,gBACZ,MAAM,CAAC,kBAUtB,CAAC"}
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\choose.js
================================================================================

/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
/**
 * Chooses and evaluates a template function from a list based on matching
 * the given `value` to a case.
 *
 * Cases are structured as `[caseValue, func]`. `value` is matched to
 * `caseValue` by strict equality. The first match is selected. Case values
 * can be of any type including primitives, objects, and symbols.
 *
 * This is similar to a switch statement, but as an expression and without
 * fallthrough.
 *
 * @example
 *
 * ```ts
 * render() {
 *   return html`
 *     ${choose(this.section, [
 *       ['home', () => html`<h1>Home</h1>`],
 *       ['about', () => html`<h1>About</h1>`]
 *     ],
 *     () => html`<h1>Error</h1>`)}
 *   `;
 * }
 * ```
 */
export const choose = (value, cases, defaultCase) => {
    for (const c of cases) {
        const caseValue = c[0];
        if (caseValue === value) {
            const fn = c[1];
            return fn();
        }
    }
    return defaultCase?.();
};
//# sourceMappingURL=choose.js.map
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\choose.js.map
================================================================================

{"version":3,"file":"choose.js","sourceRoot":"","sources":["../../src/directives/choose.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAEH;;;;;;;;;;;;;;;;;;;;;;;;GAwBG;AACH,MAAM,CAAC,MAAM,MAAM,GAAG,CACpB,KAAQ,EACR,KAA0B,EAC1B,WAAqB,EACrB,EAAE;IACF,KAAK,MAAM,CAAC,IAAI,KAAK,EAAE,CAAC;QACtB,MAAM,SAAS,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;QACvB,IAAI,SAAS,KAAK,KAAK,EAAE,CAAC;YACxB,MAAM,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;YAChB,OAAO,EAAE,EAAE,CAAC;QACd,CAAC;IACH,CAAC;IACD,OAAO,WAAW,EAAE,EAAE,CAAC;AACzB,CAAC,CAAC","sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n/**\n * Chooses and evaluates a template function from a list based on matching\n * the given `value` to a case.\n *\n * Cases are structured as `[caseValue, func]`. `value` is matched to\n * `caseValue` by strict equality. The first match is selected. Case values\n * can be of any type including primitives, objects, and symbols.\n *\n * This is similar to a switch statement, but as an expression and without\n * fallthrough.\n *\n * @example\n *\n * ```ts\n * render() {\n *   return html`\n *     ${choose(this.section, [\n *       ['home', () => html`<h1>Home</h1>`],\n *       ['about', () => html`<h1>About</h1>`]\n *     ],\n *     () => html`<h1>Error</h1>`)}\n *   `;\n * }\n * ```\n */\nexport const choose = <T, V, K extends T = T>(\n  value: T,\n  cases: Array<[K, () => V]>,\n  defaultCase?: () => V\n) => {\n  for (const c of cases) {\n    const caseValue = c[0];\n    if (caseValue === value) {\n      const fn = c[1];\n      return fn();\n    }\n  }\n  return defaultCase?.();\n};\n"]}
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\class-map.d.ts
================================================================================

/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
import { AttributePart, noChange } from '../lit-html.js';
import { Directive, DirectiveParameters, PartInfo } from '../directive.js';
/**
 * A key-value set of class names to truthy values.
 */
export interface ClassInfo {
    readonly [name: string]: string | boolean | number;
}
declare class ClassMapDirective extends Directive {
    /**
     * Stores the ClassInfo object applied to a given AttributePart.
     * Used to unset existing values when a new ClassInfo object is applied.
     */
    private _previousClasses?;
    private _staticClasses?;
    constructor(partInfo: PartInfo);
    render(classInfo: ClassInfo): string;
    update(part: AttributePart, [classInfo]: DirectiveParameters<this>): string | typeof noChange;
}
/**
 * A directive that applies dynamic CSS classes.
 *
 * This must be used in the `class` attribute and must be the only part used in
 * the attribute. It takes each property in the `classInfo` argument and adds
 * the property name to the element's `classList` if the property value is
 * truthy; if the property value is falsy, the property name is removed from
 * the element's `class`.
 *
 * For example `{foo: bar}` applies the class `foo` if the value of `bar` is
 * truthy.
 *
 * @param classInfo
 */
export declare const classMap: (classInfo: ClassInfo) => import("../directive.js").DirectiveResult<typeof ClassMapDirective>;
/**
 * The type of the class that powers this directive. Necessary for naming the
 * directive's return type.
 */
export type { ClassMapDirective };
//# sourceMappingURL=class-map.d.ts.map
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\class-map.d.ts.map
================================================================================

{"version":3,"file":"class-map.d.ts","sourceRoot":"","sources":["../../src/directives/class-map.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAEH,OAAO,EAAC,aAAa,EAAE,QAAQ,EAAC,MAAM,gBAAgB,CAAC;AACvD,OAAO,EAEL,SAAS,EACT,mBAAmB,EACnB,QAAQ,EAET,MAAM,iBAAiB,CAAC;AAEzB;;GAEG;AACH,MAAM,WAAW,SAAS;IACxB,QAAQ,EAAE,IAAI,EAAE,MAAM,GAAG,MAAM,GAAG,OAAO,GAAG,MAAM,CAAC;CACpD;AAED,cAAM,iBAAkB,SAAQ,SAAS;IACvC;;;OAGG;IACH,OAAO,CAAC,gBAAgB,CAAC,CAAc;IACvC,OAAO,CAAC,cAAc,CAAC,CAAc;gBAEzB,QAAQ,EAAE,QAAQ;IAc9B,MAAM,CAAC,SAAS,EAAE,SAAS;IAWlB,MAAM,CAAC,IAAI,EAAE,aAAa,EAAE,CAAC,SAAS,CAAC,EAAE,mBAAmB,CAAC,IAAI,CAAC;CAkD5E;AAED;;;;;;;;;;;;;GAaG;AACH,eAAO,MAAM,QAAQ,+FAA+B,CAAC;AAErD;;;GAGG;AACH,YAAY,EAAC,iBAAiB,EAAC,CAAC"}
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\class-map.js
================================================================================

/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
import { noChange } from '../lit-html.js';
import { directive, Directive, PartType, } from '../directive.js';
class ClassMapDirective extends Directive {
    constructor(partInfo) {
        super(partInfo);
        if (partInfo.type !== PartType.ATTRIBUTE ||
            partInfo.name !== 'class' ||
            partInfo.strings?.length > 2) {
            throw new Error('`classMap()` can only be used in the `class` attribute ' +
                'and must be the only part in the attribute.');
        }
    }
    render(classInfo) {
        // Add spaces to ensure separation from static classes
        return (' ' +
            Object.keys(classInfo)
                .filter((key) => classInfo[key])
                .join(' ') +
            ' ');
    }
    update(part, [classInfo]) {
        // Remember dynamic classes on the first render
        if (this._previousClasses === undefined) {
            this._previousClasses = new Set();
            if (part.strings !== undefined) {
                this._staticClasses = new Set(part.strings
                    .join(' ')
                    .split(/\s/)
                    .filter((s) => s !== ''));
            }
            for (const name in classInfo) {
                if (classInfo[name] && !this._staticClasses?.has(name)) {
                    this._previousClasses.add(name);
                }
            }
            return this.render(classInfo);
        }
        const classList = part.element.classList;
        // Remove old classes that no longer apply
        for (const name of this._previousClasses) {
            if (!(name in classInfo)) {
                classList.remove(name);
                this._previousClasses.delete(name);
            }
        }
        // Add or remove classes based on their classMap value
        for (const name in classInfo) {
            // We explicitly want a loose truthy check of `value` because it seems
            // more convenient that '' and 0 are skipped.
            const value = !!classInfo[name];
            if (value !== this._previousClasses.has(name) &&
                !this._staticClasses?.has(name)) {
                if (value) {
                    classList.add(name);
                    this._previousClasses.add(name);
                }
                else {
                    classList.remove(name);
                    this._previousClasses.delete(name);
                }
            }
        }
        return noChange;
    }
}
/**
 * A directive that applies dynamic CSS classes.
 *
 * This must be used in the `class` attribute and must be the only part used in
 * the attribute. It takes each property in the `classInfo` argument and adds
 * the property name to the element's `classList` if the property value is
 * truthy; if the property value is falsy, the property name is removed from
 * the element's `class`.
 *
 * For example `{foo: bar}` applies the class `foo` if the value of `bar` is
 * truthy.
 *
 * @param classInfo
 */
export const classMap = directive(ClassMapDirective);
//# sourceMappingURL=class-map.js.map
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\class-map.js.map
================================================================================

{"version":3,"file":"class-map.js","sourceRoot":"","sources":["../../src/directives/class-map.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {AttributePart, noChange} from '../lit-html.js';\nimport {\n  directive,\n  Directive,\n  DirectiveParameters,\n  PartInfo,\n  PartType,\n} from '../directive.js';\n\n/**\n * A key-value set of class names to truthy values.\n */\nexport interface ClassInfo {\n  readonly [name: string]: string | boolean | number;\n}\n\nclass ClassMapDirective extends Directive {\n  /**\n   * Stores the ClassInfo object applied to a given AttributePart.\n   * Used to unset existing values when a new ClassInfo object is applied.\n   */\n  private _previousClasses?: Set<string>;\n  private _staticClasses?: Set<string>;\n\n  constructor(partInfo: PartInfo) {\n    super(partInfo);\n    if (\n      partInfo.type !== PartType.ATTRIBUTE ||\n      partInfo.name !== 'class' ||\n      (partInfo.strings?.length as number) > 2\n    ) {\n      throw new Error(\n        '`classMap()` can only be used in the `class` attribute ' +\n          'and must be the only part in the attribute.'\n      );\n    }\n  }\n\n  render(classInfo: ClassInfo) {\n    // Add spaces to ensure separation from static classes\n    return (\n      ' ' +\n      Object.keys(classInfo)\n        .filter((key) => classInfo[key])\n        .join(' ') +\n      ' '\n    );\n  }\n\n  override update(part: AttributePart, [classInfo]: DirectiveParameters<this>) {\n    // Remember dynamic classes on the first render\n    if (this._previousClasses === undefined) {\n      this._previousClasses = new Set();\n      if (part.strings !== undefined) {\n        this._staticClasses = new Set(\n          part.strings\n            .join(' ')\n            .split(/\\s/)\n            .filter((s) => s !== '')\n        );\n      }\n      for (const name in classInfo) {\n        if (classInfo[name] && !this._staticClasses?.has(name)) {\n          this._previousClasses.add(name);\n        }\n      }\n      return this.render(classInfo);\n    }\n\n    const classList = part.element.classList;\n\n    // Remove old classes that no longer apply\n    for (const name of this._previousClasses) {\n      if (!(name in classInfo)) {\n        classList.remove(name);\n        this._previousClasses!.delete(name);\n      }\n    }\n\n    // Add or remove classes based on their classMap value\n    for (const name in classInfo) {\n      // We explicitly want a loose truthy check of `value` because it seems\n      // more convenient that '' and 0 are skipped.\n      const value = !!classInfo[name];\n      if (\n        value !== this._previousClasses.has(name) &&\n        !this._staticClasses?.has(name)\n      ) {\n        if (value) {\n          classList.add(name);\n          this._previousClasses.add(name);\n        } else {\n          classList.remove(name);\n          this._previousClasses.delete(name);\n        }\n      }\n    }\n    return noChange;\n  }\n}\n\n/**\n * A directive that applies dynamic CSS classes.\n *\n * This must be used in the `class` attribute and must be the only part used in\n * the attribute. It takes each property in the `classInfo` argument and adds\n * the property name to the element's `classList` if the property value is\n * truthy; if the property value is falsy, the property name is removed from\n * the element's `class`.\n *\n * For example `{foo: bar}` applies the class `foo` if the value of `bar` is\n * truthy.\n *\n * @param classInfo\n */\nexport const classMap = directive(ClassMapDirective);\n\n/**\n * The type of the class that powers this directive. Necessary for naming the\n * directive's return type.\n */\nexport type {ClassMapDirective};\n"]}
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\guard.d.ts
================================================================================

/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
import { Part } from '../lit-html.js';
import { Directive, DirectiveParameters } from '../directive.js';
declare class GuardDirective extends Directive {
    private _previousValue;
    render(_value: unknown, f: () => unknown): unknown;
    update(_part: Part, [value, f]: DirectiveParameters<this>): unknown;
}
/**
 * Prevents re-render of a template function until a single value or an array of
 * values changes.
 *
 * Values are checked against previous values with strict equality (`===`), and
 * so the check won't detect nested property changes inside objects or arrays.
 * Arrays values have each item checked against the previous value at the same
 * index with strict equality. Nested arrays are also checked only by strict
 * equality.
 *
 * Example:
 *
 * ```js
 * html`
 *   <div>
 *     ${guard([user.id, company.id], () => html`...`)}
 *   </div>
 * `
 * ```
 *
 * In this case, the template only rerenders if either `user.id` or `company.id`
 * changes.
 *
 * guard() is useful with immutable data patterns, by preventing expensive work
 * until data updates.
 *
 * Example:
 *
 * ```js
 * html`
 *   <div>
 *     ${guard([immutableItems], () => immutableItems.map(i => html`${i}`))}
 *   </div>
 * `
 * ```
 *
 * In this case, items are mapped over only when the array reference changes.
 *
 * @param value the value to check before re-rendering
 * @param f the template function
 */
export declare const guard: (_value: unknown, f: () => unknown) => import("../directive.js").DirectiveResult<typeof GuardDirective>;
/**
 * The type of the class that powers this directive. Necessary for naming the
 * directive's return type.
 */
export type { GuardDirective };
//# sourceMappingURL=guard.d.ts.map
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\guard.d.ts.map
================================================================================

{"version":3,"file":"guard.d.ts","sourceRoot":"","sources":["../../src/directives/guard.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAEH,OAAO,EAAW,IAAI,EAAC,MAAM,gBAAgB,CAAC;AAC9C,OAAO,EAAY,SAAS,EAAE,mBAAmB,EAAC,MAAM,iBAAiB,CAAC;AAK1E,cAAM,cAAe,SAAQ,SAAS;IACpC,OAAO,CAAC,cAAc,CAAyB;IAE/C,MAAM,CAAC,MAAM,EAAE,OAAO,EAAE,CAAC,EAAE,MAAM,OAAO;IAI/B,MAAM,CAAC,KAAK,EAAE,IAAI,EAAE,CAAC,KAAK,EAAE,CAAC,CAAC,EAAE,mBAAmB,CAAC,IAAI,CAAC;CAqBnE;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAwCG;AACH,eAAO,MAAM,KAAK,6BApEiB,OAAO,qEAoEI,CAAC;AAE/C;;;GAGG;AACH,YAAY,EAAC,cAAc,EAAC,CAAC"}
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\guard.js
================================================================================

/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
import { noChange } from '../lit-html.js';
import { directive, Directive } from '../directive.js';
// A sentinel that indicates guard() hasn't rendered anything yet
const initialValue = {};
class GuardDirective extends Directive {
    constructor() {
        super(...arguments);
        this._previousValue = initialValue;
    }
    render(_value, f) {
        return f();
    }
    update(_part, [value, f]) {
        if (Array.isArray(value)) {
            // Dirty-check arrays by item
            if (Array.isArray(this._previousValue) &&
                this._previousValue.length === value.length &&
                value.every((v, i) => v === this._previousValue[i])) {
                return noChange;
            }
        }
        else if (this._previousValue === value) {
            // Dirty-check non-arrays by identity
            return noChange;
        }
        // Copy the value if it's an array so that if it's mutated we don't forget
        // what the previous values were.
        this._previousValue = Array.isArray(value) ? Array.from(value) : value;
        const r = this.render(value, f);
        return r;
    }
}
/**
 * Prevents re-render of a template function until a single value or an array of
 * values changes.
 *
 * Values are checked against previous values with strict equality (`===`), and
 * so the check won't detect nested property changes inside objects or arrays.
 * Arrays values have each item checked against the previous value at the same
 * index with strict equality. Nested arrays are also checked only by strict
 * equality.
 *
 * Example:
 *
 * ```js
 * html`
 *   <div>
 *     ${guard([user.id, company.id], () => html`...`)}
 *   </div>
 * `
 * ```
 *
 * In this case, the template only rerenders if either `user.id` or `company.id`
 * changes.
 *
 * guard() is useful with immutable data patterns, by preventing expensive work
 * until data updates.
 *
 * Example:
 *
 * ```js
 * html`
 *   <div>
 *     ${guard([immutableItems], () => immutableItems.map(i => html`${i}`))}
 *   </div>
 * `
 * ```
 *
 * In this case, items are mapped over only when the array reference changes.
 *
 * @param value the value to check before re-rendering
 * @param f the template function
 */
export const guard = directive(GuardDirective);
//# sourceMappingURL=guard.js.map
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\guard.js.map
================================================================================

{"version":3,"file":"guard.js","sourceRoot":"","sources":["../../src/directives/guard.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAEH,OAAO,EAAC,QAAQ,EAAO,MAAM,gBAAgB,CAAC;AAC9C,OAAO,EAAC,SAAS,EAAE,SAAS,EAAsB,MAAM,iBAAiB,CAAC;AAE1E,iEAAiE;AACjE,MAAM,YAAY,GAAG,EAAE,CAAC;AAExB,MAAM,cAAe,SAAQ,SAAS;IAAtC;;QACU,mBAAc,GAAY,YAAY,CAAC;IA2BjD,CAAC;IAzBC,MAAM,CAAC,MAAe,EAAE,CAAgB;QACtC,OAAO,CAAC,EAAE,CAAC;IACb,CAAC;IAEQ,MAAM,CAAC,KAAW,EAAE,CAAC,KAAK,EAAE,CAAC,CAA4B;QAChE,IAAI,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE,CAAC;YACzB,6BAA6B;YAC7B,IACE,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,cAAc,CAAC;gBAClC,IAAI,CAAC,cAAc,CAAC,MAAM,KAAK,KAAK,CAAC,MAAM;gBAC3C,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,KAAM,IAAI,CAAC,cAAiC,CAAC,CAAC,CAAC,CAAC,EACvE,CAAC;gBACD,OAAO,QAAQ,CAAC;YAClB,CAAC;QACH,CAAC;aAAM,IAAI,IAAI,CAAC,cAAc,KAAK,KAAK,EAAE,CAAC;YACzC,qCAAqC;YACrC,OAAO,QAAQ,CAAC;QAClB,CAAC;QAED,0EAA0E;QAC1E,iCAAiC;QACjC,IAAI,CAAC,cAAc,GAAG,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;QACvE,MAAM,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;QAChC,OAAO,CAAC,CAAC;IACX,CAAC;CACF;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAwCG;AACH,MAAM,CAAC,MAAM,KAAK,GAAG,SAAS,CAAC,cAAc,CAAC,CAAC","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {noChange, Part} from '../lit-html.js';\nimport {directive, Directive, DirectiveParameters} from '../directive.js';\n\n// A sentinel that indicates guard() hasn't rendered anything yet\nconst initialValue = {};\n\nclass GuardDirective extends Directive {\n  private _previousValue: unknown = initialValue;\n\n  render(_value: unknown, f: () => unknown) {\n    return f();\n  }\n\n  override update(_part: Part, [value, f]: DirectiveParameters<this>) {\n    if (Array.isArray(value)) {\n      // Dirty-check arrays by item\n      if (\n        Array.isArray(this._previousValue) &&\n        this._previousValue.length === value.length &&\n        value.every((v, i) => v === (this._previousValue as Array<unknown>)[i])\n      ) {\n        return noChange;\n      }\n    } else if (this._previousValue === value) {\n      // Dirty-check non-arrays by identity\n      return noChange;\n    }\n\n    // Copy the value if it's an array so that if it's mutated we don't forget\n    // what the previous values were.\n    this._previousValue = Array.isArray(value) ? Array.from(value) : value;\n    const r = this.render(value, f);\n    return r;\n  }\n}\n\n/**\n * Prevents re-render of a template function until a single value or an array of\n * values changes.\n *\n * Values are checked against previous values with strict equality (`===`), and\n * so the check won't detect nested property changes inside objects or arrays.\n * Arrays values have each item checked against the previous value at the same\n * index with strict equality. Nested arrays are also checked only by strict\n * equality.\n *\n * Example:\n *\n * ```js\n * html`\n *   <div>\n *     ${guard([user.id, company.id], () => html`...`)}\n *   </div>\n * `\n * ```\n *\n * In this case, the template only rerenders if either `user.id` or `company.id`\n * changes.\n *\n * guard() is useful with immutable data patterns, by preventing expensive work\n * until data updates.\n *\n * Example:\n *\n * ```js\n * html`\n *   <div>\n *     ${guard([immutableItems], () => immutableItems.map(i => html`${i}`))}\n *   </div>\n * `\n * ```\n *\n * In this case, items are mapped over only when the array reference changes.\n *\n * @param value the value to check before re-rendering\n * @param f the template function\n */\nexport const guard = directive(GuardDirective);\n\n/**\n * The type of the class that powers this directive. Necessary for naming the\n * directive's return type.\n */\nexport type {GuardDirective};\n"]}
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\if-defined.d.ts
================================================================================

/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
import { nothing } from '../lit-html.js';
/**
 * For AttributeParts, sets the attribute if the value is defined and removes
 * the attribute if the value is undefined.
 *
 * For other part types, this directive is a no-op.
 */
export declare const ifDefined: <T>(value: T) => typeof nothing | NonNullable<T>;
//# sourceMappingURL=if-defined.d.ts.map
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\if-defined.d.ts.map
================================================================================

{"version":3,"file":"if-defined.d.ts","sourceRoot":"","sources":["../../src/directives/if-defined.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAEH,OAAO,EAAC,OAAO,EAAC,MAAM,gBAAgB,CAAC;AAEvC;;;;;GAKG;AACH,eAAO,MAAM,SAAS,GAAI,CAAC,SAAS,CAAC,oCAAqB,CAAC"}
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\if-defined.js
================================================================================

/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
import { nothing } from '../lit-html.js';
/**
 * For AttributeParts, sets the attribute if the value is defined and removes
 * the attribute if the value is undefined.
 *
 * For other part types, this directive is a no-op.
 */
export const ifDefined = (value) => value ?? nothing;
//# sourceMappingURL=if-defined.js.map
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\if-defined.js.map
================================================================================

{"version":3,"file":"if-defined.js","sourceRoot":"","sources":["../../src/directives/if-defined.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAEH,OAAO,EAAC,OAAO,EAAC,MAAM,gBAAgB,CAAC;AAEvC;;;;;GAKG;AACH,MAAM,CAAC,MAAM,SAAS,GAAG,CAAI,KAAQ,EAAE,EAAE,CAAC,KAAK,IAAI,OAAO,CAAC","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {nothing} from '../lit-html.js';\n\n/**\n * For AttributeParts, sets the attribute if the value is defined and removes\n * the attribute if the value is undefined.\n *\n * For other part types, this directive is a no-op.\n */\nexport const ifDefined = <T>(value: T) => value ?? nothing;\n"]}
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\join.d.ts
================================================================================

/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
/**
 * Returns an iterable containing the values in `items` interleaved with the
 * `joiner` value.
 *
 * @example
 *
 * ```ts
 * render() {
 *   return html`
 *     ${join(items, html`<span class="separator">|</span>`)}
 *   `;
 * }
 */
export declare function join<I, J>(items: Iterable<I> | undefined, joiner: (index: number) => J): Iterable<I | J>;
export declare function join<I, J>(items: Iterable<I> | undefined, joiner: J): Iterable<I | J>;
//# sourceMappingURL=join.d.ts.map
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\join.d.ts.map
================================================================================

{"version":3,"file":"join.d.ts","sourceRoot":"","sources":["../../src/directives/join.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAEH;;;;;;;;;;;;GAYG;AACH,wBAAgB,IAAI,CAAC,CAAC,EAAE,CAAC,EACvB,KAAK,EAAE,QAAQ,CAAC,CAAC,CAAC,GAAG,SAAS,EAC9B,MAAM,EAAE,CAAC,KAAK,EAAE,MAAM,KAAK,CAAC,GAC3B,QAAQ,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;AACnB,wBAAgB,IAAI,CAAC,CAAC,EAAE,CAAC,EACvB,KAAK,EAAE,QAAQ,CAAC,CAAC,CAAC,GAAG,SAAS,EAC9B,MAAM,EAAE,CAAC,GACR,QAAQ,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC"}
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\join.js
================================================================================

/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
export function* join(items, joiner) {
    const isFunction = typeof joiner === 'function';
    if (items !== undefined) {
        let i = -1;
        for (const value of items) {
            if (i > -1) {
                yield isFunction ? joiner(i) : joiner;
            }
            i++;
            yield value;
        }
    }
}
//# sourceMappingURL=join.js.map
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\join.js.map
================================================================================

{"version":3,"file":"join.js","sourceRoot":"","sources":["../../src/directives/join.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAuBH,MAAM,SAAS,CAAC,CAAC,IAAI,CAAO,KAA8B,EAAE,MAAS;IACnE,MAAM,UAAU,GAAG,OAAO,MAAM,KAAK,UAAU,CAAC;IAChD,IAAI,KAAK,KAAK,SAAS,EAAE,CAAC;QACxB,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;QACX,KAAK,MAAM,KAAK,IAAI,KAAK,EAAE,CAAC;YAC1B,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC;gBACX,MAAM,UAAU,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC;YACxC,CAAC;YACD,CAAC,EAAE,CAAC;YACJ,MAAM,KAAK,CAAC;QACd,CAAC;IACH,CAAC;AACH,CAAC","sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n/**\n * Returns an iterable containing the values in `items` interleaved with the\n * `joiner` value.\n *\n * @example\n *\n * ```ts\n * render() {\n *   return html`\n *     ${join(items, html`<span class=\"separator\">|</span>`)}\n *   `;\n * }\n */\nexport function join<I, J>(\n  items: Iterable<I> | undefined,\n  joiner: (index: number) => J\n): Iterable<I | J>;\nexport function join<I, J>(\n  items: Iterable<I> | undefined,\n  joiner: J\n): Iterable<I | J>;\nexport function* join<I, J>(items: Iterable<I> | undefined, joiner: J) {\n  const isFunction = typeof joiner === 'function';\n  if (items !== undefined) {\n    let i = -1;\n    for (const value of items) {\n      if (i > -1) {\n        yield isFunction ? joiner(i) : joiner;\n      }\n      i++;\n      yield value;\n    }\n  }\n}\n"]}
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\keyed.d.ts
================================================================================

/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
import { Directive, ChildPart, DirectiveParameters } from '../directive.js';
declare class Keyed extends Directive {
    key: unknown;
    render(k: unknown, v: unknown): unknown;
    update(part: ChildPart, [k, v]: DirectiveParameters<this>): unknown;
}
/**
 * Associates a renderable value with a unique key. When the key changes, the
 * previous DOM is removed and disposed before rendering the next value, even
 * if the value - such as a template - is the same.
 *
 * This is useful for forcing re-renders of stateful components, or working
 * with code that expects new data to generate new HTML elements, such as some
 * animation techniques.
 */
export declare const keyed: (k: unknown, v: unknown) => import("../directive.js").DirectiveResult<typeof Keyed>;
/**
 * The type of the class that powers this directive. Necessary for naming the
 * directive's return type.
 */
export type { Keyed };
//# sourceMappingURL=keyed.d.ts.map
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\keyed.d.ts.map
================================================================================

{"version":3,"file":"keyed.d.ts","sourceRoot":"","sources":["../../src/directives/keyed.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAGH,OAAO,EAEL,SAAS,EACT,SAAS,EACT,mBAAmB,EACpB,MAAM,iBAAiB,CAAC;AAGzB,cAAM,KAAM,SAAQ,SAAS;IAC3B,GAAG,EAAE,OAAO,CAAW;IAEvB,MAAM,CAAC,CAAC,EAAE,OAAO,EAAE,CAAC,EAAE,OAAO;IAKpB,MAAM,CAAC,IAAI,EAAE,SAAS,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,mBAAmB,CAAC,IAAI,CAAC;CAUnE;AAED;;;;;;;;GAQG;AACH,eAAO,MAAM,KAAK,qFAAmB,CAAC;AAEtC;;;GAGG;AACH,YAAY,EAAC,KAAK,EAAC,CAAC"}
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\keyed.js
================================================================================

/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
import { nothing } from '../lit-html.js';
import { directive, Directive, } from '../directive.js';
import { setCommittedValue } from '../directive-helpers.js';
class Keyed extends Directive {
    constructor() {
        super(...arguments);
        this.key = nothing;
    }
    render(k, v) {
        this.key = k;
        return v;
    }
    update(part, [k, v]) {
        if (k !== this.key) {
            // Clear the part before returning a value. The one-arg form of
            // setCommittedValue sets the value to a sentinel which forces a
            // commit the next render.
            setCommittedValue(part);
            this.key = k;
        }
        return v;
    }
}
/**
 * Associates a renderable value with a unique key. When the key changes, the
 * previous DOM is removed and disposed before rendering the next value, even
 * if the value - such as a template - is the same.
 *
 * This is useful for forcing re-renders of stateful components, or working
 * with code that expects new data to generate new HTML elements, such as some
 * animation techniques.
 */
export const keyed = directive(Keyed);
//# sourceMappingURL=keyed.js.map
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\keyed.js.map
================================================================================

{"version":3,"file":"keyed.js","sourceRoot":"","sources":["../../src/directives/keyed.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAEH,OAAO,EAAC,OAAO,EAAC,MAAM,gBAAgB,CAAC;AACvC,OAAO,EACL,SAAS,EACT,SAAS,GAGV,MAAM,iBAAiB,CAAC;AACzB,OAAO,EAAC,iBAAiB,EAAC,MAAM,yBAAyB,CAAC;AAE1D,MAAM,KAAM,SAAQ,SAAS;IAA7B;;QACE,QAAG,GAAY,OAAO,CAAC;IAiBzB,CAAC;IAfC,MAAM,CAAC,CAAU,EAAE,CAAU;QAC3B,IAAI,CAAC,GAAG,GAAG,CAAC,CAAC;QACb,OAAO,CAAC,CAAC;IACX,CAAC;IAEQ,MAAM,CAAC,IAAe,EAAE,CAAC,CAAC,EAAE,CAAC,CAA4B;QAChE,IAAI,CAAC,KAAK,IAAI,CAAC,GAAG,EAAE,CAAC;YACnB,+DAA+D;YAC/D,gEAAgE;YAChE,0BAA0B;YAC1B,iBAAiB,CAAC,IAAI,CAAC,CAAC;YACxB,IAAI,CAAC,GAAG,GAAG,CAAC,CAAC;QACf,CAAC;QACD,OAAO,CAAC,CAAC;IACX,CAAC;CACF;AAED;;;;;;;;GAQG;AACH,MAAM,CAAC,MAAM,KAAK,GAAG,SAAS,CAAC,KAAK,CAAC,CAAC","sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {nothing} from '../lit-html.js';\nimport {\n  directive,\n  Directive,\n  ChildPart,\n  DirectiveParameters,\n} from '../directive.js';\nimport {setCommittedValue} from '../directive-helpers.js';\n\nclass Keyed extends Directive {\n  key: unknown = nothing;\n\n  render(k: unknown, v: unknown) {\n    this.key = k;\n    return v;\n  }\n\n  override update(part: ChildPart, [k, v]: DirectiveParameters<this>) {\n    if (k !== this.key) {\n      // Clear the part before returning a value. The one-arg form of\n      // setCommittedValue sets the value to a sentinel which forces a\n      // commit the next render.\n      setCommittedValue(part);\n      this.key = k;\n    }\n    return v;\n  }\n}\n\n/**\n * Associates a renderable value with a unique key. When the key changes, the\n * previous DOM is removed and disposed before rendering the next value, even\n * if the value - such as a template - is the same.\n *\n * This is useful for forcing re-renders of stateful components, or working\n * with code that expects new data to generate new HTML elements, such as some\n * animation techniques.\n */\nexport const keyed = directive(Keyed);\n\n/**\n * The type of the class that powers this directive. Necessary for naming the\n * directive's return type.\n */\nexport type {Keyed};\n"]}
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\live.d.ts
================================================================================

/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
import { AttributePart } from '../lit-html.js';
import { Directive, DirectiveParameters, PartInfo } from '../directive.js';
declare class LiveDirective extends Directive {
    constructor(partInfo: PartInfo);
    render(value: unknown): unknown;
    update(part: AttributePart, [value]: DirectiveParameters<this>): unknown;
}
/**
 * Checks binding values against live DOM values, instead of previously bound
 * values, when determining whether to update the value.
 *
 * This is useful for cases where the DOM value may change from outside of
 * lit-html, such as with a binding to an `<input>` element's `value` property,
 * a content editable elements text, or to a custom element that changes it's
 * own properties or attributes.
 *
 * In these cases if the DOM value changes, but the value set through lit-html
 * bindings hasn't, lit-html won't know to update the DOM value and will leave
 * it alone. If this is not what you want--if you want to overwrite the DOM
 * value with the bound value no matter what--use the `live()` directive:
 *
 * ```js
 * html`<input .value=${live(x)}>`
 * ```
 *
 * `live()` performs a strict equality check against the live DOM value, and if
 * the new value is equal to the live value, does nothing. This means that
 * `live()` should not be used when the binding will cause a type conversion. If
 * you use `live()` with an attribute binding, make sure that only strings are
 * passed in, or the binding will update every render.
 */
export declare const live: (value: unknown) => import("../directive.js").DirectiveResult<typeof LiveDirective>;
/**
 * The type of the class that powers this directive. Necessary for naming the
 * directive's return type.
 */
export type { LiveDirective };
//# sourceMappingURL=live.d.ts.map
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\live.d.ts.map
================================================================================

{"version":3,"file":"live.d.ts","sourceRoot":"","sources":["../../src/directives/live.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAEH,OAAO,EAAC,aAAa,EAAoB,MAAM,gBAAgB,CAAC;AAChE,OAAO,EAEL,SAAS,EACT,mBAAmB,EACnB,QAAQ,EAET,MAAM,iBAAiB,CAAC;AAGzB,cAAM,aAAc,SAAQ,SAAS;gBACvB,QAAQ,EAAE,QAAQ;IAkB9B,MAAM,CAAC,KAAK,EAAE,OAAO;IAIZ,MAAM,CAAC,IAAI,EAAE,aAAa,EAAE,CAAC,KAAK,CAAC,EAAE,mBAAmB,CAAC,IAAI,CAAC;CA0BxE;AAED;;;;;;;;;;;;;;;;;;;;;;;GAuBG;AACH,eAAO,MAAM,IAAI,qFAA2B,CAAC;AAE7C;;;GAGG;AACH,YAAY,EAAC,aAAa,EAAC,CAAC"}
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\live.js
================================================================================

/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
import { noChange, nothing } from '../lit-html.js';
import { directive, Directive, PartType, } from '../directive.js';
import { isSingleExpression, setCommittedValue } from '../directive-helpers.js';
class LiveDirective extends Directive {
    constructor(partInfo) {
        super(partInfo);
        if (!(partInfo.type === PartType.PROPERTY ||
            partInfo.type === PartType.ATTRIBUTE ||
            partInfo.type === PartType.BOOLEAN_ATTRIBUTE)) {
            throw new Error('The `live` directive is not allowed on child or event bindings');
        }
        if (!isSingleExpression(partInfo)) {
            throw new Error('`live` bindings can only contain a single expression');
        }
    }
    render(value) {
        return value;
    }
    update(part, [value]) {
        if (value === noChange || value === nothing) {
            return value;
        }
        const element = part.element;
        const name = part.name;
        if (part.type === PartType.PROPERTY) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            if (value === element[name]) {
                return noChange;
            }
        }
        else if (part.type === PartType.BOOLEAN_ATTRIBUTE) {
            if (!!value === element.hasAttribute(name)) {
                return noChange;
            }
        }
        else if (part.type === PartType.ATTRIBUTE) {
            if (element.getAttribute(name) === String(value)) {
                return noChange;
            }
        }
        // Resets the part's value, causing its dirty-check to fail so that it
        // always sets the value.
        setCommittedValue(part);
        return value;
    }
}
/**
 * Checks binding values against live DOM values, instead of previously bound
 * values, when determining whether to update the value.
 *
 * This is useful for cases where the DOM value may change from outside of
 * lit-html, such as with a binding to an `<input>` element's `value` property,
 * a content editable elements text, or to a custom element that changes it's
 * own properties or attributes.
 *
 * In these cases if the DOM value changes, but the value set through lit-html
 * bindings hasn't, lit-html won't know to update the DOM value and will leave
 * it alone. If this is not what you want--if you want to overwrite the DOM
 * value with the bound value no matter what--use the `live()` directive:
 *
 * ```js
 * html`<input .value=${live(x)}>`
 * ```
 *
 * `live()` performs a strict equality check against the live DOM value, and if
 * the new value is equal to the live value, does nothing. This means that
 * `live()` should not be used when the binding will cause a type conversion. If
 * you use `live()` with an attribute binding, make sure that only strings are
 * passed in, or the binding will update every render.
 */
export const live = directive(LiveDirective);
//# sourceMappingURL=live.js.map
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\live.js.map
================================================================================

{"version":3,"file":"live.js","sourceRoot":"","sources":["../../src/directives/live.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAEH,OAAO,EAAgB,QAAQ,EAAE,OAAO,EAAC,MAAM,gBAAgB,CAAC;AAChE,OAAO,EACL,SAAS,EACT,SAAS,EAGT,QAAQ,GACT,MAAM,iBAAiB,CAAC;AACzB,OAAO,EAAC,kBAAkB,EAAE,iBAAiB,EAAC,MAAM,yBAAyB,CAAC;AAE9E,MAAM,aAAc,SAAQ,SAAS;IACnC,YAAY,QAAkB;QAC5B,KAAK,CAAC,QAAQ,CAAC,CAAC;QAChB,IACE,CAAC,CACC,QAAQ,CAAC,IAAI,KAAK,QAAQ,CAAC,QAAQ;YACnC,QAAQ,CAAC,IAAI,KAAK,QAAQ,CAAC,SAAS;YACpC,QAAQ,CAAC,IAAI,KAAK,QAAQ,CAAC,iBAAiB,CAC7C,EACD,CAAC;YACD,MAAM,IAAI,KAAK,CACb,gEAAgE,CACjE,CAAC;QACJ,CAAC;QACD,IAAI,CAAC,kBAAkB,CAAC,QAAQ,CAAC,EAAE,CAAC;YAClC,MAAM,IAAI,KAAK,CAAC,sDAAsD,CAAC,CAAC;QAC1E,CAAC;IACH,CAAC;IAED,MAAM,CAAC,KAAc;QACnB,OAAO,KAAK,CAAC;IACf,CAAC;IAEQ,MAAM,CAAC,IAAmB,EAAE,CAAC,KAAK,CAA4B;QACrE,IAAI,KAAK,KAAK,QAAQ,IAAI,KAAK,KAAK,OAAO,EAAE,CAAC;YAC5C,OAAO,KAAK,CAAC;QACf,CAAC;QACD,MAAM,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC;QAC7B,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;QAEvB,IAAI,IAAI,CAAC,IAAI,KAAK,QAAQ,CAAC,QAAQ,EAAE,CAAC;YACpC,8DAA8D;YAC9D,IAAI,KAAK,KAAM,OAAe,CAAC,IAAI,CAAC,EAAE,CAAC;gBACrC,OAAO,QAAQ,CAAC;YAClB,CAAC;QACH,CAAC;aAAM,IAAI,IAAI,CAAC,IAAI,KAAK,QAAQ,CAAC,iBAAiB,EAAE,CAAC;YACpD,IAAI,CAAC,CAAC,KAAK,KAAK,OAAO,CAAC,YAAY,CAAC,IAAI,CAAC,EAAE,CAAC;gBAC3C,OAAO,QAAQ,CAAC;YAClB,CAAC;QACH,CAAC;aAAM,IAAI,IAAI,CAAC,IAAI,KAAK,QAAQ,CAAC,SAAS,EAAE,CAAC;YAC5C,IAAI,OAAO,CAAC,YAAY,CAAC,IAAI,CAAC,KAAK,MAAM,CAAC,KAAK,CAAC,EAAE,CAAC;gBACjD,OAAO,QAAQ,CAAC;YAClB,CAAC;QACH,CAAC;QACD,sEAAsE;QACtE,yBAAyB;QACzB,iBAAiB,CAAC,IAAI,CAAC,CAAC;QACxB,OAAO,KAAK,CAAC;IACf,CAAC;CACF;AAED;;;;;;;;;;;;;;;;;;;;;;;GAuBG;AACH,MAAM,CAAC,MAAM,IAAI,GAAG,SAAS,CAAC,aAAa,CAAC,CAAC","sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {AttributePart, noChange, nothing} from '../lit-html.js';\nimport {\n  directive,\n  Directive,\n  DirectiveParameters,\n  PartInfo,\n  PartType,\n} from '../directive.js';\nimport {isSingleExpression, setCommittedValue} from '../directive-helpers.js';\n\nclass LiveDirective extends Directive {\n  constructor(partInfo: PartInfo) {\n    super(partInfo);\n    if (\n      !(\n        partInfo.type === PartType.PROPERTY ||\n        partInfo.type === PartType.ATTRIBUTE ||\n        partInfo.type === PartType.BOOLEAN_ATTRIBUTE\n      )\n    ) {\n      throw new Error(\n        'The `live` directive is not allowed on child or event bindings'\n      );\n    }\n    if (!isSingleExpression(partInfo)) {\n      throw new Error('`live` bindings can only contain a single expression');\n    }\n  }\n\n  render(value: unknown) {\n    return value;\n  }\n\n  override update(part: AttributePart, [value]: DirectiveParameters<this>) {\n    if (value === noChange || value === nothing) {\n      return value;\n    }\n    const element = part.element;\n    const name = part.name;\n\n    if (part.type === PartType.PROPERTY) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      if (value === (element as any)[name]) {\n        return noChange;\n      }\n    } else if (part.type === PartType.BOOLEAN_ATTRIBUTE) {\n      if (!!value === element.hasAttribute(name)) {\n        return noChange;\n      }\n    } else if (part.type === PartType.ATTRIBUTE) {\n      if (element.getAttribute(name) === String(value)) {\n        return noChange;\n      }\n    }\n    // Resets the part's value, causing its dirty-check to fail so that it\n    // always sets the value.\n    setCommittedValue(part);\n    return value;\n  }\n}\n\n/**\n * Checks binding values against live DOM values, instead of previously bound\n * values, when determining whether to update the value.\n *\n * This is useful for cases where the DOM value may change from outside of\n * lit-html, such as with a binding to an `<input>` element's `value` property,\n * a content editable elements text, or to a custom element that changes it's\n * own properties or attributes.\n *\n * In these cases if the DOM value changes, but the value set through lit-html\n * bindings hasn't, lit-html won't know to update the DOM value and will leave\n * it alone. If this is not what you want--if you want to overwrite the DOM\n * value with the bound value no matter what--use the `live()` directive:\n *\n * ```js\n * html`<input .value=${live(x)}>`\n * ```\n *\n * `live()` performs a strict equality check against the live DOM value, and if\n * the new value is equal to the live value, does nothing. This means that\n * `live()` should not be used when the binding will cause a type conversion. If\n * you use `live()` with an attribute binding, make sure that only strings are\n * passed in, or the binding will update every render.\n */\nexport const live = directive(LiveDirective);\n\n/**\n * The type of the class that powers this directive. Necessary for naming the\n * directive's return type.\n */\nexport type {LiveDirective};\n"]}
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\map.d.ts
================================================================================

/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
/**
 * Returns an iterable containing the result of calling `f(value)` on each
 * value in `items`.
 *
 * @example
 *
 * ```ts
 * render() {
 *   return html`
 *     <ul>
 *       ${map(items, (i) => html`<li>${i}</li>`)}
 *     </ul>
 *   `;
 * }
 * ```
 */
export declare function map<T>(items: Iterable<T> | undefined, f: (value: T, index: number) => unknown): Generator<unknown, void, unknown>;
//# sourceMappingURL=map.d.ts.map
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\map.d.ts.map
================================================================================

{"version":3,"file":"map.d.ts","sourceRoot":"","sources":["../../src/directives/map.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAEH;;;;;;;;;;;;;;;GAeG;AACH,wBAAiB,GAAG,CAAC,CAAC,EACpB,KAAK,EAAE,QAAQ,CAAC,CAAC,CAAC,GAAG,SAAS,EAC9B,CAAC,EAAE,CAAC,KAAK,EAAE,CAAC,EAAE,KAAK,EAAE,MAAM,KAAK,OAAO,qCAQxC"}
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\map.js
================================================================================

/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
/**
 * Returns an iterable containing the result of calling `f(value)` on each
 * value in `items`.
 *
 * @example
 *
 * ```ts
 * render() {
 *   return html`
 *     <ul>
 *       ${map(items, (i) => html`<li>${i}</li>`)}
 *     </ul>
 *   `;
 * }
 * ```
 */
export function* map(items, f) {
    if (items !== undefined) {
        let i = 0;
        for (const value of items) {
            yield f(value, i++);
        }
    }
}
//# sourceMappingURL=map.js.map
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\map.js.map
================================================================================

{"version":3,"file":"map.js","sourceRoot":"","sources":["../../src/directives/map.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAEH;;;;;;;;;;;;;;;GAeG;AACH,MAAM,SAAS,CAAC,CAAC,GAAG,CAClB,KAA8B,EAC9B,CAAuC;IAEvC,IAAI,KAAK,KAAK,SAAS,EAAE,CAAC;QACxB,IAAI,CAAC,GAAG,CAAC,CAAC;QACV,KAAK,MAAM,KAAK,IAAI,KAAK,EAAE,CAAC;YAC1B,MAAM,CAAC,CAAC,KAAK,EAAE,CAAC,EAAE,CAAC,CAAC;QACtB,CAAC;IACH,CAAC;AACH,CAAC","sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n/**\n * Returns an iterable containing the result of calling `f(value)` on each\n * value in `items`.\n *\n * @example\n *\n * ```ts\n * render() {\n *   return html`\n *     <ul>\n *       ${map(items, (i) => html`<li>${i}</li>`)}\n *     </ul>\n *   `;\n * }\n * ```\n */\nexport function* map<T>(\n  items: Iterable<T> | undefined,\n  f: (value: T, index: number) => unknown\n) {\n  if (items !== undefined) {\n    let i = 0;\n    for (const value of items) {\n      yield f(value, i++);\n    }\n  }\n}\n"]}
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\private-async-helpers.d.ts
================================================================================

/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
/**
 * Helper to iterate an AsyncIterable in its own closure.
 * @param iterable The iterable to iterate
 * @param callback The callback to call for each value. If the callback returns
 * `false`, the loop will be broken.
 */
export declare const forAwaitOf: <T>(iterable: AsyncIterable<T>, callback: (value: T) => Promise<boolean>) => Promise<void>;
/**
 * Holds a reference to an instance that can be disconnected and reconnected,
 * so that a closure over the ref (e.g. in a then function to a promise) does
 * not strongly hold a ref to the instance. Approximates a WeakRef but must
 * be manually connected & disconnected to the backing instance.
 */
export declare class PseudoWeakRef<T> {
    private _ref?;
    constructor(ref: T);
    /**
     * Disassociates the ref with the backing instance.
     */
    disconnect(): void;
    /**
     * Reassociates the ref with the backing instance.
     */
    reconnect(ref: T): void;
    /**
     * Retrieves the backing instance (will be undefined when disconnected)
     */
    deref(): T | undefined;
}
/**
 * A helper to pause and resume waiting on a condition in an async function
 */
export declare class Pauser {
    private _promise?;
    private _resolve?;
    /**
     * When paused, returns a promise to be awaited; when unpaused, returns
     * undefined. Note that in the microtask between the pauser being resumed
     * an await of this promise resolving, the pauser could be paused again,
     * hence callers should check the promise in a loop when awaiting.
     * @returns A promise to be awaited when paused or undefined
     */
    get(): Promise<void> | undefined;
    /**
     * Creates a promise to be awaited
     */
    pause(): void;
    /**
     * Resolves the promise which may be awaited
     */
    resume(): void;
}
//# sourceMappingURL=private-async-helpers.d.ts.map
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\private-async-helpers.d.ts.map
================================================================================

{"version":3,"file":"private-async-helpers.d.ts","sourceRoot":"","sources":["../../src/directives/private-async-helpers.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAMH;;;;;GAKG;AACH,eAAO,MAAM,UAAU,GAAU,CAAC,YACtB,aAAa,CAAC,CAAC,CAAC,YAChB,CAAC,KAAK,EAAE,CAAC,KAAK,OAAO,CAAC,OAAO,CAAC,kBAOzC,CAAC;AAEF;;;;;GAKG;AACH,qBAAa,aAAa,CAAC,CAAC;IAC1B,OAAO,CAAC,IAAI,CAAC,CAAI;gBACL,GAAG,EAAE,CAAC;IAGlB;;OAEG;IACH,UAAU;IAGV;;OAEG;IACH,SAAS,CAAC,GAAG,EAAE,CAAC;IAGhB;;OAEG;IACH,KAAK;CAGN;AAED;;GAEG;AACH,qBAAa,MAAM;IACjB,OAAO,CAAC,QAAQ,CAAC,CAA4B;IAC7C,OAAO,CAAC,QAAQ,CAAC,CAAyB;IAC1C;;;;;;OAMG;IACH,GAAG;IAGH;;OAEG;IACH,KAAK;IAGL;;OAEG;IACH,MAAM;CAIP"}
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\private-async-helpers.js
================================================================================

/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
// Note, this module is not included in package exports so that it's private to
// our first-party directives. If it ends up being useful, we can open it up and
// export it.
/**
 * Helper to iterate an AsyncIterable in its own closure.
 * @param iterable The iterable to iterate
 * @param callback The callback to call for each value. If the callback returns
 * `false`, the loop will be broken.
 */
export const forAwaitOf = async (iterable, callback) => {
    for await (const v of iterable) {
        if ((await callback(v)) === false) {
            return;
        }
    }
};
/**
 * Holds a reference to an instance that can be disconnected and reconnected,
 * so that a closure over the ref (e.g. in a then function to a promise) does
 * not strongly hold a ref to the instance. Approximates a WeakRef but must
 * be manually connected & disconnected to the backing instance.
 */
export class PseudoWeakRef {
    constructor(ref) {
        this._ref = ref;
    }
    /**
     * Disassociates the ref with the backing instance.
     */
    disconnect() {
        this._ref = undefined;
    }
    /**
     * Reassociates the ref with the backing instance.
     */
    reconnect(ref) {
        this._ref = ref;
    }
    /**
     * Retrieves the backing instance (will be undefined when disconnected)
     */
    deref() {
        return this._ref;
    }
}
/**
 * A helper to pause and resume waiting on a condition in an async function
 */
export class Pauser {
    constructor() {
        this._promise = undefined;
        this._resolve = undefined;
    }
    /**
     * When paused, returns a promise to be awaited; when unpaused, returns
     * undefined. Note that in the microtask between the pauser being resumed
     * an await of this promise resolving, the pauser could be paused again,
     * hence callers should check the promise in a loop when awaiting.
     * @returns A promise to be awaited when paused or undefined
     */
    get() {
        return this._promise;
    }
    /**
     * Creates a promise to be awaited
     */
    pause() {
        this._promise ??= new Promise((resolve) => (this._resolve = resolve));
    }
    /**
     * Resolves the promise which may be awaited
     */
    resume() {
        this._resolve?.();
        this._promise = this._resolve = undefined;
    }
}
//# sourceMappingURL=private-async-helpers.js.map
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\private-async-helpers.js.map
================================================================================

{"version":3,"file":"private-async-helpers.js","sourceRoot":"","sources":["../../src/directives/private-async-helpers.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAEH,+EAA+E;AAC/E,gFAAgF;AAChF,aAAa;AAEb;;;;;GAKG;AACH,MAAM,CAAC,MAAM,UAAU,GAAG,KAAK,EAC7B,QAA0B,EAC1B,QAAwC,EACxC,EAAE;IACF,IAAI,KAAK,EAAE,MAAM,CAAC,IAAI,QAAQ,EAAE,CAAC;QAC/B,IAAI,CAAC,MAAM,QAAQ,CAAC,CAAC,CAAC,CAAC,KAAK,KAAK,EAAE,CAAC;YAClC,OAAO;QACT,CAAC;IACH,CAAC;AACH,CAAC,CAAC;AAEF;;;;;GAKG;AACH,MAAM,OAAO,aAAa;IAExB,YAAY,GAAM;QAChB,IAAI,CAAC,IAAI,GAAG,GAAG,CAAC;IAClB,CAAC;IACD;;OAEG;IACH,UAAU;QACR,IAAI,CAAC,IAAI,GAAG,SAAS,CAAC;IACxB,CAAC;IACD;;OAEG;IACH,SAAS,CAAC,GAAM;QACd,IAAI,CAAC,IAAI,GAAG,GAAG,CAAC;IAClB,CAAC;IACD;;OAEG;IACH,KAAK;QACH,OAAO,IAAI,CAAC,IAAI,CAAC;IACnB,CAAC;CACF;AAED;;GAEG;AACH,MAAM,OAAO,MAAM;IAAnB;QACU,aAAQ,GAAmB,SAAS,CAAC;QACrC,aAAQ,GAAgB,SAAS,CAAC;IAwB5C,CAAC;IAvBC;;;;;;OAMG;IACH,GAAG;QACD,OAAO,IAAI,CAAC,QAAQ,CAAC;IACvB,CAAC;IACD;;OAEG;IACH,KAAK;QACH,IAAI,CAAC,QAAQ,KAAK,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC,CAAC,CAAC;IACxE,CAAC;IACD;;OAEG;IACH,MAAM;QACJ,IAAI,CAAC,QAAQ,EAAE,EAAE,CAAC;QAClB,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,QAAQ,GAAG,SAAS,CAAC;IAC5C,CAAC;CACF","sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n// Note, this module is not included in package exports so that it's private to\n// our first-party directives. If it ends up being useful, we can open it up and\n// export it.\n\n/**\n * Helper to iterate an AsyncIterable in its own closure.\n * @param iterable The iterable to iterate\n * @param callback The callback to call for each value. If the callback returns\n * `false`, the loop will be broken.\n */\nexport const forAwaitOf = async <T>(\n  iterable: AsyncIterable<T>,\n  callback: (value: T) => Promise<boolean>\n) => {\n  for await (const v of iterable) {\n    if ((await callback(v)) === false) {\n      return;\n    }\n  }\n};\n\n/**\n * Holds a reference to an instance that can be disconnected and reconnected,\n * so that a closure over the ref (e.g. in a then function to a promise) does\n * not strongly hold a ref to the instance. Approximates a WeakRef but must\n * be manually connected & disconnected to the backing instance.\n */\nexport class PseudoWeakRef<T> {\n  private _ref?: T;\n  constructor(ref: T) {\n    this._ref = ref;\n  }\n  /**\n   * Disassociates the ref with the backing instance.\n   */\n  disconnect() {\n    this._ref = undefined;\n  }\n  /**\n   * Reassociates the ref with the backing instance.\n   */\n  reconnect(ref: T) {\n    this._ref = ref;\n  }\n  /**\n   * Retrieves the backing instance (will be undefined when disconnected)\n   */\n  deref() {\n    return this._ref;\n  }\n}\n\n/**\n * A helper to pause and resume waiting on a condition in an async function\n */\nexport class Pauser {\n  private _promise?: Promise<void> = undefined;\n  private _resolve?: () => void = undefined;\n  /**\n   * When paused, returns a promise to be awaited; when unpaused, returns\n   * undefined. Note that in the microtask between the pauser being resumed\n   * an await of this promise resolving, the pauser could be paused again,\n   * hence callers should check the promise in a loop when awaiting.\n   * @returns A promise to be awaited when paused or undefined\n   */\n  get() {\n    return this._promise;\n  }\n  /**\n   * Creates a promise to be awaited\n   */\n  pause() {\n    this._promise ??= new Promise((resolve) => (this._resolve = resolve));\n  }\n  /**\n   * Resolves the promise which may be awaited\n   */\n  resume() {\n    this._resolve?.();\n    this._promise = this._resolve = undefined;\n  }\n}\n"]}
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\range.d.ts
================================================================================

/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
/**
 * Returns an iterable of integers from `start` to `end` (exclusive)
 * incrementing by `step`.
 *
 * If `start` is omitted, the range starts at `0`. `step` defaults to `1`.
 *
 * @example
 *
 * ```ts
 * render() {
 *   return html`
 *     ${map(range(8), () => html`<div class="cell"></div>`)}
 *   `;
 * }
 * ```
 */
export declare function range(end: number): Iterable<number>;
export declare function range(start: number, end: number, step?: number): Iterable<number>;
//# sourceMappingURL=range.d.ts.map
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\range.d.ts.map
================================================================================

{"version":3,"file":"range.d.ts","sourceRoot":"","sources":["../../src/directives/range.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAEH;;;;;;;;;;;;;;;GAeG;AACH,wBAAgB,KAAK,CAAC,GAAG,EAAE,MAAM,GAAG,QAAQ,CAAC,MAAM,CAAC,CAAC;AACrD,wBAAgB,KAAK,CACnB,KAAK,EAAE,MAAM,EACb,GAAG,EAAE,MAAM,EACX,IAAI,CAAC,EAAE,MAAM,GACZ,QAAQ,CAAC,MAAM,CAAC,CAAC"}
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\range.js
================================================================================

/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
export function* range(startOrEnd, end, step = 1) {
    const start = end === undefined ? 0 : startOrEnd;
    end ??= startOrEnd;
    for (let i = start; step > 0 ? i < end : end < i; i += step) {
        yield i;
    }
}
//# sourceMappingURL=range.js.map
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\range.js.map
================================================================================

{"version":3,"file":"range.js","sourceRoot":"","sources":["../../src/directives/range.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAwBH,MAAM,SAAS,CAAC,CAAC,KAAK,CAAC,UAAkB,EAAE,GAAY,EAAE,IAAI,GAAG,CAAC;IAC/D,MAAM,KAAK,GAAG,GAAG,KAAK,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC;IACjD,GAAG,KAAK,UAAU,CAAC;IACnB,KAAK,IAAI,CAAC,GAAG,KAAK,EAAE,IAAI,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,IAAI,IAAI,EAAE,CAAC;QAC5D,MAAM,CAAC,CAAC;IACV,CAAC;AACH,CAAC","sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n/**\n * Returns an iterable of integers from `start` to `end` (exclusive)\n * incrementing by `step`.\n *\n * If `start` is omitted, the range starts at `0`. `step` defaults to `1`.\n *\n * @example\n *\n * ```ts\n * render() {\n *   return html`\n *     ${map(range(8), () => html`<div class=\"cell\"></div>`)}\n *   `;\n * }\n * ```\n */\nexport function range(end: number): Iterable<number>;\nexport function range(\n  start: number,\n  end: number,\n  step?: number\n): Iterable<number>;\nexport function* range(startOrEnd: number, end?: number, step = 1) {\n  const start = end === undefined ? 0 : startOrEnd;\n  end ??= startOrEnd;\n  for (let i = start; step > 0 ? i < end : end < i; i += step) {\n    yield i;\n  }\n}\n"]}
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\ref.d.ts
================================================================================

/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
import { ElementPart } from '../lit-html.js';
import { AsyncDirective } from '../async-directive.js';
/**
 * Creates a new Ref object, which is container for a reference to an element.
 */
export declare const createRef: <T = Element>() => Ref<T>;
/**
 * An object that holds a ref value.
 */
declare class Ref<T = Element> {
    /**
     * The current Element value of the ref, or else `undefined` if the ref is no
     * longer rendered.
     */
    readonly value?: T;
}
export type { Ref };
export type RefOrCallback<T = Element> = Ref<T> | ((el: T | undefined) => void);
declare class RefDirective extends AsyncDirective {
    private _element?;
    private _ref?;
    private _context?;
    render(_ref?: RefOrCallback): symbol;
    update(part: ElementPart, [ref]: Parameters<this['render']>): symbol;
    private _updateRefValue;
    private get _lastElementForRef();
    disconnected(): void;
    reconnected(): void;
}
/**
 * Sets the value of a Ref object or calls a ref callback with the element it's
 * bound to.
 *
 * A Ref object acts as a container for a reference to an element. A ref
 * callback is a function that takes an element as its only argument.
 *
 * The ref directive sets the value of the Ref object or calls the ref callback
 * during rendering, if the referenced element changed.
 *
 * Note: If a ref callback is rendered to a different element position or is
 * removed in a subsequent render, it will first be called with `undefined`,
 * followed by another call with the new element it was rendered to (if any).
 *
 * ```js
 * // Using Ref object
 * const inputRef = createRef();
 * render(html`<input ${ref(inputRef)}>`, container);
 * inputRef.value.focus();
 *
 * // Using callback
 * const callback = (inputElement) => inputElement.focus();
 * render(html`<input ${ref(callback)}>`, container);
 * ```
 */
export declare const ref: (_ref?: RefOrCallback<Element> | undefined) => import("../directive.js").DirectiveResult<typeof RefDirective>;
/**
 * The type of the class that powers this directive. Necessary for naming the
 * directive's return type.
 */
export type { RefDirective };
//# sourceMappingURL=ref.d.ts.map
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\ref.d.ts.map
================================================================================

{"version":3,"file":"ref.d.ts","sourceRoot":"","sources":["../../src/directives/ref.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AACH,OAAO,EAAU,WAAW,EAAC,MAAM,gBAAgB,CAAC;AACpD,OAAO,EAAY,cAAc,EAAC,MAAM,uBAAuB,CAAC;AAEhE;;GAEG;AACH,eAAO,MAAM,SAAS,GAAI,CAAC,uBAA6B,CAAC;AAEzD;;GAEG;AACH,cAAM,GAAG,CAAC,CAAC,GAAG,OAAO;IACnB;;;OAGG;IACH,QAAQ,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;CACpB;AAED,YAAY,EAAC,GAAG,EAAC,CAAC;AAgBlB,MAAM,MAAM,aAAa,CAAC,CAAC,GAAG,OAAO,IAAI,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC,GAAG,SAAS,KAAK,IAAI,CAAC,CAAC;AAEhF,cAAM,YAAa,SAAQ,cAAc;IACvC,OAAO,CAAC,QAAQ,CAAC,CAAU;IAC3B,OAAO,CAAC,IAAI,CAAC,CAAgB;IAC7B,OAAO,CAAC,QAAQ,CAAC,CAAS;IAE1B,MAAM,CAAC,IAAI,CAAC,EAAE,aAAa;IAIlB,MAAM,CAAC,IAAI,EAAE,WAAW,EAAE,CAAC,GAAG,CAAC,EAAE,UAAU,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;IAiBpE,OAAO,CAAC,eAAe;IAkCvB,OAAO,KAAK,kBAAkB,GAM7B;IAEQ,YAAY;IAUZ,WAAW;CAKrB;AAED;;;;;;;;;;;;;;;;;;;;;;;;GAwBG;AACH,eAAO,MAAM,GAAG,+GAA0B,CAAC;AAE3C;;;GAGG;AACH,YAAY,EAAC,YAAY,EAAC,CAAC"}
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\ref.js
================================================================================

/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
import { nothing } from '../lit-html.js';
import { directive, AsyncDirective } from '../async-directive.js';
/**
 * Creates a new Ref object, which is container for a reference to an element.
 */
export const createRef = () => new Ref();
/**
 * An object that holds a ref value.
 */
class Ref {
}
// When callbacks are used for refs, this map tracks the last value the callback
// was called with, for ensuring a directive doesn't clear the ref if the ref
// has already been rendered to a new spot. It is double-keyed on both the
// context (`options.host`) and the callback, since we auto-bind class methods
// to `options.host`.
const lastElementForContextAndCallback = new WeakMap();
class RefDirective extends AsyncDirective {
    render(_ref) {
        return nothing;
    }
    update(part, [ref]) {
        const refChanged = ref !== this._ref;
        if (refChanged && this._ref !== undefined) {
            // The ref passed to the directive has changed;
            // unset the previous ref's value
            this._updateRefValue(undefined);
        }
        if (refChanged || this._lastElementForRef !== this._element) {
            // We either got a new ref or this is the first render;
            // store the ref/element & update the ref value
            this._ref = ref;
            this._context = part.options?.host;
            this._updateRefValue((this._element = part.element));
        }
        return nothing;
    }
    _updateRefValue(element) {
        if (!this.isConnected) {
            element = undefined;
        }
        if (typeof this._ref === 'function') {
            // If the current ref was called with a previous value, call with
            // `undefined`; We do this to ensure callbacks are called in a consistent
            // way regardless of whether a ref might be moving up in the tree (in
            // which case it would otherwise be called with the new value before the
            // previous one unsets it) and down in the tree (where it would be unset
            // before being set). Note that element lookup is keyed by
            // both the context and the callback, since we allow passing unbound
            // functions that are called on options.host, and we want to treat
            // these as unique "instances" of a function.
            const context = this._context ?? globalThis;
            let lastElementForCallback = lastElementForContextAndCallback.get(context);
            if (lastElementForCallback === undefined) {
                lastElementForCallback = new WeakMap();
                lastElementForContextAndCallback.set(context, lastElementForCallback);
            }
            if (lastElementForCallback.get(this._ref) !== undefined) {
                this._ref.call(this._context, undefined);
            }
            lastElementForCallback.set(this._ref, element);
            // Call the ref with the new element value
            if (element !== undefined) {
                this._ref.call(this._context, element);
            }
        }
        else {
            this._ref.value = element;
        }
    }
    get _lastElementForRef() {
        return typeof this._ref === 'function'
            ? lastElementForContextAndCallback
                .get(this._context ?? globalThis)
                ?.get(this._ref)
            : this._ref?.value;
    }
    disconnected() {
        // Only clear the box if our element is still the one in it (i.e. another
        // directive instance hasn't rendered its element to it before us); that
        // only happens in the event of the directive being cleared (not via manual
        // disconnection)
        if (this._lastElementForRef === this._element) {
            this._updateRefValue(undefined);
        }
    }
    reconnected() {
        // If we were manually disconnected, we can safely put our element back in
        // the box, since no rendering could have occurred to change its state
        this._updateRefValue(this._element);
    }
}
/**
 * Sets the value of a Ref object or calls a ref callback with the element it's
 * bound to.
 *
 * A Ref object acts as a container for a reference to an element. A ref
 * callback is a function that takes an element as its only argument.
 *
 * The ref directive sets the value of the Ref object or calls the ref callback
 * during rendering, if the referenced element changed.
 *
 * Note: If a ref callback is rendered to a different element position or is
 * removed in a subsequent render, it will first be called with `undefined`,
 * followed by another call with the new element it was rendered to (if any).
 *
 * ```js
 * // Using Ref object
 * const inputRef = createRef();
 * render(html`<input ${ref(inputRef)}>`, container);
 * inputRef.value.focus();
 *
 * // Using callback
 * const callback = (inputElement) => inputElement.focus();
 * render(html`<input ${ref(callback)}>`, container);
 * ```
 */
export const ref = directive(RefDirective);
//# sourceMappingURL=ref.js.map
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\ref.js.map
================================================================================

{"version":3,"file":"ref.js","sourceRoot":"","sources":["../../src/directives/ref.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport {nothing, ElementPart} from '../lit-html.js';\nimport {directive, AsyncDirective} from '../async-directive.js';\n\n/**\n * Creates a new Ref object, which is container for a reference to an element.\n */\nexport const createRef = <T = Element>() => new Ref<T>();\n\n/**\n * An object that holds a ref value.\n */\nclass Ref<T = Element> {\n  /**\n   * The current Element value of the ref, or else `undefined` if the ref is no\n   * longer rendered.\n   */\n  readonly value?: T;\n}\n\nexport type {Ref};\n\ninterface RefInternal {\n  value: Element | undefined;\n}\n\n// When callbacks are used for refs, this map tracks the last value the callback\n// was called with, for ensuring a directive doesn't clear the ref if the ref\n// has already been rendered to a new spot. It is double-keyed on both the\n// context (`options.host`) and the callback, since we auto-bind class methods\n// to `options.host`.\nconst lastElementForContextAndCallback = new WeakMap<\n  object,\n  WeakMap<Function, Element | undefined>\n>();\n\nexport type RefOrCallback<T = Element> = Ref<T> | ((el: T | undefined) => void);\n\nclass RefDirective extends AsyncDirective {\n  private _element?: Element;\n  private _ref?: RefOrCallback;\n  private _context?: object;\n\n  render(_ref?: RefOrCallback) {\n    return nothing;\n  }\n\n  override update(part: ElementPart, [ref]: Parameters<this['render']>) {\n    const refChanged = ref !== this._ref;\n    if (refChanged && this._ref !== undefined) {\n      // The ref passed to the directive has changed;\n      // unset the previous ref's value\n      this._updateRefValue(undefined);\n    }\n    if (refChanged || this._lastElementForRef !== this._element) {\n      // We either got a new ref or this is the first render;\n      // store the ref/element & update the ref value\n      this._ref = ref;\n      this._context = part.options?.host;\n      this._updateRefValue((this._element = part.element));\n    }\n    return nothing;\n  }\n\n  private _updateRefValue(element: Element | undefined) {\n    if (!this.isConnected) {\n      element = undefined;\n    }\n    if (typeof this._ref === 'function') {\n      // If the current ref was called with a previous value, call with\n      // `undefined`; We do this to ensure callbacks are called in a consistent\n      // way regardless of whether a ref might be moving up in the tree (in\n      // which case it would otherwise be called with the new value before the\n      // previous one unsets it) and down in the tree (where it would be unset\n      // before being set). Note that element lookup is keyed by\n      // both the context and the callback, since we allow passing unbound\n      // functions that are called on options.host, and we want to treat\n      // these as unique \"instances\" of a function.\n      const context = this._context ?? globalThis;\n      let lastElementForCallback =\n        lastElementForContextAndCallback.get(context);\n      if (lastElementForCallback === undefined) {\n        lastElementForCallback = new WeakMap();\n        lastElementForContextAndCallback.set(context, lastElementForCallback);\n      }\n      if (lastElementForCallback.get(this._ref) !== undefined) {\n        this._ref.call(this._context, undefined);\n      }\n      lastElementForCallback.set(this._ref, element);\n      // Call the ref with the new element value\n      if (element !== undefined) {\n        this._ref.call(this._context, element);\n      }\n    } else {\n      (this._ref as RefInternal)!.value = element;\n    }\n  }\n\n  private get _lastElementForRef() {\n    return typeof this._ref === 'function'\n      ? lastElementForContextAndCallback\n          .get(this._context ?? globalThis)\n          ?.get(this._ref)\n      : this._ref?.value;\n  }\n\n  override disconnected() {\n    // Only clear the box if our element is still the one in it (i.e. another\n    // directive instance hasn't rendered its element to it before us); that\n    // only happens in the event of the directive being cleared (not via manual\n    // disconnection)\n    if (this._lastElementForRef === this._element) {\n      this._updateRefValue(undefined);\n    }\n  }\n\n  override reconnected() {\n    // If we were manually disconnected, we can safely put our element back in\n    // the box, since no rendering could have occurred to change its state\n    this._updateRefValue(this._element);\n  }\n}\n\n/**\n * Sets the value of a Ref object or calls a ref callback with the element it's\n * bound to.\n *\n * A Ref object acts as a container for a reference to an element. A ref\n * callback is a function that takes an element as its only argument.\n *\n * The ref directive sets the value of the Ref object or calls the ref callback\n * during rendering, if the referenced element changed.\n *\n * Note: If a ref callback is rendered to a different element position or is\n * removed in a subsequent render, it will first be called with `undefined`,\n * followed by another call with the new element it was rendered to (if any).\n *\n * ```js\n * // Using Ref object\n * const inputRef = createRef();\n * render(html`<input ${ref(inputRef)}>`, container);\n * inputRef.value.focus();\n *\n * // Using callback\n * const callback = (inputElement) => inputElement.focus();\n * render(html`<input ${ref(callback)}>`, container);\n * ```\n */\nexport const ref = directive(RefDirective);\n\n/**\n * The type of the class that powers this directive. Necessary for naming the\n * directive's return type.\n */\nexport type {RefDirective};\n"]}
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\repeat.d.ts
================================================================================

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
import { ChildPart, noChange } from '../lit-html.js';
import { Directive, PartInfo } from '../directive.js';
export type KeyFn<T> = (item: T, index: number) => unknown;
export type ItemTemplate<T> = (item: T, index: number) => unknown;
declare class RepeatDirective extends Directive {
    private _itemKeys?;
    constructor(partInfo: PartInfo);
    private _getValuesAndKeys;
    render<T>(items: Iterable<T>, template: ItemTemplate<T>): Array<unknown>;
    render<T>(items: Iterable<T>, keyFn: KeyFn<T> | ItemTemplate<T>, template: ItemTemplate<T>): Array<unknown>;
    update<T>(containerPart: ChildPart, [items, keyFnOrTemplate, template]: [
        Iterable<T>,
        KeyFn<T> | ItemTemplate<T>,
        ItemTemplate<T>
    ]): unknown[] | typeof noChange;
}
export interface RepeatDirectiveFn {
    <T>(items: Iterable<T>, keyFnOrTemplate: KeyFn<T> | ItemTemplate<T>, template?: ItemTemplate<T>): unknown;
    <T>(items: Iterable<T>, template: ItemTemplate<T>): unknown;
    <T>(items: Iterable<T>, keyFn: KeyFn<T> | ItemTemplate<T>, template: ItemTemplate<T>): unknown;
}
/**
 * A directive that repeats a series of values (usually `TemplateResults`)
 * generated from an iterable, and updates those items efficiently when the
 * iterable changes based on user-provided `keys` associated with each item.
 *
 * Note that if a `keyFn` is provided, strict key-to-DOM mapping is maintained,
 * meaning previous DOM for a given key is moved into the new position if
 * needed, and DOM will never be reused with values for different keys (new DOM
 * will always be created for new keys). This is generally the most efficient
 * way to use `repeat` since it performs minimum unnecessary work for insertions
 * and removals.
 *
 * The `keyFn` takes two parameters, the item and its index, and returns a unique key value.
 *
 * ```js
 * html`
 *   <ol>
 *     ${repeat(this.items, (item) => item.id, (item, index) => {
 *       return html`<li>${index}: ${item.name}</li>`;
 *     })}
 *   </ol>
 * `
 * ```
 *
 * **Important**: If providing a `keyFn`, keys *must* be unique for all items in a
 * given call to `repeat`. The behavior when two or more items have the same key
 * is undefined.
 *
 * If no `keyFn` is provided, this directive will perform similar to mapping
 * items to values, and DOM will be reused against potentially different items.
 */
export declare const repeat: RepeatDirectiveFn;
/**
 * The type of the class that powers this directive. Necessary for naming the
 * directive's return type.
 */
export type { RepeatDirective };
//# sourceMappingURL=repeat.d.ts.map
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\repeat.d.ts.map
================================================================================

{"version":3,"file":"repeat.d.ts","sourceRoot":"","sources":["../../src/directives/repeat.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAEH,OAAO,EAAC,SAAS,EAAE,QAAQ,EAAC,MAAM,gBAAgB,CAAC;AACnD,OAAO,EAAY,SAAS,EAAE,QAAQ,EAAW,MAAM,iBAAiB,CAAC;AASzE,MAAM,MAAM,KAAK,CAAC,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC,EAAE,KAAK,EAAE,MAAM,KAAK,OAAO,CAAC;AAC3D,MAAM,MAAM,YAAY,CAAC,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC,EAAE,KAAK,EAAE,MAAM,KAAK,OAAO,CAAC;AAalE,cAAM,eAAgB,SAAQ,SAAS;IACrC,OAAO,CAAC,SAAS,CAAC,CAAY;gBAElB,QAAQ,EAAE,QAAQ;IAO9B,OAAO,CAAC,iBAAiB;IAyBzB,MAAM,CAAC,CAAC,EAAE,KAAK,EAAE,QAAQ,CAAC,CAAC,CAAC,EAAE,QAAQ,EAAE,YAAY,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC,OAAO,CAAC;IACxE,MAAM,CAAC,CAAC,EACN,KAAK,EAAE,QAAQ,CAAC,CAAC,CAAC,EAClB,KAAK,EAAE,KAAK,CAAC,CAAC,CAAC,GAAG,YAAY,CAAC,CAAC,CAAC,EACjC,QAAQ,EAAE,YAAY,CAAC,CAAC,CAAC,GACxB,KAAK,CAAC,OAAO,CAAC;IASR,MAAM,CAAC,CAAC,EACf,aAAa,EAAE,SAAS,EACxB,CAAC,KAAK,EAAE,eAAe,EAAE,QAAQ,CAAC,EAAE;QAClC,QAAQ,CAAC,CAAC,CAAC;QACX,KAAK,CAAC,CAAC,CAAC,GAAG,YAAY,CAAC,CAAC,CAAC;QAC1B,YAAY,CAAC,CAAC,CAAC;KAChB;CA4VJ;AAED,MAAM,WAAW,iBAAiB;IAChC,CAAC,CAAC,EACA,KAAK,EAAE,QAAQ,CAAC,CAAC,CAAC,EAClB,eAAe,EAAE,KAAK,CAAC,CAAC,CAAC,GAAG,YAAY,CAAC,CAAC,CAAC,EAC3C,QAAQ,CAAC,EAAE,YAAY,CAAC,CAAC,CAAC,GACzB,OAAO,CAAC;IACX,CAAC,CAAC,EAAE,KAAK,EAAE,QAAQ,CAAC,CAAC,CAAC,EAAE,QAAQ,EAAE,YAAY,CAAC,CAAC,CAAC,GAAG,OAAO,CAAC;IAC5D,CAAC,CAAC,EACA,KAAK,EAAE,QAAQ,CAAC,CAAC,CAAC,EAClB,KAAK,EAAE,KAAK,CAAC,CAAC,CAAC,GAAG,YAAY,CAAC,CAAC,CAAC,EACjC,QAAQ,EAAE,YAAY,CAAC,CAAC,CAAC,GACxB,OAAO,CAAC;CACZ;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA8BG;AACH,eAAO,MAAM,MAAM,EAAiC,iBAAiB,CAAC;AAEtE;;;GAGG;AACH,YAAY,EAAC,eAAe,EAAC,CAAC"}
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\repeat.js
================================================================================

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
import { noChange } from '../lit-html.js';
import { directive, Directive, PartType } from '../directive.js';
import { insertPart, getCommittedValue, removePart, setCommittedValue, setChildPartValue, } from '../directive-helpers.js';
// Helper for generating a map of array item to its index over a subset
// of an array (used to lazily generate `newKeyToIndexMap` and
// `oldKeyToIndexMap`)
const generateMap = (list, start, end) => {
    const map = new Map();
    for (let i = start; i <= end; i++) {
        map.set(list[i], i);
    }
    return map;
};
class RepeatDirective extends Directive {
    constructor(partInfo) {
        super(partInfo);
        if (partInfo.type !== PartType.CHILD) {
            throw new Error('repeat() can only be used in text expressions');
        }
    }
    _getValuesAndKeys(items, keyFnOrTemplate, template) {
        let keyFn;
        if (template === undefined) {
            template = keyFnOrTemplate;
        }
        else if (keyFnOrTemplate !== undefined) {
            keyFn = keyFnOrTemplate;
        }
        const keys = [];
        const values = [];
        let index = 0;
        for (const item of items) {
            keys[index] = keyFn ? keyFn(item, index) : index;
            values[index] = template(item, index);
            index++;
        }
        return {
            values,
            keys,
        };
    }
    render(items, keyFnOrTemplate, template) {
        return this._getValuesAndKeys(items, keyFnOrTemplate, template).values;
    }
    update(containerPart, [items, keyFnOrTemplate, template]) {
        // Old part & key lists are retrieved from the last update (which may
        // be primed by hydration)
        const oldParts = getCommittedValue(containerPart);
        const { values: newValues, keys: newKeys } = this._getValuesAndKeys(items, keyFnOrTemplate, template);
        // We check that oldParts, the committed value, is an Array as an
        // indicator that the previous value came from a repeat() call. If
        // oldParts is not an Array then this is the first render and we return
        // an array for lit-html's array handling to render, and remember the
        // keys.
        if (!Array.isArray(oldParts)) {
            this._itemKeys = newKeys;
            return newValues;
        }
        // In SSR hydration it's possible for oldParts to be an array but for us
        // to not have item keys because the update() hasn't run yet. We set the
        // keys to an empty array. This will cause all oldKey/newKey comparisons
        // to fail and execution to fall to the last nested brach below which
        // reuses the oldPart.
        const oldKeys = (this._itemKeys ??= []);
        // New part list will be built up as we go (either reused from
        // old parts or created for new keys in this update). This is
        // saved in the above cache at the end of the update.
        const newParts = [];
        // Maps from key to index for current and previous update; these
        // are generated lazily only when needed as a performance
        // optimization, since they are only required for multiple
        // non-contiguous changes in the list, which are less common.
        let newKeyToIndexMap;
        let oldKeyToIndexMap;
        // Head and tail pointers to old parts and new values
        let oldHead = 0;
        let oldTail = oldParts.length - 1;
        let newHead = 0;
        let newTail = newValues.length - 1;
        // Overview of O(n) reconciliation algorithm (general approach
        // based on ideas found in ivi, vue, snabbdom, etc.):
        //
        // * We start with the list of old parts and new values (and
        //   arrays of their respective keys), head/tail pointers into
        //   each, and we build up the new list of parts by updating
        //   (and when needed, moving) old parts or creating new ones.
        //   The initial scenario might look like this (for brevity of
        //   the diagrams, the numbers in the array reflect keys
        //   associated with the old parts or new values, although keys
        //   and parts/values are actually stored in parallel arrays
        //   indexed using the same head/tail pointers):
        //
        //      oldHead v                 v oldTail
        //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]
        //   newParts: [ ,  ,  ,  ,  ,  ,  ]
        //   newKeys:  [0, 2, 1, 4, 3, 7, 6] <- reflects the user's new
        //                                      item order
        //      newHead ^                 ^ newTail
        //
        // * Iterate old & new lists from both sides, updating,
        //   swapping, or removing parts at the head/tail locations
        //   until neither head nor tail can move.
        //
        // * Example below: keys at head pointers match, so update old
        //   part 0 in-place (no need to move it) and record part 0 in
        //   the `newParts` list. The last thing we do is advance the
        //   `oldHead` and `newHead` pointers (will be reflected in the
        //   next diagram).
        //
        //      oldHead v                 v oldTail
        //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]
        //   newParts: [0,  ,  ,  ,  ,  ,  ] <- heads matched: update 0
        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance both oldHead
        //                                      & newHead
        //      newHead ^                 ^ newTail
        //
        // * Example below: head pointers don't match, but tail
        //   pointers do, so update part 6 in place (no need to move
        //   it), and record part 6 in the `newParts` list. Last,
        //   advance the `oldTail` and `oldHead` pointers.
        //
        //         oldHead v              v oldTail
        //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]
        //   newParts: [0,  ,  ,  ,  ,  , 6] <- tails matched: update 6
        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance both oldTail
        //                                      & newTail
        //         newHead ^              ^ newTail
        //
        // * If neither head nor tail match; next check if one of the
        //   old head/tail items was removed. We first need to generate
        //   the reverse map of new keys to index (`newKeyToIndexMap`),
        //   which is done once lazily as a performance optimization,
        //   since we only hit this case if multiple non-contiguous
        //   changes were made. Note that for contiguous removal
        //   anywhere in the list, the head and tails would advance
        //   from either end and pass each other before we get to this
        //   case and removals would be handled in the final while loop
        //   without needing to generate the map.
        //
        // * Example below: The key at `oldTail` was removed (no longer
        //   in the `newKeyToIndexMap`), so remove that part from the
        //   DOM and advance just the `oldTail` pointer.
        //
        //         oldHead v           v oldTail
        //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]
        //   newParts: [0,  ,  ,  ,  ,  , 6] <- 5 not in new map: remove
        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    5 and advance oldTail
        //         newHead ^           ^ newTail
        //
        // * Once head and tail cannot move, any mismatches are due to
        //   either new or moved items; if a new key is in the previous
        //   "old key to old index" map, move the old part to the new
        //   location, otherwise create and insert a new part. Note
        //   that when moving an old part we null its position in the
        //   oldParts array if it lies between the head and tail so we
        //   know to skip it when the pointers get there.
        //
        // * Example below: neither head nor tail match, and neither
        //   were removed; so find the `newHead` key in the
        //   `oldKeyToIndexMap`, and move that old part's DOM into the
        //   next head position (before `oldParts[oldHead]`). Last,
        //   null the part in the `oldPart` array since it was
        //   somewhere in the remaining oldParts still to be scanned
        //   (between the head and tail pointers) so that we know to
        //   skip that old part on future iterations.
        //
        //         oldHead v        v oldTail
        //   oldKeys:  [0, 1, -, 3, 4, 5, 6]
        //   newParts: [0, 2,  ,  ,  ,  , 6] <- stuck: update & move 2
        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    into place and advance
        //                                      newHead
        //         newHead ^           ^ newTail
        //
        // * Note that for moves/insertions like the one above, a part
        //   inserted at the head pointer is inserted before the
        //   current `oldParts[oldHead]`, and a part inserted at the
        //   tail pointer is inserted before `newParts[newTail+1]`. The
        //   seeming asymmetry lies in the fact that new parts are
        //   moved into place outside in, so to the right of the head
        //   pointer are old parts, and to the right of the tail
        //   pointer are new parts.
        //
        // * We always restart back from the top of the algorithm,
        //   allowing matching and simple updates in place to
        //   continue...
        //
        // * Example below: the head pointers once again match, so
        //   simply update part 1 and record it in the `newParts`
        //   array.  Last, advance both head pointers.
        //
        //         oldHead v        v oldTail
        //   oldKeys:  [0, 1, -, 3, 4, 5, 6]
        //   newParts: [0, 2, 1,  ,  ,  , 6] <- heads matched: update 1
        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance both oldHead
        //                                      & newHead
        //            newHead ^        ^ newTail
        //
        // * As mentioned above, items that were moved as a result of
        //   being stuck (the final else clause in the code below) are
        //   marked with null, so we always advance old pointers over
        //   these so we're comparing the next actual old value on
        //   either end.
        //
        // * Example below: `oldHead` is null (already placed in
        //   newParts), so advance `oldHead`.
        //
        //            oldHead v     v oldTail
        //   oldKeys:  [0, 1, -, 3, 4, 5, 6] <- old head already used:
        //   newParts: [0, 2, 1,  ,  ,  , 6]    advance oldHead
        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]
        //               newHead ^     ^ newTail
        //
        // * Note it's not critical to mark old parts as null when they
        //   are moved from head to tail or tail to head, since they
        //   will be outside the pointer range and never visited again.
        //
        // * Example below: Here the old tail key matches the new head
        //   key, so the part at the `oldTail` position and move its
        //   DOM to the new head position (before `oldParts[oldHead]`).
        //   Last, advance `oldTail` and `newHead` pointers.
        //
        //               oldHead v  v oldTail
        //   oldKeys:  [0, 1, -, 3, 4, 5, 6]
        //   newParts: [0, 2, 1, 4,  ,  , 6] <- old tail matches new
        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]   head: update & move 4,
        //                                     advance oldTail & newHead
        //               newHead ^     ^ newTail
        //
        // * Example below: Old and new head keys match, so update the
        //   old head part in place, and advance the `oldHead` and
        //   `newHead` pointers.
        //
        //               oldHead v oldTail
        //   oldKeys:  [0, 1, -, 3, 4, 5, 6]
        //   newParts: [0, 2, 1, 4, 3,   ,6] <- heads match: update 3
        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance oldHead &
        //                                      newHead
        //                  newHead ^  ^ newTail
        //
        // * Once the new or old pointers move past each other then all
        //   we have left is additions (if old list exhausted) or
        //   removals (if new list exhausted). Those are handled in the
        //   final while loops at the end.
        //
        // * Example below: `oldHead` exceeded `oldTail`, so we're done
        //   with the main loop.  Create the remaining part and insert
        //   it at the new head position, and the update is complete.
        //
        //                   (oldHead > oldTail)
        //   oldKeys:  [0, 1, -, 3, 4, 5, 6]
        //   newParts: [0, 2, 1, 4, 3, 7 ,6] <- create and insert 7
        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]
        //                     newHead ^ newTail
        //
        // * Note that the order of the if/else clauses is not
        //   important to the algorithm, as long as the null checks
        //   come first (to ensure we're always working on valid old
        //   parts) and that the final else clause comes last (since
        //   that's where the expensive moves occur). The order of
        //   remaining clauses is just a simple guess at which cases
        //   will be most common.
        //
        // * Note, we could calculate the longest
        //   increasing subsequence (LIS) of old items in new position,
        //   and only move those not in the LIS set. However that costs
        //   O(nlogn) time and adds a bit more code, and only helps
        //   make rare types of mutations require fewer moves. The
        //   above handles removes, adds, reversal, swaps, and single
        //   moves of contiguous items in linear time, in the minimum
        //   number of moves. As the number of multiple moves where LIS
        //   might help approaches a random shuffle, the LIS
        //   optimization becomes less helpful, so it seems not worth
        //   the code at this point. Could reconsider if a compelling
        //   case arises.
        while (oldHead <= oldTail && newHead <= newTail) {
            if (oldParts[oldHead] === null) {
                // `null` means old part at head has already been used
                // below; skip
                oldHead++;
            }
            else if (oldParts[oldTail] === null) {
                // `null` means old part at tail has already been used
                // below; skip
                oldTail--;
            }
            else if (oldKeys[oldHead] === newKeys[newHead]) {
                // Old head matches new head; update in place
                newParts[newHead] = setChildPartValue(oldParts[oldHead], newValues[newHead]);
                oldHead++;
                newHead++;
            }
            else if (oldKeys[oldTail] === newKeys[newTail]) {
                // Old tail matches new tail; update in place
                newParts[newTail] = setChildPartValue(oldParts[oldTail], newValues[newTail]);
                oldTail--;
                newTail--;
            }
            else if (oldKeys[oldHead] === newKeys[newTail]) {
                // Old head matches new tail; update and move to new tail
                newParts[newTail] = setChildPartValue(oldParts[oldHead], newValues[newTail]);
                insertPart(containerPart, newParts[newTail + 1], oldParts[oldHead]);
                oldHead++;
                newTail--;
            }
            else if (oldKeys[oldTail] === newKeys[newHead]) {
                // Old tail matches new head; update and move to new head
                newParts[newHead] = setChildPartValue(oldParts[oldTail], newValues[newHead]);
                insertPart(containerPart, oldParts[oldHead], oldParts[oldTail]);
                oldTail--;
                newHead++;
            }
            else {
                if (newKeyToIndexMap === undefined) {
                    // Lazily generate key-to-index maps, used for removals &
                    // moves below
                    newKeyToIndexMap = generateMap(newKeys, newHead, newTail);
                    oldKeyToIndexMap = generateMap(oldKeys, oldHead, oldTail);
                }
                if (!newKeyToIndexMap.has(oldKeys[oldHead])) {
                    // Old head is no longer in new list; remove
                    removePart(oldParts[oldHead]);
                    oldHead++;
                }
                else if (!newKeyToIndexMap.has(oldKeys[oldTail])) {
                    // Old tail is no longer in new list; remove
                    removePart(oldParts[oldTail]);
                    oldTail--;
                }
                else {
                    // Any mismatches at this point are due to additions or
                    // moves; see if we have an old part we can reuse and move
                    // into place
                    const oldIndex = oldKeyToIndexMap.get(newKeys[newHead]);
                    const oldPart = oldIndex !== undefined ? oldParts[oldIndex] : null;
                    if (oldPart === null) {
                        // No old part for this value; create a new one and
                        // insert it
                        const newPart = insertPart(containerPart, oldParts[oldHead]);
                        setChildPartValue(newPart, newValues[newHead]);
                        newParts[newHead] = newPart;
                    }
                    else {
                        // Reuse old part
                        newParts[newHead] = setChildPartValue(oldPart, newValues[newHead]);
                        insertPart(containerPart, oldParts[oldHead], oldPart);
                        // This marks the old part as having been used, so that
                        // it will be skipped in the first two checks above
                        oldParts[oldIndex] = null;
                    }
                    newHead++;
                }
            }
        }
        // Add parts for any remaining new values
        while (newHead <= newTail) {
            // For all remaining additions, we insert before last new
            // tail, since old pointers are no longer valid
            const newPart = insertPart(containerPart, newParts[newTail + 1]);
            setChildPartValue(newPart, newValues[newHead]);
            newParts[newHead++] = newPart;
        }
        // Remove any remaining unused old parts
        while (oldHead <= oldTail) {
            const oldPart = oldParts[oldHead++];
            if (oldPart !== null) {
                removePart(oldPart);
            }
        }
        // Save order of new parts for next round
        this._itemKeys = newKeys;
        // Directly set part value, bypassing it's dirty-checking
        setCommittedValue(containerPart, newParts);
        return noChange;
    }
}
/**
 * A directive that repeats a series of values (usually `TemplateResults`)
 * generated from an iterable, and updates those items efficiently when the
 * iterable changes based on user-provided `keys` associated with each item.
 *
 * Note that if a `keyFn` is provided, strict key-to-DOM mapping is maintained,
 * meaning previous DOM for a given key is moved into the new position if
 * needed, and DOM will never be reused with values for different keys (new DOM
 * will always be created for new keys). This is generally the most efficient
 * way to use `repeat` since it performs minimum unnecessary work for insertions
 * and removals.
 *
 * The `keyFn` takes two parameters, the item and its index, and returns a unique key value.
 *
 * ```js
 * html`
 *   <ol>
 *     ${repeat(this.items, (item) => item.id, (item, index) => {
 *       return html`<li>${index}: ${item.name}</li>`;
 *     })}
 *   </ol>
 * `
 * ```
 *
 * **Important**: If providing a `keyFn`, keys *must* be unique for all items in a
 * given call to `repeat`. The behavior when two or more items have the same key
 * is undefined.
 *
 * If no `keyFn` is provided, this directive will perform similar to mapping
 * items to values, and DOM will be reused against potentially different items.
 */
export const repeat = directive(RepeatDirective);
//# sourceMappingURL=repeat.js.map
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\repeat.js.map
================================================================================

{"version":3,"file":"repeat.js","sourceRoot":"","sources":["../../src/directives/repeat.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {ChildPart, noChange} from '../lit-html.js';\nimport {directive, Directive, PartInfo, PartType} from '../directive.js';\nimport {\n  insertPart,\n  getCommittedValue,\n  removePart,\n  setCommittedValue,\n  setChildPartValue,\n} from '../directive-helpers.js';\n\nexport type KeyFn<T> = (item: T, index: number) => unknown;\nexport type ItemTemplate<T> = (item: T, index: number) => unknown;\n\n// Helper for generating a map of array item to its index over a subset\n// of an array (used to lazily generate `newKeyToIndexMap` and\n// `oldKeyToIndexMap`)\nconst generateMap = (list: unknown[], start: number, end: number) => {\n  const map = new Map<unknown, number>();\n  for (let i = start; i <= end; i++) {\n    map.set(list[i], i);\n  }\n  return map;\n};\n\nclass RepeatDirective extends Directive {\n  private _itemKeys?: unknown[];\n\n  constructor(partInfo: PartInfo) {\n    super(partInfo);\n    if (partInfo.type !== PartType.CHILD) {\n      throw new Error('repeat() can only be used in text expressions');\n    }\n  }\n\n  private _getValuesAndKeys<T>(\n    items: Iterable<T>,\n    keyFnOrTemplate: KeyFn<T> | ItemTemplate<T>,\n    template?: ItemTemplate<T>\n  ) {\n    let keyFn: KeyFn<T> | undefined;\n    if (template === undefined) {\n      template = keyFnOrTemplate;\n    } else if (keyFnOrTemplate !== undefined) {\n      keyFn = keyFnOrTemplate as KeyFn<T>;\n    }\n    const keys = [];\n    const values = [];\n    let index = 0;\n    for (const item of items) {\n      keys[index] = keyFn ? keyFn(item, index) : index;\n      values[index] = template!(item, index);\n      index++;\n    }\n    return {\n      values,\n      keys,\n    };\n  }\n\n  render<T>(items: Iterable<T>, template: ItemTemplate<T>): Array<unknown>;\n  render<T>(\n    items: Iterable<T>,\n    keyFn: KeyFn<T> | ItemTemplate<T>,\n    template: ItemTemplate<T>\n  ): Array<unknown>;\n  render<T>(\n    items: Iterable<T>,\n    keyFnOrTemplate: KeyFn<T> | ItemTemplate<T>,\n    template?: ItemTemplate<T>\n  ) {\n    return this._getValuesAndKeys(items, keyFnOrTemplate, template).values;\n  }\n\n  override update<T>(\n    containerPart: ChildPart,\n    [items, keyFnOrTemplate, template]: [\n      Iterable<T>,\n      KeyFn<T> | ItemTemplate<T>,\n      ItemTemplate<T>,\n    ]\n  ) {\n    // Old part & key lists are retrieved from the last update (which may\n    // be primed by hydration)\n    const oldParts = getCommittedValue(\n      containerPart\n    ) as Array<ChildPart | null>;\n    const {values: newValues, keys: newKeys} = this._getValuesAndKeys(\n      items,\n      keyFnOrTemplate,\n      template\n    );\n\n    // We check that oldParts, the committed value, is an Array as an\n    // indicator that the previous value came from a repeat() call. If\n    // oldParts is not an Array then this is the first render and we return\n    // an array for lit-html's array handling to render, and remember the\n    // keys.\n    if (!Array.isArray(oldParts)) {\n      this._itemKeys = newKeys;\n      return newValues;\n    }\n\n    // In SSR hydration it's possible for oldParts to be an array but for us\n    // to not have item keys because the update() hasn't run yet. We set the\n    // keys to an empty array. This will cause all oldKey/newKey comparisons\n    // to fail and execution to fall to the last nested brach below which\n    // reuses the oldPart.\n    const oldKeys = (this._itemKeys ??= []);\n\n    // New part list will be built up as we go (either reused from\n    // old parts or created for new keys in this update). This is\n    // saved in the above cache at the end of the update.\n    const newParts: ChildPart[] = [];\n\n    // Maps from key to index for current and previous update; these\n    // are generated lazily only when needed as a performance\n    // optimization, since they are only required for multiple\n    // non-contiguous changes in the list, which are less common.\n    let newKeyToIndexMap!: Map<unknown, number>;\n    let oldKeyToIndexMap!: Map<unknown, number>;\n\n    // Head and tail pointers to old parts and new values\n    let oldHead = 0;\n    let oldTail = oldParts.length - 1;\n    let newHead = 0;\n    let newTail = newValues.length - 1;\n\n    // Overview of O(n) reconciliation algorithm (general approach\n    // based on ideas found in ivi, vue, snabbdom, etc.):\n    //\n    // * We start with the list of old parts and new values (and\n    //   arrays of their respective keys), head/tail pointers into\n    //   each, and we build up the new list of parts by updating\n    //   (and when needed, moving) old parts or creating new ones.\n    //   The initial scenario might look like this (for brevity of\n    //   the diagrams, the numbers in the array reflect keys\n    //   associated with the old parts or new values, although keys\n    //   and parts/values are actually stored in parallel arrays\n    //   indexed using the same head/tail pointers):\n    //\n    //      oldHead v                 v oldTail\n    //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n    //   newParts: [ ,  ,  ,  ,  ,  ,  ]\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6] <- reflects the user's new\n    //                                      item order\n    //      newHead ^                 ^ newTail\n    //\n    // * Iterate old & new lists from both sides, updating,\n    //   swapping, or removing parts at the head/tail locations\n    //   until neither head nor tail can move.\n    //\n    // * Example below: keys at head pointers match, so update old\n    //   part 0 in-place (no need to move it) and record part 0 in\n    //   the `newParts` list. The last thing we do is advance the\n    //   `oldHead` and `newHead` pointers (will be reflected in the\n    //   next diagram).\n    //\n    //      oldHead v                 v oldTail\n    //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n    //   newParts: [0,  ,  ,  ,  ,  ,  ] <- heads matched: update 0\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance both oldHead\n    //                                      & newHead\n    //      newHead ^                 ^ newTail\n    //\n    // * Example below: head pointers don't match, but tail\n    //   pointers do, so update part 6 in place (no need to move\n    //   it), and record part 6 in the `newParts` list. Last,\n    //   advance the `oldTail` and `oldHead` pointers.\n    //\n    //         oldHead v              v oldTail\n    //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n    //   newParts: [0,  ,  ,  ,  ,  , 6] <- tails matched: update 6\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance both oldTail\n    //                                      & newTail\n    //         newHead ^              ^ newTail\n    //\n    // * If neither head nor tail match; next check if one of the\n    //   old head/tail items was removed. We first need to generate\n    //   the reverse map of new keys to index (`newKeyToIndexMap`),\n    //   which is done once lazily as a performance optimization,\n    //   since we only hit this case if multiple non-contiguous\n    //   changes were made. Note that for contiguous removal\n    //   anywhere in the list, the head and tails would advance\n    //   from either end and pass each other before we get to this\n    //   case and removals would be handled in the final while loop\n    //   without needing to generate the map.\n    //\n    // * Example below: The key at `oldTail` was removed (no longer\n    //   in the `newKeyToIndexMap`), so remove that part from the\n    //   DOM and advance just the `oldTail` pointer.\n    //\n    //         oldHead v           v oldTail\n    //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n    //   newParts: [0,  ,  ,  ,  ,  , 6] <- 5 not in new map: remove\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    5 and advance oldTail\n    //         newHead ^           ^ newTail\n    //\n    // * Once head and tail cannot move, any mismatches are due to\n    //   either new or moved items; if a new key is in the previous\n    //   \"old key to old index\" map, move the old part to the new\n    //   location, otherwise create and insert a new part. Note\n    //   that when moving an old part we null its position in the\n    //   oldParts array if it lies between the head and tail so we\n    //   know to skip it when the pointers get there.\n    //\n    // * Example below: neither head nor tail match, and neither\n    //   were removed; so find the `newHead` key in the\n    //   `oldKeyToIndexMap`, and move that old part's DOM into the\n    //   next head position (before `oldParts[oldHead]`). Last,\n    //   null the part in the `oldPart` array since it was\n    //   somewhere in the remaining oldParts still to be scanned\n    //   (between the head and tail pointers) so that we know to\n    //   skip that old part on future iterations.\n    //\n    //         oldHead v        v oldTail\n    //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n    //   newParts: [0, 2,  ,  ,  ,  , 6] <- stuck: update & move 2\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    into place and advance\n    //                                      newHead\n    //         newHead ^           ^ newTail\n    //\n    // * Note that for moves/insertions like the one above, a part\n    //   inserted at the head pointer is inserted before the\n    //   current `oldParts[oldHead]`, and a part inserted at the\n    //   tail pointer is inserted before `newParts[newTail+1]`. The\n    //   seeming asymmetry lies in the fact that new parts are\n    //   moved into place outside in, so to the right of the head\n    //   pointer are old parts, and to the right of the tail\n    //   pointer are new parts.\n    //\n    // * We always restart back from the top of the algorithm,\n    //   allowing matching and simple updates in place to\n    //   continue...\n    //\n    // * Example below: the head pointers once again match, so\n    //   simply update part 1 and record it in the `newParts`\n    //   array.  Last, advance both head pointers.\n    //\n    //         oldHead v        v oldTail\n    //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n    //   newParts: [0, 2, 1,  ,  ,  , 6] <- heads matched: update 1\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance both oldHead\n    //                                      & newHead\n    //            newHead ^        ^ newTail\n    //\n    // * As mentioned above, items that were moved as a result of\n    //   being stuck (the final else clause in the code below) are\n    //   marked with null, so we always advance old pointers over\n    //   these so we're comparing the next actual old value on\n    //   either end.\n    //\n    // * Example below: `oldHead` is null (already placed in\n    //   newParts), so advance `oldHead`.\n    //\n    //            oldHead v     v oldTail\n    //   oldKeys:  [0, 1, -, 3, 4, 5, 6] <- old head already used:\n    //   newParts: [0, 2, 1,  ,  ,  , 6]    advance oldHead\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]\n    //               newHead ^     ^ newTail\n    //\n    // * Note it's not critical to mark old parts as null when they\n    //   are moved from head to tail or tail to head, since they\n    //   will be outside the pointer range and never visited again.\n    //\n    // * Example below: Here the old tail key matches the new head\n    //   key, so the part at the `oldTail` position and move its\n    //   DOM to the new head position (before `oldParts[oldHead]`).\n    //   Last, advance `oldTail` and `newHead` pointers.\n    //\n    //               oldHead v  v oldTail\n    //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n    //   newParts: [0, 2, 1, 4,  ,  , 6] <- old tail matches new\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]   head: update & move 4,\n    //                                     advance oldTail & newHead\n    //               newHead ^     ^ newTail\n    //\n    // * Example below: Old and new head keys match, so update the\n    //   old head part in place, and advance the `oldHead` and\n    //   `newHead` pointers.\n    //\n    //               oldHead v oldTail\n    //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n    //   newParts: [0, 2, 1, 4, 3,   ,6] <- heads match: update 3\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance oldHead &\n    //                                      newHead\n    //                  newHead ^  ^ newTail\n    //\n    // * Once the new or old pointers move past each other then all\n    //   we have left is additions (if old list exhausted) or\n    //   removals (if new list exhausted). Those are handled in the\n    //   final while loops at the end.\n    //\n    // * Example below: `oldHead` exceeded `oldTail`, so we're done\n    //   with the main loop.  Create the remaining part and insert\n    //   it at the new head position, and the update is complete.\n    //\n    //                   (oldHead > oldTail)\n    //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n    //   newParts: [0, 2, 1, 4, 3, 7 ,6] <- create and insert 7\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]\n    //                     newHead ^ newTail\n    //\n    // * Note that the order of the if/else clauses is not\n    //   important to the algorithm, as long as the null checks\n    //   come first (to ensure we're always working on valid old\n    //   parts) and that the final else clause comes last (since\n    //   that's where the expensive moves occur). The order of\n    //   remaining clauses is just a simple guess at which cases\n    //   will be most common.\n    //\n    // * Note, we could calculate the longest\n    //   increasing subsequence (LIS) of old items in new position,\n    //   and only move those not in the LIS set. However that costs\n    //   O(nlogn) time and adds a bit more code, and only helps\n    //   make rare types of mutations require fewer moves. The\n    //   above handles removes, adds, reversal, swaps, and single\n    //   moves of contiguous items in linear time, in the minimum\n    //   number of moves. As the number of multiple moves where LIS\n    //   might help approaches a random shuffle, the LIS\n    //   optimization becomes less helpful, so it seems not worth\n    //   the code at this point. Could reconsider if a compelling\n    //   case arises.\n\n    while (oldHead <= oldTail && newHead <= newTail) {\n      if (oldParts[oldHead] === null) {\n        // `null` means old part at head has already been used\n        // below; skip\n        oldHead++;\n      } else if (oldParts[oldTail] === null) {\n        // `null` means old part at tail has already been used\n        // below; skip\n        oldTail--;\n      } else if (oldKeys[oldHead] === newKeys[newHead]) {\n        // Old head matches new head; update in place\n        newParts[newHead] = setChildPartValue(\n          oldParts[oldHead]!,\n          newValues[newHead]\n        );\n        oldHead++;\n        newHead++;\n      } else if (oldKeys[oldTail] === newKeys[newTail]) {\n        // Old tail matches new tail; update in place\n        newParts[newTail] = setChildPartValue(\n          oldParts[oldTail]!,\n          newValues[newTail]\n        );\n        oldTail--;\n        newTail--;\n      } else if (oldKeys[oldHead] === newKeys[newTail]) {\n        // Old head matches new tail; update and move to new tail\n        newParts[newTail] = setChildPartValue(\n          oldParts[oldHead]!,\n          newValues[newTail]\n        );\n        insertPart(containerPart, newParts[newTail + 1], oldParts[oldHead]!);\n        oldHead++;\n        newTail--;\n      } else if (oldKeys[oldTail] === newKeys[newHead]) {\n        // Old tail matches new head; update and move to new head\n        newParts[newHead] = setChildPartValue(\n          oldParts[oldTail]!,\n          newValues[newHead]\n        );\n        insertPart(containerPart, oldParts[oldHead]!, oldParts[oldTail]!);\n        oldTail--;\n        newHead++;\n      } else {\n        if (newKeyToIndexMap === undefined) {\n          // Lazily generate key-to-index maps, used for removals &\n          // moves below\n          newKeyToIndexMap = generateMap(newKeys, newHead, newTail);\n          oldKeyToIndexMap = generateMap(oldKeys, oldHead, oldTail);\n        }\n        if (!newKeyToIndexMap.has(oldKeys[oldHead])) {\n          // Old head is no longer in new list; remove\n          removePart(oldParts[oldHead]!);\n          oldHead++;\n        } else if (!newKeyToIndexMap.has(oldKeys[oldTail])) {\n          // Old tail is no longer in new list; remove\n          removePart(oldParts[oldTail]!);\n          oldTail--;\n        } else {\n          // Any mismatches at this point are due to additions or\n          // moves; see if we have an old part we can reuse and move\n          // into place\n          const oldIndex = oldKeyToIndexMap.get(newKeys[newHead]);\n          const oldPart = oldIndex !== undefined ? oldParts[oldIndex] : null;\n          if (oldPart === null) {\n            // No old part for this value; create a new one and\n            // insert it\n            const newPart = insertPart(containerPart, oldParts[oldHead]!);\n            setChildPartValue(newPart, newValues[newHead]);\n            newParts[newHead] = newPart;\n          } else {\n            // Reuse old part\n            newParts[newHead] = setChildPartValue(oldPart, newValues[newHead]);\n            insertPart(containerPart, oldParts[oldHead]!, oldPart);\n            // This marks the old part as having been used, so that\n            // it will be skipped in the first two checks above\n            oldParts[oldIndex as number] = null;\n          }\n          newHead++;\n        }\n      }\n    }\n    // Add parts for any remaining new values\n    while (newHead <= newTail) {\n      // For all remaining additions, we insert before last new\n      // tail, since old pointers are no longer valid\n      const newPart = insertPart(containerPart, newParts[newTail + 1]);\n      setChildPartValue(newPart, newValues[newHead]);\n      newParts[newHead++] = newPart;\n    }\n    // Remove any remaining unused old parts\n    while (oldHead <= oldTail) {\n      const oldPart = oldParts[oldHead++];\n      if (oldPart !== null) {\n        removePart(oldPart);\n      }\n    }\n\n    // Save order of new parts for next round\n    this._itemKeys = newKeys;\n    // Directly set part value, bypassing it's dirty-checking\n    setCommittedValue(containerPart, newParts);\n    return noChange;\n  }\n}\n\nexport interface RepeatDirectiveFn {\n  <T>(\n    items: Iterable<T>,\n    keyFnOrTemplate: KeyFn<T> | ItemTemplate<T>,\n    template?: ItemTemplate<T>\n  ): unknown;\n  <T>(items: Iterable<T>, template: ItemTemplate<T>): unknown;\n  <T>(\n    items: Iterable<T>,\n    keyFn: KeyFn<T> | ItemTemplate<T>,\n    template: ItemTemplate<T>\n  ): unknown;\n}\n\n/**\n * A directive that repeats a series of values (usually `TemplateResults`)\n * generated from an iterable, and updates those items efficiently when the\n * iterable changes based on user-provided `keys` associated with each item.\n *\n * Note that if a `keyFn` is provided, strict key-to-DOM mapping is maintained,\n * meaning previous DOM for a given key is moved into the new position if\n * needed, and DOM will never be reused with values for different keys (new DOM\n * will always be created for new keys). This is generally the most efficient\n * way to use `repeat` since it performs minimum unnecessary work for insertions\n * and removals.\n *\n * The `keyFn` takes two parameters, the item and its index, and returns a unique key value.\n *\n * ```js\n * html`\n *   <ol>\n *     ${repeat(this.items, (item) => item.id, (item, index) => {\n *       return html`<li>${index}: ${item.name}</li>`;\n *     })}\n *   </ol>\n * `\n * ```\n *\n * **Important**: If providing a `keyFn`, keys *must* be unique for all items in a\n * given call to `repeat`. The behavior when two or more items have the same key\n * is undefined.\n *\n * If no `keyFn` is provided, this directive will perform similar to mapping\n * items to values, and DOM will be reused against potentially different items.\n */\nexport const repeat = directive(RepeatDirective) as RepeatDirectiveFn;\n\n/**\n * The type of the class that powers this directive. Necessary for naming the\n * directive's return type.\n */\nexport type {RepeatDirective};\n"]}
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\style-map.d.ts
================================================================================

/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
import { AttributePart, noChange } from '../lit-html.js';
import { Directive, DirectiveParameters, PartInfo } from '../directive.js';
/**
 * A key-value set of CSS properties and values.
 *
 * The key should be either a valid CSS property name string, like
 * `'background-color'`, or a valid JavaScript camel case property name
 * for CSSStyleDeclaration like `backgroundColor`.
 */
export interface StyleInfo {
    [name: string]: string | number | undefined | null;
}
declare class StyleMapDirective extends Directive {
    private _previousStyleProperties?;
    constructor(partInfo: PartInfo);
    render(styleInfo: Readonly<StyleInfo>): string;
    update(part: AttributePart, [styleInfo]: DirectiveParameters<this>): string | typeof noChange;
}
/**
 * A directive that applies CSS properties to an element.
 *
 * `styleMap` can only be used in the `style` attribute and must be the only
 * expression in the attribute. It takes the property names in the
 * {@link StyleInfo styleInfo} object and adds the properties to the inline
 * style of the element.
 *
 * Property names with dashes (`-`) are assumed to be valid CSS
 * property names and set on the element's style object using `setProperty()`.
 * Names without dashes are assumed to be camelCased JavaScript property names
 * and set on the element's style object using property assignment, allowing the
 * style object to translate JavaScript-style names to CSS property names.
 *
 * For example `styleMap({backgroundColor: 'red', 'border-top': '5px', '--size':
 * '0'})` sets the `background-color`, `border-top` and `--size` properties.
 *
 * @param styleInfo
 * @see {@link https://lit.dev/docs/templates/directives/#stylemap styleMap code samples on Lit.dev}
 */
export declare const styleMap: (styleInfo: Readonly<StyleInfo>) => import("../directive.js").DirectiveResult<typeof StyleMapDirective>;
/**
 * The type of the class that powers this directive. Necessary for naming the
 * directive's return type.
 */
export type { StyleMapDirective };
//# sourceMappingURL=style-map.d.ts.map
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\style-map.d.ts.map
================================================================================

{"version":3,"file":"style-map.d.ts","sourceRoot":"","sources":["../../src/directives/style-map.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAEH,OAAO,EAAC,aAAa,EAAE,QAAQ,EAAC,MAAM,gBAAgB,CAAC;AACvD,OAAO,EAEL,SAAS,EACT,mBAAmB,EACnB,QAAQ,EAET,MAAM,iBAAiB,CAAC;AAEzB;;;;;;GAMG;AACH,MAAM,WAAW,SAAS;IACxB,CAAC,IAAI,EAAE,MAAM,GAAG,MAAM,GAAG,MAAM,GAAG,SAAS,GAAG,IAAI,CAAC;CACpD;AAQD,cAAM,iBAAkB,SAAQ,SAAS;IACvC,OAAO,CAAC,wBAAwB,CAAC,CAAc;gBAEnC,QAAQ,EAAE,QAAQ;IAc9B,MAAM,CAAC,SAAS,EAAE,QAAQ,CAAC,SAAS,CAAC;IAsB5B,MAAM,CAAC,IAAI,EAAE,aAAa,EAAE,CAAC,SAAS,CAAC,EAAE,mBAAmB,CAAC,IAAI,CAAC;CA6C5E;AAED;;;;;;;;;;;;;;;;;;;GAmBG;AACH,eAAO,MAAM,QAAQ,yGAA+B,CAAC;AAErD;;;GAGG;AACH,YAAY,EAAC,iBAAiB,EAAC,CAAC"}
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\style-map.js
================================================================================

/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
import { noChange } from '../lit-html.js';
import { directive, Directive, PartType, } from '../directive.js';
const important = 'important';
// The leading space is important
const importantFlag = ' !' + important;
// How many characters to remove from a value, as a negative number
const flagTrim = 0 - importantFlag.length;
class StyleMapDirective extends Directive {
    constructor(partInfo) {
        super(partInfo);
        if (partInfo.type !== PartType.ATTRIBUTE ||
            partInfo.name !== 'style' ||
            partInfo.strings?.length > 2) {
            throw new Error('The `styleMap` directive must be used in the `style` attribute ' +
                'and must be the only part in the attribute.');
        }
    }
    render(styleInfo) {
        return Object.keys(styleInfo).reduce((style, prop) => {
            const value = styleInfo[prop];
            if (value == null) {
                return style;
            }
            // Convert property names from camel-case to dash-case, i.e.:
            //  `backgroundColor` -> `background-color`
            // Vendor-prefixed names need an extra `-` appended to front:
            //  `webkitAppearance` -> `-webkit-appearance`
            // Exception is any property name containing a dash, including
            // custom properties; we assume these are already dash-cased i.e.:
            //  `--my-button-color` --> `--my-button-color`
            prop = prop.includes('-')
                ? prop
                : prop
                    .replace(/(?:^(webkit|moz|ms|o)|)(?=[A-Z])/g, '-$&')
                    .toLowerCase();
            return style + `${prop}:${value};`;
        }, '');
    }
    update(part, [styleInfo]) {
        const { style } = part.element;
        if (this._previousStyleProperties === undefined) {
            this._previousStyleProperties = new Set(Object.keys(styleInfo));
            return this.render(styleInfo);
        }
        // Remove old properties that no longer exist in styleInfo
        for (const name of this._previousStyleProperties) {
            // If the name isn't in styleInfo or it's null/undefined
            if (styleInfo[name] == null) {
                this._previousStyleProperties.delete(name);
                if (name.includes('-')) {
                    style.removeProperty(name);
                }
                else {
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    style[name] = null;
                }
            }
        }
        // Add or update properties
        for (const name in styleInfo) {
            const value = styleInfo[name];
            if (value != null) {
                this._previousStyleProperties.add(name);
                const isImportant = typeof value === 'string' && value.endsWith(importantFlag);
                if (name.includes('-') || isImportant) {
                    style.setProperty(name, isImportant
                        ? value.slice(0, flagTrim)
                        : value, isImportant ? important : '');
                }
                else {
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    style[name] = value;
                }
            }
        }
        return noChange;
    }
}
/**
 * A directive that applies CSS properties to an element.
 *
 * `styleMap` can only be used in the `style` attribute and must be the only
 * expression in the attribute. It takes the property names in the
 * {@link StyleInfo styleInfo} object and adds the properties to the inline
 * style of the element.
 *
 * Property names with dashes (`-`) are assumed to be valid CSS
 * property names and set on the element's style object using `setProperty()`.
 * Names without dashes are assumed to be camelCased JavaScript property names
 * and set on the element's style object using property assignment, allowing the
 * style object to translate JavaScript-style names to CSS property names.
 *
 * For example `styleMap({backgroundColor: 'red', 'border-top': '5px', '--size':
 * '0'})` sets the `background-color`, `border-top` and `--size` properties.
 *
 * @param styleInfo
 * @see {@link https://lit.dev/docs/templates/directives/#stylemap styleMap code samples on Lit.dev}
 */
export const styleMap = directive(StyleMapDirective);
//# sourceMappingURL=style-map.js.map
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\style-map.js.map
================================================================================

{"version":3,"file":"style-map.js","sourceRoot":"","sources":["../../src/directives/style-map.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {AttributePart, noChange} from '../lit-html.js';\nimport {\n  directive,\n  Directive,\n  DirectiveParameters,\n  PartInfo,\n  PartType,\n} from '../directive.js';\n\n/**\n * A key-value set of CSS properties and values.\n *\n * The key should be either a valid CSS property name string, like\n * `'background-color'`, or a valid JavaScript camel case property name\n * for CSSStyleDeclaration like `backgroundColor`.\n */\nexport interface StyleInfo {\n  [name: string]: string | number | undefined | null;\n}\n\nconst important = 'important';\n// The leading space is important\nconst importantFlag = ' !' + important;\n// How many characters to remove from a value, as a negative number\nconst flagTrim = 0 - importantFlag.length;\n\nclass StyleMapDirective extends Directive {\n  private _previousStyleProperties?: Set<string>;\n\n  constructor(partInfo: PartInfo) {\n    super(partInfo);\n    if (\n      partInfo.type !== PartType.ATTRIBUTE ||\n      partInfo.name !== 'style' ||\n      (partInfo.strings?.length as number) > 2\n    ) {\n      throw new Error(\n        'The `styleMap` directive must be used in the `style` attribute ' +\n          'and must be the only part in the attribute.'\n      );\n    }\n  }\n\n  render(styleInfo: Readonly<StyleInfo>) {\n    return Object.keys(styleInfo).reduce((style, prop) => {\n      const value = styleInfo[prop];\n      if (value == null) {\n        return style;\n      }\n      // Convert property names from camel-case to dash-case, i.e.:\n      //  `backgroundColor` -> `background-color`\n      // Vendor-prefixed names need an extra `-` appended to front:\n      //  `webkitAppearance` -> `-webkit-appearance`\n      // Exception is any property name containing a dash, including\n      // custom properties; we assume these are already dash-cased i.e.:\n      //  `--my-button-color` --> `--my-button-color`\n      prop = prop.includes('-')\n        ? prop\n        : prop\n            .replace(/(?:^(webkit|moz|ms|o)|)(?=[A-Z])/g, '-$&')\n            .toLowerCase();\n      return style + `${prop}:${value};`;\n    }, '');\n  }\n\n  override update(part: AttributePart, [styleInfo]: DirectiveParameters<this>) {\n    const {style} = part.element as HTMLElement;\n\n    if (this._previousStyleProperties === undefined) {\n      this._previousStyleProperties = new Set(Object.keys(styleInfo));\n      return this.render(styleInfo);\n    }\n\n    // Remove old properties that no longer exist in styleInfo\n    for (const name of this._previousStyleProperties) {\n      // If the name isn't in styleInfo or it's null/undefined\n      if (styleInfo[name] == null) {\n        this._previousStyleProperties!.delete(name);\n        if (name.includes('-')) {\n          style.removeProperty(name);\n        } else {\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          (style as any)[name] = null;\n        }\n      }\n    }\n\n    // Add or update properties\n    for (const name in styleInfo) {\n      const value = styleInfo[name];\n      if (value != null) {\n        this._previousStyleProperties.add(name);\n        const isImportant =\n          typeof value === 'string' && value.endsWith(importantFlag);\n        if (name.includes('-') || isImportant) {\n          style.setProperty(\n            name,\n            isImportant\n              ? (value as string).slice(0, flagTrim)\n              : (value as string),\n            isImportant ? important : ''\n          );\n        } else {\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          (style as any)[name] = value;\n        }\n      }\n    }\n    return noChange;\n  }\n}\n\n/**\n * A directive that applies CSS properties to an element.\n *\n * `styleMap` can only be used in the `style` attribute and must be the only\n * expression in the attribute. It takes the property names in the\n * {@link StyleInfo styleInfo} object and adds the properties to the inline\n * style of the element.\n *\n * Property names with dashes (`-`) are assumed to be valid CSS\n * property names and set on the element's style object using `setProperty()`.\n * Names without dashes are assumed to be camelCased JavaScript property names\n * and set on the element's style object using property assignment, allowing the\n * style object to translate JavaScript-style names to CSS property names.\n *\n * For example `styleMap({backgroundColor: 'red', 'border-top': '5px', '--size':\n * '0'})` sets the `background-color`, `border-top` and `--size` properties.\n *\n * @param styleInfo\n * @see {@link https://lit.dev/docs/templates/directives/#stylemap styleMap code samples on Lit.dev}\n */\nexport const styleMap = directive(StyleMapDirective);\n\n/**\n * The type of the class that powers this directive. Necessary for naming the\n * directive's return type.\n */\nexport type {StyleMapDirective};\n"]}
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\template-content.d.ts
================================================================================

/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
import { noChange } from '../lit-html.js';
import { Directive, PartInfo } from '../directive.js';
declare class TemplateContentDirective extends Directive {
    private _previousTemplate?;
    constructor(partInfo: PartInfo);
    render(template: HTMLTemplateElement): DocumentFragment | typeof noChange;
}
/**
 * Renders the content of a template element as HTML.
 *
 * Note, the template should be developer controlled and not user controlled.
 * Rendering a user-controlled template with this directive
 * could lead to cross-site-scripting vulnerabilities.
 */
export declare const templateContent: (template: HTMLTemplateElement) => import("../directive.js").DirectiveResult<typeof TemplateContentDirective>;
/**
 * The type of the class that powers this directive. Necessary for naming the
 * directive's return type.
 */
export type { TemplateContentDirective };
//# sourceMappingURL=template-content.d.ts.map
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\template-content.d.ts.map
================================================================================

{"version":3,"file":"template-content.d.ts","sourceRoot":"","sources":["../../src/directives/template-content.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAEH,OAAO,EAAC,QAAQ,EAAC,MAAM,gBAAgB,CAAC;AACxC,OAAO,EAAY,SAAS,EAAE,QAAQ,EAAW,MAAM,iBAAiB,CAAC;AAEzE,cAAM,wBAAyB,SAAQ,SAAS;IAC9C,OAAO,CAAC,iBAAiB,CAAC,CAAsB;gBAEpC,QAAQ,EAAE,QAAQ;IAO9B,MAAM,CAAC,QAAQ,EAAE,mBAAmB;CAOrC;AAED;;;;;;GAMG;AACH,eAAO,MAAM,eAAe,+GAAsC,CAAC;AAEnE;;;GAGG;AACH,YAAY,EAAC,wBAAwB,EAAC,CAAC"}
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\template-content.js
================================================================================

/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
import { noChange } from '../lit-html.js';
import { directive, Directive, PartType } from '../directive.js';
class TemplateContentDirective extends Directive {
    constructor(partInfo) {
        super(partInfo);
        if (partInfo.type !== PartType.CHILD) {
            throw new Error('templateContent can only be used in child bindings');
        }
    }
    render(template) {
        if (this._previousTemplate === template) {
            return noChange;
        }
        this._previousTemplate = template;
        return document.importNode(template.content, true);
    }
}
/**
 * Renders the content of a template element as HTML.
 *
 * Note, the template should be developer controlled and not user controlled.
 * Rendering a user-controlled template with this directive
 * could lead to cross-site-scripting vulnerabilities.
 */
export const templateContent = directive(TemplateContentDirective);
//# sourceMappingURL=template-content.js.map
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\template-content.js.map
================================================================================

{"version":3,"file":"template-content.js","sourceRoot":"","sources":["../../src/directives/template-content.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAEH,OAAO,EAAC,QAAQ,EAAC,MAAM,gBAAgB,CAAC;AACxC,OAAO,EAAC,SAAS,EAAE,SAAS,EAAY,QAAQ,EAAC,MAAM,iBAAiB,CAAC;AAEzE,MAAM,wBAAyB,SAAQ,SAAS;IAG9C,YAAY,QAAkB;QAC5B,KAAK,CAAC,QAAQ,CAAC,CAAC;QAChB,IAAI,QAAQ,CAAC,IAAI,KAAK,QAAQ,CAAC,KAAK,EAAE,CAAC;YACrC,MAAM,IAAI,KAAK,CAAC,oDAAoD,CAAC,CAAC;QACxE,CAAC;IACH,CAAC;IAED,MAAM,CAAC,QAA6B;QAClC,IAAI,IAAI,CAAC,iBAAiB,KAAK,QAAQ,EAAE,CAAC;YACxC,OAAO,QAAQ,CAAC;QAClB,CAAC;QACD,IAAI,CAAC,iBAAiB,GAAG,QAAQ,CAAC;QAClC,OAAO,QAAQ,CAAC,UAAU,CAAC,QAAQ,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;IACrD,CAAC;CACF;AAED;;;;;;GAMG;AACH,MAAM,CAAC,MAAM,eAAe,GAAG,SAAS,CAAC,wBAAwB,CAAC,CAAC","sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {noChange} from '../lit-html.js';\nimport {directive, Directive, PartInfo, PartType} from '../directive.js';\n\nclass TemplateContentDirective extends Directive {\n  private _previousTemplate?: HTMLTemplateElement;\n\n  constructor(partInfo: PartInfo) {\n    super(partInfo);\n    if (partInfo.type !== PartType.CHILD) {\n      throw new Error('templateContent can only be used in child bindings');\n    }\n  }\n\n  render(template: HTMLTemplateElement) {\n    if (this._previousTemplate === template) {\n      return noChange;\n    }\n    this._previousTemplate = template;\n    return document.importNode(template.content, true);\n  }\n}\n\n/**\n * Renders the content of a template element as HTML.\n *\n * Note, the template should be developer controlled and not user controlled.\n * Rendering a user-controlled template with this directive\n * could lead to cross-site-scripting vulnerabilities.\n */\nexport const templateContent = directive(TemplateContentDirective);\n\n/**\n * The type of the class that powers this directive. Necessary for naming the\n * directive's return type.\n */\nexport type {TemplateContentDirective};\n"]}
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\unsafe-html.d.ts
================================================================================

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
import { nothing, TemplateResult, noChange } from '../lit-html.js';
import { Directive, PartInfo } from '../directive.js';
export declare class UnsafeHTMLDirective extends Directive {
    static directiveName: string;
    static resultType: number;
    private _value;
    private _templateResult?;
    constructor(partInfo: PartInfo);
    render(value: string | typeof nothing | typeof noChange | undefined | null): typeof noChange | typeof nothing | TemplateResult | null | undefined;
}
/**
 * Renders the result as HTML, rather than text.
 *
 * The values `undefined`, `null`, and `nothing`, will all result in no content
 * (empty string) being rendered.
 *
 * Note, this is unsafe to use with any user-provided input that hasn't been
 * sanitized or escaped, as it may lead to cross-site-scripting
 * vulnerabilities.
 */
export declare const unsafeHTML: (value: string | typeof noChange | typeof nothing | null | undefined) => import("../directive.js").DirectiveResult<typeof UnsafeHTMLDirective>;
//# sourceMappingURL=unsafe-html.d.ts.map
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\unsafe-html.d.ts.map
================================================================================

{"version":3,"file":"unsafe-html.d.ts","sourceRoot":"","sources":["../../src/directives/unsafe-html.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAEH,OAAO,EAAC,OAAO,EAAE,cAAc,EAAE,QAAQ,EAAC,MAAM,gBAAgB,CAAC;AACjE,OAAO,EAAY,SAAS,EAAE,QAAQ,EAAW,MAAM,iBAAiB,CAAC;AAIzE,qBAAa,mBAAoB,SAAQ,SAAS;IAChD,MAAM,CAAC,aAAa,SAAgB;IACpC,MAAM,CAAC,UAAU,SAAe;IAEhC,OAAO,CAAC,MAAM,CAAoB;IAClC,OAAO,CAAC,eAAe,CAAC,CAAiB;gBAE7B,QAAQ,EAAE,QAAQ;IAW9B,MAAM,CAAC,KAAK,EAAE,MAAM,GAAG,OAAO,OAAO,GAAG,OAAO,QAAQ,GAAG,SAAS,GAAG,IAAI;CAkC3E;AAED;;;;;;;;;GASG;AACH,eAAO,MAAM,UAAU,gJAAiC,CAAC"}
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\unsafe-html.js
================================================================================

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
import { nothing, noChange } from '../lit-html.js';
import { directive, Directive, PartType } from '../directive.js';
const HTML_RESULT = 1;
export class UnsafeHTMLDirective extends Directive {
    constructor(partInfo) {
        super(partInfo);
        this._value = nothing;
        if (partInfo.type !== PartType.CHILD) {
            throw new Error(`${this.constructor.directiveName}() can only be used in child bindings`);
        }
    }
    render(value) {
        if (value === nothing || value == null) {
            this._templateResult = undefined;
            return (this._value = value);
        }
        if (value === noChange) {
            return value;
        }
        if (typeof value != 'string') {
            throw new Error(`${this.constructor.directiveName}() called with a non-string value`);
        }
        if (value === this._value) {
            return this._templateResult;
        }
        this._value = value;
        const strings = [value];
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        strings.raw = strings;
        // WARNING: impersonating a TemplateResult like this is extremely
        // dangerous. Third-party directives should not do this.
        return (this._templateResult = {
            // Cast to a known set of integers that satisfy ResultType so that we
            // don't have to export ResultType and possibly encourage this pattern.
            // This property needs to remain unminified.
            ['_$litType$']: this.constructor
                .resultType,
            strings,
            values: [],
        });
    }
}
UnsafeHTMLDirective.directiveName = 'unsafeHTML';
UnsafeHTMLDirective.resultType = HTML_RESULT;
/**
 * Renders the result as HTML, rather than text.
 *
 * The values `undefined`, `null`, and `nothing`, will all result in no content
 * (empty string) being rendered.
 *
 * Note, this is unsafe to use with any user-provided input that hasn't been
 * sanitized or escaped, as it may lead to cross-site-scripting
 * vulnerabilities.
 */
export const unsafeHTML = directive(UnsafeHTMLDirective);
//# sourceMappingURL=unsafe-html.js.map
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\unsafe-html.js.map
================================================================================

{"version":3,"file":"unsafe-html.js","sourceRoot":"","sources":["../../src/directives/unsafe-html.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAEH,OAAO,EAAC,OAAO,EAAkB,QAAQ,EAAC,MAAM,gBAAgB,CAAC;AACjE,OAAO,EAAC,SAAS,EAAE,SAAS,EAAY,QAAQ,EAAC,MAAM,iBAAiB,CAAC;AAEzE,MAAM,WAAW,GAAG,CAAC,CAAC;AAEtB,MAAM,OAAO,mBAAoB,SAAQ,SAAS;IAOhD,YAAY,QAAkB;QAC5B,KAAK,CAAC,QAAQ,CAAC,CAAC;QAJV,WAAM,GAAY,OAAO,CAAC;QAKhC,IAAI,QAAQ,CAAC,IAAI,KAAK,QAAQ,CAAC,KAAK,EAAE,CAAC;YACrC,MAAM,IAAI,KAAK,CACb,GACG,IAAI,CAAC,WAA0C,CAAC,aACnD,uCAAuC,CACxC,CAAC;QACJ,CAAC;IACH,CAAC;IAED,MAAM,CAAC,KAAmE;QACxE,IAAI,KAAK,KAAK,OAAO,IAAI,KAAK,IAAI,IAAI,EAAE,CAAC;YACvC,IAAI,CAAC,eAAe,GAAG,SAAS,CAAC;YACjC,OAAO,CAAC,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC,CAAC;QAC/B,CAAC;QACD,IAAI,KAAK,KAAK,QAAQ,EAAE,CAAC;YACvB,OAAO,KAAK,CAAC;QACf,CAAC;QACD,IAAI,OAAO,KAAK,IAAI,QAAQ,EAAE,CAAC;YAC7B,MAAM,IAAI,KAAK,CACb,GACG,IAAI,CAAC,WAA0C,CAAC,aACnD,mCAAmC,CACpC,CAAC;QACJ,CAAC;QACD,IAAI,KAAK,KAAK,IAAI,CAAC,MAAM,EAAE,CAAC;YAC1B,OAAO,IAAI,CAAC,eAAe,CAAC;QAC9B,CAAC;QACD,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;QACpB,MAAM,OAAO,GAAG,CAAC,KAAK,CAAoC,CAAC;QAC3D,8DAA8D;QAC7D,OAAe,CAAC,GAAG,GAAG,OAAO,CAAC;QAC/B,iEAAiE;QACjE,wDAAwD;QACxD,OAAO,CAAC,IAAI,CAAC,eAAe,GAAG;YAC7B,qEAAqE;YACrE,uEAAuE;YACvE,4CAA4C;YAC5C,CAAC,YAAY,CAAC,EAAG,IAAI,CAAC,WAA0C;iBAC7D,UAAmB;YACtB,OAAO;YACP,MAAM,EAAE,EAAE;SACX,CAAC,CAAC;IACL,CAAC;;AAlDM,iCAAa,GAAG,YAAY,AAAf,CAAgB;AAC7B,8BAAU,GAAG,WAAW,AAAd,CAAe;AAoDlC;;;;;;;;;GASG;AACH,MAAM,CAAC,MAAM,UAAU,GAAG,SAAS,CAAC,mBAAmB,CAAC,CAAC","sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {nothing, TemplateResult, noChange} from '../lit-html.js';\nimport {directive, Directive, PartInfo, PartType} from '../directive.js';\n\nconst HTML_RESULT = 1;\n\nexport class UnsafeHTMLDirective extends Directive {\n  static directiveName = 'unsafeHTML';\n  static resultType = HTML_RESULT;\n\n  private _value: unknown = nothing;\n  private _templateResult?: TemplateResult;\n\n  constructor(partInfo: PartInfo) {\n    super(partInfo);\n    if (partInfo.type !== PartType.CHILD) {\n      throw new Error(\n        `${\n          (this.constructor as typeof UnsafeHTMLDirective).directiveName\n        }() can only be used in child bindings`\n      );\n    }\n  }\n\n  render(value: string | typeof nothing | typeof noChange | undefined | null) {\n    if (value === nothing || value == null) {\n      this._templateResult = undefined;\n      return (this._value = value);\n    }\n    if (value === noChange) {\n      return value;\n    }\n    if (typeof value != 'string') {\n      throw new Error(\n        `${\n          (this.constructor as typeof UnsafeHTMLDirective).directiveName\n        }() called with a non-string value`\n      );\n    }\n    if (value === this._value) {\n      return this._templateResult;\n    }\n    this._value = value;\n    const strings = [value] as unknown as TemplateStringsArray;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (strings as any).raw = strings;\n    // WARNING: impersonating a TemplateResult like this is extremely\n    // dangerous. Third-party directives should not do this.\n    return (this._templateResult = {\n      // Cast to a known set of integers that satisfy ResultType so that we\n      // don't have to export ResultType and possibly encourage this pattern.\n      // This property needs to remain unminified.\n      ['_$litType$']: (this.constructor as typeof UnsafeHTMLDirective)\n        .resultType as 1 | 2,\n      strings,\n      values: [],\n    });\n  }\n}\n\n/**\n * Renders the result as HTML, rather than text.\n *\n * The values `undefined`, `null`, and `nothing`, will all result in no content\n * (empty string) being rendered.\n *\n * Note, this is unsafe to use with any user-provided input that hasn't been\n * sanitized or escaped, as it may lead to cross-site-scripting\n * vulnerabilities.\n */\nexport const unsafeHTML = directive(UnsafeHTMLDirective);\n"]}
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\unsafe-mathml.d.ts
================================================================================

/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
import { UnsafeHTMLDirective } from './unsafe-html.js';
declare class UnsafeMathMLDirective extends UnsafeHTMLDirective {
    static directiveName: string;
    static resultType: number;
}
/**
 * Renders the result as MathML, rather than text.
 *
 * The values `undefined`, `null`, and `nothing`, will all result in no content
 * (empty string) being rendered.
 *
 * Note, this is unsafe to use with any user-provided input that hasn't been
 * sanitized or escaped, as it may lead to cross-site-scripting
 * vulnerabilities.
 */
export declare const unsafeMathML: (value: string | typeof import("../lit-html.js").noChange | typeof import("../lit-html.js").nothing | null | undefined) => import("../directive.js").DirectiveResult<typeof UnsafeMathMLDirective>;
/**
 * The type of the class that powers this directive. Necessary for naming the
 * directive's return type.
 */
export type { UnsafeMathMLDirective as UnsafeMathDirective };
//# sourceMappingURL=unsafe-mathml.d.ts.map
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\unsafe-mathml.d.ts.map
================================================================================

{"version":3,"file":"unsafe-mathml.d.ts","sourceRoot":"","sources":["../../src/directives/unsafe-mathml.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAGH,OAAO,EAAC,mBAAmB,EAAC,MAAM,kBAAkB,CAAC;AAIrD,cAAM,qBAAsB,SAAQ,mBAAmB;IACrD,OAAgB,aAAa,SAAgB;IAC7C,OAAgB,UAAU,SAAiB;CAC5C;AAED;;;;;;;;;GASG;AACH,eAAO,MAAM,YAAY,oMAAmC,CAAC;AAE7D;;;GAGG;AACH,YAAY,EAAC,qBAAqB,IAAI,mBAAmB,EAAC,CAAC"}
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\unsafe-mathml.js
================================================================================

/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
import { directive } from '../directive.js';
import { UnsafeHTMLDirective } from './unsafe-html.js';
const MATHML_RESULT = 3;
class UnsafeMathMLDirective extends UnsafeHTMLDirective {
}
UnsafeMathMLDirective.directiveName = 'unsafeMath';
UnsafeMathMLDirective.resultType = MATHML_RESULT;
/**
 * Renders the result as MathML, rather than text.
 *
 * The values `undefined`, `null`, and `nothing`, will all result in no content
 * (empty string) being rendered.
 *
 * Note, this is unsafe to use with any user-provided input that hasn't been
 * sanitized or escaped, as it may lead to cross-site-scripting
 * vulnerabilities.
 */
export const unsafeMathML = directive(UnsafeMathMLDirective);
//# sourceMappingURL=unsafe-mathml.js.map
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\unsafe-mathml.js.map
================================================================================

{"version":3,"file":"unsafe-mathml.js","sourceRoot":"","sources":["../../src/directives/unsafe-mathml.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAEH,OAAO,EAAC,SAAS,EAAC,MAAM,iBAAiB,CAAC;AAC1C,OAAO,EAAC,mBAAmB,EAAC,MAAM,kBAAkB,CAAC;AAErD,MAAM,aAAa,GAAG,CAAC,CAAC;AAExB,MAAM,qBAAsB,SAAQ,mBAAmB;;AACrC,mCAAa,GAAG,YAAY,CAAC;AAC7B,gCAAU,GAAG,aAAa,CAAC;AAG7C;;;;;;;;;GASG;AACH,MAAM,CAAC,MAAM,YAAY,GAAG,SAAS,CAAC,qBAAqB,CAAC,CAAC","sourcesContent":["/**\n * @license\n * Copyright 2024 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {directive} from '../directive.js';\nimport {UnsafeHTMLDirective} from './unsafe-html.js';\n\nconst MATHML_RESULT = 3;\n\nclass UnsafeMathMLDirective extends UnsafeHTMLDirective {\n  static override directiveName = 'unsafeMath';\n  static override resultType = MATHML_RESULT;\n}\n\n/**\n * Renders the result as MathML, rather than text.\n *\n * The values `undefined`, `null`, and `nothing`, will all result in no content\n * (empty string) being rendered.\n *\n * Note, this is unsafe to use with any user-provided input that hasn't been\n * sanitized or escaped, as it may lead to cross-site-scripting\n * vulnerabilities.\n */\nexport const unsafeMathML = directive(UnsafeMathMLDirective);\n\n/**\n * The type of the class that powers this directive. Necessary for naming the\n * directive's return type.\n */\nexport type {UnsafeMathMLDirective as UnsafeMathDirective};\n"]}
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\unsafe-svg.d.ts
================================================================================

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
import { UnsafeHTMLDirective } from './unsafe-html.js';
declare class UnsafeSVGDirective extends UnsafeHTMLDirective {
    static directiveName: string;
    static resultType: number;
}
/**
 * Renders the result as SVG, rather than text.
 *
 * The values `undefined`, `null`, and `nothing`, will all result in no content
 * (empty string) being rendered.
 *
 * Note, this is unsafe to use with any user-provided input that hasn't been
 * sanitized or escaped, as it may lead to cross-site-scripting
 * vulnerabilities.
 */
export declare const unsafeSVG: (value: string | typeof import("../lit-html.js").noChange | typeof import("../lit-html.js").nothing | null | undefined) => import("../directive.js").DirectiveResult<typeof UnsafeSVGDirective>;
/**
 * The type of the class that powers this directive. Necessary for naming the
 * directive's return type.
 */
export type { UnsafeSVGDirective };
//# sourceMappingURL=unsafe-svg.d.ts.map
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\unsafe-svg.d.ts.map
================================================================================

{"version":3,"file":"unsafe-svg.d.ts","sourceRoot":"","sources":["../../src/directives/unsafe-svg.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAGH,OAAO,EAAC,mBAAmB,EAAC,MAAM,kBAAkB,CAAC;AAIrD,cAAM,kBAAmB,SAAQ,mBAAmB;IAClD,OAAgB,aAAa,SAAe;IAC5C,OAAgB,UAAU,SAAc;CACzC;AAED;;;;;;;;;GASG;AACH,eAAO,MAAM,SAAS,iMAAgC,CAAC;AAEvD;;;GAGG;AACH,YAAY,EAAC,kBAAkB,EAAC,CAAC"}
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\unsafe-svg.js
================================================================================

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
import { directive } from '../directive.js';
import { UnsafeHTMLDirective } from './unsafe-html.js';
const SVG_RESULT = 2;
class UnsafeSVGDirective extends UnsafeHTMLDirective {
}
UnsafeSVGDirective.directiveName = 'unsafeSVG';
UnsafeSVGDirective.resultType = SVG_RESULT;
/**
 * Renders the result as SVG, rather than text.
 *
 * The values `undefined`, `null`, and `nothing`, will all result in no content
 * (empty string) being rendered.
 *
 * Note, this is unsafe to use with any user-provided input that hasn't been
 * sanitized or escaped, as it may lead to cross-site-scripting
 * vulnerabilities.
 */
export const unsafeSVG = directive(UnsafeSVGDirective);
//# sourceMappingURL=unsafe-svg.js.map
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\unsafe-svg.js.map
================================================================================

{"version":3,"file":"unsafe-svg.js","sourceRoot":"","sources":["../../src/directives/unsafe-svg.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAEH,OAAO,EAAC,SAAS,EAAC,MAAM,iBAAiB,CAAC;AAC1C,OAAO,EAAC,mBAAmB,EAAC,MAAM,kBAAkB,CAAC;AAErD,MAAM,UAAU,GAAG,CAAC,CAAC;AAErB,MAAM,kBAAmB,SAAQ,mBAAmB;;AAClC,gCAAa,GAAG,WAAW,CAAC;AAC5B,6BAAU,GAAG,UAAU,CAAC;AAG1C;;;;;;;;;GASG;AACH,MAAM,CAAC,MAAM,SAAS,GAAG,SAAS,CAAC,kBAAkB,CAAC,CAAC","sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {directive} from '../directive.js';\nimport {UnsafeHTMLDirective} from './unsafe-html.js';\n\nconst SVG_RESULT = 2;\n\nclass UnsafeSVGDirective extends UnsafeHTMLDirective {\n  static override directiveName = 'unsafeSVG';\n  static override resultType = SVG_RESULT;\n}\n\n/**\n * Renders the result as SVG, rather than text.\n *\n * The values `undefined`, `null`, and `nothing`, will all result in no content\n * (empty string) being rendered.\n *\n * Note, this is unsafe to use with any user-provided input that hasn't been\n * sanitized or escaped, as it may lead to cross-site-scripting\n * vulnerabilities.\n */\nexport const unsafeSVG = directive(UnsafeSVGDirective);\n\n/**\n * The type of the class that powers this directive. Necessary for naming the\n * directive's return type.\n */\nexport type {UnsafeSVGDirective};\n"]}
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\until.d.ts
================================================================================

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
import { Part } from '../lit-html.js';
import { AsyncDirective } from '../async-directive.js';
export declare class UntilDirective extends AsyncDirective {
    private __lastRenderedIndex;
    private __values;
    private __weakThis;
    private __pauser;
    render(...args: Array<unknown>): unknown;
    update(_part: Part, args: Array<unknown>): unknown;
    disconnected(): void;
    reconnected(): void;
}
/**
 * Renders one of a series of values, including Promises, to a Part.
 *
 * Values are rendered in priority order, with the first argument having the
 * highest priority and the last argument having the lowest priority. If a
 * value is a Promise, low-priority values will be rendered until it resolves.
 *
 * The priority of values can be used to create placeholder content for async
 * data. For example, a Promise with pending content can be the first,
 * highest-priority, argument, and a non_promise loading indicator template can
 * be used as the second, lower-priority, argument. The loading indicator will
 * render immediately, and the primary content will render when the Promise
 * resolves.
 *
 * Example:
 *
 * ```js
 * const content = fetch('./content.txt').then(r => r.text());
 * html`${until(content, html`<span>Loading...</span>`)}`
 * ```
 */
export declare const until: (...values: unknown[]) => import("../directive.js").DirectiveResult<typeof UntilDirective>;
/**
 * The type of the class that powers this directive. Necessary for naming the
 * directive's return type.
 */
//# sourceMappingURL=until.d.ts.map
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\until.d.ts.map
================================================================================

{"version":3,"file":"until.d.ts","sourceRoot":"","sources":["../../src/directives/until.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAEH,OAAO,EAAC,IAAI,EAAW,MAAM,gBAAgB,CAAC;AAE9C,OAAO,EAAY,cAAc,EAAC,MAAM,uBAAuB,CAAC;AAShE,qBAAa,cAAe,SAAQ,cAAc;IAChD,OAAO,CAAC,mBAAmB,CAAqB;IAChD,OAAO,CAAC,QAAQ,CAAiB;IACjC,OAAO,CAAC,UAAU,CAA2B;IAC7C,OAAO,CAAC,QAAQ,CAAgB;IAEhC,MAAM,CAAC,GAAG,IAAI,EAAE,KAAK,CAAC,OAAO,CAAC,GAAG,OAAO;IAI/B,MAAM,CAAC,KAAK,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,CAAC,OAAO,CAAC;IAuExC,YAAY;IAKZ,WAAW;CAIrB;AAED;;;;;;;;;;;;;;;;;;;;GAoBG;AACH,eAAO,MAAM,KAAK,4FAA4B,CAAC;AAE/C;;;GAGG"}
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\until.js
================================================================================

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
import { noChange } from '../lit-html.js';
import { isPrimitive } from '../directive-helpers.js';
import { directive, AsyncDirective } from '../async-directive.js';
import { Pauser, PseudoWeakRef } from './private-async-helpers.js';
const isPromise = (x) => {
    return !isPrimitive(x) && typeof x.then === 'function';
};
// Effectively infinity, but a SMI.
const _infinity = 0x3fffffff;
export class UntilDirective extends AsyncDirective {
    constructor() {
        super(...arguments);
        this.__lastRenderedIndex = _infinity;
        this.__values = [];
        this.__weakThis = new PseudoWeakRef(this);
        this.__pauser = new Pauser();
    }
    render(...args) {
        return args.find((x) => !isPromise(x)) ?? noChange;
    }
    update(_part, args) {
        const previousValues = this.__values;
        let previousLength = previousValues.length;
        this.__values = args;
        const weakThis = this.__weakThis;
        const pauser = this.__pauser;
        // If our initial render occurs while disconnected, ensure that the pauser
        // and weakThis are in the disconnected state
        if (!this.isConnected) {
            this.disconnected();
        }
        for (let i = 0; i < args.length; i++) {
            // If we've rendered a higher-priority value already, stop.
            if (i > this.__lastRenderedIndex) {
                break;
            }
            const value = args[i];
            // Render non-Promise values immediately
            if (!isPromise(value)) {
                this.__lastRenderedIndex = i;
                // Since a lower-priority value will never overwrite a higher-priority
                // synchronous value, we can stop processing now.
                return value;
            }
            // If this is a Promise we've already handled, skip it.
            if (i < previousLength && value === previousValues[i]) {
                continue;
            }
            // We have a Promise that we haven't seen before, so priorities may have
            // changed. Forget what we rendered before.
            this.__lastRenderedIndex = _infinity;
            previousLength = 0;
            // Note, the callback avoids closing over `this` so that the directive
            // can be gc'ed before the promise resolves; instead `this` is retrieved
            // from `weakThis`, which can break the hard reference in the closure when
            // the directive disconnects
            Promise.resolve(value).then(async (result) => {
                // If we're disconnected, wait until we're (maybe) reconnected
                // The while loop here handles the case that the connection state
                // thrashes, causing the pauser to resume and then get re-paused
                while (pauser.get()) {
                    await pauser.get();
                }
                // If the callback gets here and there is no `this`, it means that the
                // directive has been disconnected and garbage collected and we don't
                // need to do anything else
                const _this = weakThis.deref();
                if (_this !== undefined) {
                    const index = _this.__values.indexOf(value);
                    // If state.values doesn't contain the value, we've re-rendered without
                    // the value, so don't render it. Then, only render if the value is
                    // higher-priority than what's already been rendered.
                    if (index > -1 && index < _this.__lastRenderedIndex) {
                        _this.__lastRenderedIndex = index;
                        _this.setValue(result);
                    }
                }
            });
        }
        return noChange;
    }
    disconnected() {
        this.__weakThis.disconnect();
        this.__pauser.pause();
    }
    reconnected() {
        this.__weakThis.reconnect(this);
        this.__pauser.resume();
    }
}
/**
 * Renders one of a series of values, including Promises, to a Part.
 *
 * Values are rendered in priority order, with the first argument having the
 * highest priority and the last argument having the lowest priority. If a
 * value is a Promise, low-priority values will be rendered until it resolves.
 *
 * The priority of values can be used to create placeholder content for async
 * data. For example, a Promise with pending content can be the first,
 * highest-priority, argument, and a non_promise loading indicator template can
 * be used as the second, lower-priority, argument. The loading indicator will
 * render immediately, and the primary content will render when the Promise
 * resolves.
 *
 * Example:
 *
 * ```js
 * const content = fetch('./content.txt').then(r => r.text());
 * html`${until(content, html`<span>Loading...</span>`)}`
 * ```
 */
export const until = directive(UntilDirective);
/**
 * The type of the class that powers this directive. Necessary for naming the
 * directive's return type.
 */
// export type {UntilDirective};
//# sourceMappingURL=until.js.map
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\until.js.map
================================================================================

{"version":3,"file":"until.js","sourceRoot":"","sources":["../../src/directives/until.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {Part, noChange} from '../lit-html.js';\nimport {isPrimitive} from '../directive-helpers.js';\nimport {directive, AsyncDirective} from '../async-directive.js';\nimport {Pauser, PseudoWeakRef} from './private-async-helpers.js';\n\nconst isPromise = (x: unknown) => {\n  return !isPrimitive(x) && typeof (x as {then?: unknown}).then === 'function';\n};\n// Effectively infinity, but a SMI.\nconst _infinity = 0x3fffffff;\n\nexport class UntilDirective extends AsyncDirective {\n  private __lastRenderedIndex: number = _infinity;\n  private __values: unknown[] = [];\n  private __weakThis = new PseudoWeakRef(this);\n  private __pauser = new Pauser();\n\n  render(...args: Array<unknown>): unknown {\n    return args.find((x) => !isPromise(x)) ?? noChange;\n  }\n\n  override update(_part: Part, args: Array<unknown>) {\n    const previousValues = this.__values;\n    let previousLength = previousValues.length;\n    this.__values = args;\n\n    const weakThis = this.__weakThis;\n    const pauser = this.__pauser;\n\n    // If our initial render occurs while disconnected, ensure that the pauser\n    // and weakThis are in the disconnected state\n    if (!this.isConnected) {\n      this.disconnected();\n    }\n\n    for (let i = 0; i < args.length; i++) {\n      // If we've rendered a higher-priority value already, stop.\n      if (i > this.__lastRenderedIndex) {\n        break;\n      }\n\n      const value = args[i];\n\n      // Render non-Promise values immediately\n      if (!isPromise(value)) {\n        this.__lastRenderedIndex = i;\n        // Since a lower-priority value will never overwrite a higher-priority\n        // synchronous value, we can stop processing now.\n        return value;\n      }\n\n      // If this is a Promise we've already handled, skip it.\n      if (i < previousLength && value === previousValues[i]) {\n        continue;\n      }\n\n      // We have a Promise that we haven't seen before, so priorities may have\n      // changed. Forget what we rendered before.\n      this.__lastRenderedIndex = _infinity;\n      previousLength = 0;\n\n      // Note, the callback avoids closing over `this` so that the directive\n      // can be gc'ed before the promise resolves; instead `this` is retrieved\n      // from `weakThis`, which can break the hard reference in the closure when\n      // the directive disconnects\n      Promise.resolve(value).then(async (result: unknown) => {\n        // If we're disconnected, wait until we're (maybe) reconnected\n        // The while loop here handles the case that the connection state\n        // thrashes, causing the pauser to resume and then get re-paused\n        while (pauser.get()) {\n          await pauser.get();\n        }\n        // If the callback gets here and there is no `this`, it means that the\n        // directive has been disconnected and garbage collected and we don't\n        // need to do anything else\n        const _this = weakThis.deref();\n        if (_this !== undefined) {\n          const index = _this.__values.indexOf(value);\n          // If state.values doesn't contain the value, we've re-rendered without\n          // the value, so don't render it. Then, only render if the value is\n          // higher-priority than what's already been rendered.\n          if (index > -1 && index < _this.__lastRenderedIndex) {\n            _this.__lastRenderedIndex = index;\n            _this.setValue(result);\n          }\n        }\n      });\n    }\n\n    return noChange;\n  }\n\n  override disconnected() {\n    this.__weakThis.disconnect();\n    this.__pauser.pause();\n  }\n\n  override reconnected() {\n    this.__weakThis.reconnect(this);\n    this.__pauser.resume();\n  }\n}\n\n/**\n * Renders one of a series of values, including Promises, to a Part.\n *\n * Values are rendered in priority order, with the first argument having the\n * highest priority and the last argument having the lowest priority. If a\n * value is a Promise, low-priority values will be rendered until it resolves.\n *\n * The priority of values can be used to create placeholder content for async\n * data. For example, a Promise with pending content can be the first,\n * highest-priority, argument, and a non_promise loading indicator template can\n * be used as the second, lower-priority, argument. The loading indicator will\n * render immediately, and the primary content will render when the Promise\n * resolves.\n *\n * Example:\n *\n * ```js\n * const content = fetch('./content.txt').then(r => r.text());\n * html`${until(content, html`<span>Loading...</span>`)}`\n * ```\n */\nexport const until = directive(UntilDirective);\n\n/**\n * The type of the class that powers this directive. Necessary for naming the\n * directive's return type.\n */\n// export type {UntilDirective};\n"]}
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\when.d.ts
================================================================================

/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
type Falsy = null | undefined | false | 0 | -0 | 0n | '';
/**
 * When `condition` is true, returns the result of calling `trueCase()`, else
 * returns the result of calling `falseCase()` if `falseCase` is defined.
 *
 * This is a convenience wrapper around a ternary expression that makes it a
 * little nicer to write an inline conditional without an else.
 *
 * @example
 *
 * ```ts
 * render() {
 *   return html`
 *     ${when(this.user, () => html`User: ${this.user.username}`, () => html`Sign In...`)}
 *   `;
 * }
 * ```
 */
export declare function when<C extends Falsy, T, F = undefined>(condition: C, trueCase: (c: C) => T, falseCase?: (c: C) => F): F;
export declare function when<C, T, F>(condition: C extends Falsy ? never : C, trueCase: (c: C) => T, falseCase?: (c: C) => F): T;
export declare function when<C, T, F = undefined>(condition: C, trueCase: (c: Exclude<C, Falsy>) => T, falseCase?: (c: Extract<C, Falsy>) => F): C extends Falsy ? F : T;
export {};
//# sourceMappingURL=when.d.ts.map
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\when.d.ts.map
================================================================================

{"version":3,"file":"when.d.ts","sourceRoot":"","sources":["../../src/directives/when.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAEH,KAAK,KAAK,GAAG,IAAI,GAAG,SAAS,GAAG,KAAK,GAAG,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,GAAG,EAAE,CAAC;AAEzD;;;;;;;;;;;;;;;;GAgBG;AACH,wBAAgB,IAAI,CAAC,CAAC,SAAS,KAAK,EAAE,CAAC,EAAE,CAAC,GAAG,SAAS,EACpD,SAAS,EAAE,CAAC,EACZ,QAAQ,EAAE,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,EACrB,SAAS,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,GACtB,CAAC,CAAC;AACL,wBAAgB,IAAI,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAC1B,SAAS,EAAE,CAAC,SAAS,KAAK,GAAG,KAAK,GAAG,CAAC,EACtC,QAAQ,EAAE,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,EACrB,SAAS,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,GACtB,CAAC,CAAC;AACL,wBAAgB,IAAI,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,GAAG,SAAS,EACtC,SAAS,EAAE,CAAC,EACZ,QAAQ,EAAE,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC,EAAE,KAAK,CAAC,KAAK,CAAC,EACrC,SAAS,CAAC,EAAE,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC,EAAE,KAAK,CAAC,KAAK,CAAC,GACtC,CAAC,SAAS,KAAK,GAAG,CAAC,GAAG,CAAC,CAAC"}
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\when.js
================================================================================

/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
export function when(condition, trueCase, falseCase) {
    return condition ? trueCase(condition) : falseCase?.(condition);
}
//# sourceMappingURL=when.js.map
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\lit-html\development\directives\when.js.map
================================================================================

{"version":3,"file":"when.js","sourceRoot":"","sources":["../../src/directives/when.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAoCH,MAAM,UAAU,IAAI,CAClB,SAAkB,EAClB,QAAiC,EACjC,SAAmC;IAEnC,OAAO,SAAS,CAAC,CAAC,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,SAAS,EAAE,CAAC,SAAS,CAAC,CAAC;AAClE,CAAC","sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\ntype Falsy = null | undefined | false | 0 | -0 | 0n | '';\n\n/**\n * When `condition` is true, returns the result of calling `trueCase()`, else\n * returns the result of calling `falseCase()` if `falseCase` is defined.\n *\n * This is a convenience wrapper around a ternary expression that makes it a\n * little nicer to write an inline conditional without an else.\n *\n * @example\n *\n * ```ts\n * render() {\n *   return html`\n *     ${when(this.user, () => html`User: ${this.user.username}`, () => html`Sign In...`)}\n *   `;\n * }\n * ```\n */\nexport function when<C extends Falsy, T, F = undefined>(\n  condition: C,\n  trueCase: (c: C) => T,\n  falseCase?: (c: C) => F\n): F;\nexport function when<C, T, F>(\n  condition: C extends Falsy ? never : C,\n  trueCase: (c: C) => T,\n  falseCase?: (c: C) => F\n): T;\nexport function when<C, T, F = undefined>(\n  condition: C,\n  trueCase: (c: Exclude<C, Falsy>) => T,\n  falseCase?: (c: Extract<C, Falsy>) => F\n): C extends Falsy ? F : T;\nexport function when(\n  condition: unknown,\n  trueCase: (c: unknown) => unknown,\n  falseCase?: (c: unknown) => unknown\n): unknown {\n  return condition ? trueCase(condition) : falseCase?.(condition);\n}\n"]}