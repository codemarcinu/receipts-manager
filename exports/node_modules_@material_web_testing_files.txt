=== Directory: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\@material\web\testing ===


================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\@material\web\testing\harness.d.ts
================================================================================

/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Retrieves the element type from a `Harness` type.
 *
 * @template H The harness type.
 */
export type HarnessElement<H extends Harness> = H extends Harness<infer E> ? ElementWithHarness<E, H> : never;
/**
 * Harnesses will attach themselves to their element for convenience.
 *
 * @template E The element type.
 * @template H The harness type.
 */
export type ElementWithHarness<E extends HTMLElement = HTMLElement, H extends Harness<E> = Harness<E>> = E & {
    /**
     * The harness for this element.
     */
    harness: H;
    /**
     * Associated form element.
     */
    form?: HTMLFormElement | null;
};
/**
 * Checks whether or not an element has a Harness attached to it on the
 * `element.harness` property.
 *
 * @param element The element to check.
 * @return True if the element has a harness property.
 */
export declare function isElementWithHarness(element: Element): element is ElementWithHarness;
/**
 * A test harness class that can be used to simulate interaction with an
 * element.
 *
 * @template E The harness's element type.
 */
export declare class Harness<E extends HTMLElement = HTMLElement> {
    /**
     * The pseudo classes that should be transformed for simulation. Component
     * subclasses may override this to add additional pseudo classes.
     */
    protected transformPseudoClasses: string[];
    /**
     * The element that this harness controls.
     */
    readonly element: E & ElementWithHarness<E, this>;
    /**
     * A set of elements that have already been patched to support transformed
     * pseudo classes.
     */
    private readonly patchedElements;
    /**
     * Creates a new harness for the given element.
     *
     * @param element The element that this harness controls.
     */
    constructor(element: E);
    /**
     * Resets the element's simulated classes to the default state.
     */
    reset(): Promise<void>;
    /**
     * Hovers and clicks on an element. This will generate a `click` event.
     *
     * @param init Additional event options.
     */
    clickWithMouse(init?: PointerEventInit): Promise<void>;
    /**
     * Begins a click with a mouse. Use this along with `endClickWithMouse()` to
     * customize the length of the click.
     *
     * @param init Additional event options.
     */
    startClickWithMouse(init?: PointerEventInit): Promise<void>;
    /**
     * Finishes a click with a mouse. Use this along with `startClickWithMouse()`
     * to customize the length of the click. This will generate a `click` event.
     *
     * @param init Additional event options.
     */
    endClickWithMouse(init?: PointerEventInit): Promise<void>;
    /**
     * Clicks an element with the keyboard (defaults to spacebar). This will
     * generate a `click` event.
     *
     * @param init Additional event options.
     */
    clickWithKeyboard(init?: KeyboardEventInit): Promise<void>;
    /**
     * Begins a click with the keyboard (defaults to spacebar). Use this along
     * with `endClickWithKeyboard()` to customize the length of the click.
     *
     * @param init Additional event options.
     */
    startClickWithKeyboard(init?: KeyboardEventInit): Promise<void>;
    /**
     * Finishes a click with the keyboard (defaults to spacebar). Use this along
     * with `startClickWithKeyboard()` to customize the length of the click.
     *
     * @param init Additional event options.
     */
    endClickWithKeyboard(init?: KeyboardEventInit): Promise<void>;
    /**
     * Right-clicks and opens a context menu. This will generate a `contextmenu`
     * event.
     */
    rightClickWithMouse(): Promise<void>;
    /**
     * Taps once on the element with a simulated touch. This will generate a
     * `click` event.
     *
     * @param init Additional event options.
     * @param touchInit Additional touch event options.
     */
    tap(init?: PointerEventInit, touchInit?: TouchEventInit): Promise<void>;
    /**
     * Begins a touch tap. Use this along with `endTap()` to customize the length
     * or number of taps.
     *
     * @param init Additional event options.
     * @param touchInit Additional touch event options.
     */
    startTap(init?: PointerEventInit, touchInit?: TouchEventInit): Promise<void>;
    /**
     * Simulates a `contextmenu` event for touch. Use this along with `startTap()`
     * to generate a tap-and-hold context menu interaction.
     *
     * @param init Additional event options.
     */
    startTapContextMenu(init?: MouseEventInit): Promise<void>;
    /**
     * Finished a touch tap. Use this along with `startTap()` to customize the
     * length or number of taps.
     *
     * This will NOT generate a `click` event.
     *
     * @param init Additional event options.
     * @param touchInit Additional touch event options.
     */
    endTap(init?: PointerEventInit, touchInit?: TouchEventInit): Promise<void>;
    /**
     * Simulates a `click` event for touch. Use this along with `endTap()` to
     * control the timing of tap and click events.
     *
     * @param init Additional event options.
     */
    endTapClick(init?: PointerEventInit): Promise<void>;
    /**
     * Cancels a touch tap.
     *
     * @param init Additional event options.
     * @param touchInit Additional touch event options.
     */
    cancelTap(init?: PointerEventInit, touchInit?: TouchEventInit): Promise<void>;
    /**
     * Hovers over the element with a simulated mouse.
     */
    startHover(): Promise<void>;
    /**
     * Moves the simulated mouse cursor off of the element.
     */
    endHover(): Promise<void>;
    /**
     * Simulates focusing an element with the keyboard.
     *
     * @param init Additional event options.
     */
    focusWithKeyboard(init?: KeyboardEventInit): Promise<void>;
    /**
     * Simulates focusing an element with a pointer.
     */
    focusWithPointer(): Promise<void>;
    /**
     * Simulates unfocusing an element.
     */
    blur(): Promise<void>;
    /**
     * Simulates a keypress on an element.
     *
     * @param key The key to press.
     * @param init Additional event options.
     */
    keypress(key: string, init?: KeyboardEventInit): Promise<void>;
    /**
     * Simulates submitting the element's associated form element.
     *
     * @param form (Optional) form to submit, defaults to the elemnt's form.
     * @return The submitted form data or null if the element has no associated
     * form.
     */
    submitForm(form?: HTMLFormElement): FormData | Promise<FormData>;
    /**
     * Returns the element that should be used for interaction simulation.
     * Defaults to the host element itself.
     *
     * Subclasses should override this if the interactive element is not the host.
     *
     * @return The element to use in simulation.
     */
    protected getInteractiveElement(): Promise<HTMLElement>;
    /**
     * Adds a pseudo class to an element. The element's shadow root styles (or
     * document if not in a shadow root) will be transformed to support
     * simulated pseudo classes.
     *
     * @param element The element to add a pseudo class to.
     * @param pseudoClass The pseudo class to add.
     */
    protected addPseudoClass(element: HTMLElement, pseudoClass: string): void;
    /**
     * Removes a pseudo class from an element.
     *
     * @param element The element to remove a pseudo class from.
     * @param pseudoClass The pseudo class to remove.
     */
    protected removePseudoClass(element: HTMLElement, pseudoClass: string): void;
    /**
     * Simulates a click event.
     *
     * @param element The element to click.
     * @param init Additional event options.
     */
    protected simulateClick(element: HTMLElement, init?: MouseEventInit): void;
    /**
     * Simulates a contextmenu event.
     *
     * @param element The element to generate an event for.
     * @param init Additional event options.
     */
    protected simulateContextmenu(element: HTMLElement, init?: MouseEventInit): void;
    /**
     * Simulates focusing with a keyboard. The difference between this and
     * `simulatePointerFocus` is that keyboard focus will include the
     * `:focus-visible` pseudo class.
     *
     * @param element The element to focus with a keyboard.
     */
    protected simulateKeyboardFocus(element: HTMLElement): void;
    /**
     * Simulates focusing with a pointer.
     *
     * @param element The element to focus with a pointer.
     */
    protected simulatePointerFocus(element: HTMLElement): void;
    /**
     * Simulates unfocusing an element.
     *
     * @param element The element to blur.
     */
    protected simulateBlur(element: HTMLElement): void;
    /**
     * Simulates a mouse pointer hovering over an element.
     *
     * @param element The element to hover over.
     * @param init Additional event options.
     */
    protected simulateStartHover(element: HTMLElement, init?: PointerEventInit): void;
    /**
     * Simulates a mouse pointer leaving the element.
     *
     * @param element The element to stop hovering over.
     * @param init Additional event options.
     */
    protected simulateEndHover(element: HTMLElement, init?: PointerEventInit): void;
    /**
     * Simulates a mouse press and hold on an element.
     *
     * @param element The element to press with a mouse.
     * @param init Additional event options.
     */
    protected simulateMousePress(element: HTMLElement, init?: PointerEventInit): void;
    /**
     * Simulates a mouse press release from an element.
     *
     * @param element The element to release pressing from.
     * @param init Additional event options.
     */
    protected simulateMouseRelease(element: HTMLElement, init?: PointerEventInit): void;
    /**
     * Simulates a touch press and hold on an element.
     *
     * @param element The element to press with a touch pointer.
     * @param init Additional event options.
     */
    protected simulateTouchPress(element: HTMLElement, init?: PointerEventInit, touchInit?: TouchEventInit): void;
    /**
     * Simulates a touch press release from an element.
     *
     * @param element The element to release pressing from.
     * @param init Additional event options.
     */
    protected simulateTouchRelease(element: HTMLElement, init?: PointerEventInit, touchInit?: TouchEventInit): void;
    /**
     * Simulates a touch cancel from an element.
     *
     * @param element The element to cancel a touch for.
     * @param init Additional event options.
     */
    protected simulateTouchCancel(element: HTMLElement, init?: PointerEventInit, touchInit?: TouchEventInit): void;
    /**
     * Simulates a keypress on an element.
     *
     * @param element The element to press a key on.
     * @param key The key to press.
     * @param init Additional event options.
     */
    protected simulateKeypress(element: EventTarget, key: string, init?: KeyboardEventInit): void;
    /**
     * Simulates a keydown press on an element.
     *
     * @param element The element to press a key on.
     * @param key The key to press.
     * @param init Additional event options.
     */
    protected simulateKeydown(element: EventTarget, key: string, init?: KeyboardEventInit): void;
    /**
     * Simulates a keyup release from an element.
     *
     * @param element The element to release a key from.
     * @param key The key to release.
     * @param init Additional keyboard options.
     */
    protected simulateKeyup(element: EventTarget, key: string, init?: KeyboardEventInit): void;
    /**
     * Creates a MouseEventInit for an element. The default x/y coordinates of the
     * event init will be in the center of the element.
     *
     * @param element The element to create a `MouseEventInit` for.
     * @return The init object for a `MouseEvent`.
     */
    protected createMouseEventInit(element: HTMLElement): MouseEventInit;
    /**
     * Creates a Touch instance for an element. The default x/y coordinates of the
     * touch will be in the center of the element. This can be used in the
     * `TouchEvent` constructor.
     *
     * @param element The element to create a touch for.
     * @param identifier Optional identifier for the touch. Defaults to 0 for
     *     every touch instance.
     * @return The `Touch` instance.
     */
    protected createTouch(element: HTMLElement, identifier?: number): Touch;
    /**
     * Visit each node up the parent tree from the given child until reaching the
     * given parent.
     *
     * This is used to perform logic such as adding/removing recursive pseudo
     * classes like `:hover`.
     *
     * @param child The first child element to start from.
     * @param callback A callback that is invoked with each `HTMLElement` node
     *     from the child to the parent.
     * @param parent The last parent element to visit.
     */
    protected forEachNodeFrom(child: HTMLElement, callback: (node: HTMLElement) => void, parent?: HTMLElement): void;
    /**
     * Patch an element's methods, such as `querySelector` and `matches` to
     * handle transformed pseudo classes.
     *
     * For example, `element.matches(':focus')` will return true when the
     * `._focus` class is applied.
     *
     * @param element The element to patch.
     */
    protected patchForTransformedPseudoClasses(element: HTMLElement): void;
}

================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\@material\web\testing\harness.js
================================================================================

/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
import { defaultTransformPseudoClasses, getTransformedPseudoClass, transformPseudoClasses, } from './transform-pseudo-classes.js';
/**
 * Checks whether or not an element has a Harness attached to it on the
 * `element.harness` property.
 *
 * @param element The element to check.
 * @return True if the element has a harness property.
 */
export function isElementWithHarness(element) {
    return element.harness instanceof Harness;
}
/**
 * A test harness class that can be used to simulate interaction with an
 * element.
 *
 * @template E The harness's element type.
 */
export class Harness {
    /**
     * Creates a new harness for the given element.
     *
     * @param element The element that this harness controls.
     */
    constructor(element) {
        /**
         * The pseudo classes that should be transformed for simulation. Component
         * subclasses may override this to add additional pseudo classes.
         */
        this.transformPseudoClasses = defaultTransformPseudoClasses;
        /**
         * A set of elements that have already been patched to support transformed
         * pseudo classes.
         */
        this.patchedElements = new WeakSet();
        this.element = element;
        this.element.harness = this;
    }
    /**
     * Resets the element's simulated classes to the default state.
     */
    async reset() {
        const element = await this.getInteractiveElement();
        for (const pseudoClass of this.transformPseudoClasses) {
            this.forEachNodeFrom(element, (el) => {
                this.removePseudoClass(el, pseudoClass);
            });
        }
    }
    /**
     * Hovers and clicks on an element. This will generate a `click` event.
     *
     * @param init Additional event options.
     */
    async clickWithMouse(init = {}) {
        await this.startClickWithMouse(init);
        await this.endClickWithMouse(init);
    }
    /**
     * Begins a click with a mouse. Use this along with `endClickWithMouse()` to
     * customize the length of the click.
     *
     * @param init Additional event options.
     */
    async startClickWithMouse(init = {}) {
        const element = await this.getInteractiveElement();
        await this.startHover();
        this.simulateMousePress(element, init);
    }
    /**
     * Finishes a click with a mouse. Use this along with `startClickWithMouse()`
     * to customize the length of the click. This will generate a `click` event.
     *
     * @param init Additional event options.
     */
    async endClickWithMouse(init = {}) {
        const element = await this.getInteractiveElement();
        this.simulateMouseRelease(element, init);
        if ((init?.button ?? 0) === 0) {
            // Dispatch a click for left-click only (default).
            this.simulateClick(element, init);
        }
    }
    /**
     * Clicks an element with the keyboard (defaults to spacebar). This will
     * generate a `click` event.
     *
     * @param init Additional event options.
     */
    async clickWithKeyboard(init = {}) {
        const element = await this.getInteractiveElement();
        await this.startClickWithKeyboard(init);
        await this.endClickWithKeyboard(init);
        this.simulateClick(element, init);
    }
    /**
     * Begins a click with the keyboard (defaults to spacebar). Use this along
     * with `endClickWithKeyboard()` to customize the length of the click.
     *
     * @param init Additional event options.
     */
    async startClickWithKeyboard(init = {}) {
        const element = await this.getInteractiveElement();
        await this.focusWithKeyboard(init);
        this.simulateKeydown(element, init.key ?? ' ', init);
        this.simulateClick(element, init);
    }
    /**
     * Finishes a click with the keyboard (defaults to spacebar). Use this along
     * with `startClickWithKeyboard()` to customize the length of the click.
     *
     * @param init Additional event options.
     */
    async endClickWithKeyboard(init = {}) {
        const element = await this.getInteractiveElement();
        this.simulateKeyup(element, init.key ?? ' ', init);
        this.simulateClick(element, init);
    }
    /**
     * Right-clicks and opens a context menu. This will generate a `contextmenu`
     * event.
     */
    async rightClickWithMouse() {
        const element = await this.getInteractiveElement();
        const rightMouseButton = { button: 2, buttons: 2 };
        await this.startClickWithMouse(rightMouseButton);
        // Note: contextmenu right clicks do not generate the up events
        this.simulateContextmenu(element, rightMouseButton);
    }
    /**
     * Taps once on the element with a simulated touch. This will generate a
     * `click` event.
     *
     * @param init Additional event options.
     * @param touchInit Additional touch event options.
     */
    async tap(init = {}, touchInit = {}) {
        const element = await this.getInteractiveElement();
        this.simulateTouchPress(element, init, touchInit);
        this.simulateTouchRelease(element, init, touchInit);
        if ((init?.isPrimary ?? true) === true) {
            // Dispatch a click for primary touches only (default).
            await this.endTapClick(init);
        }
    }
    /**
     * Begins a touch tap. Use this along with `endTap()` to customize the length
     * or number of taps.
     *
     * @param init Additional event options.
     * @param touchInit Additional touch event options.
     */
    async startTap(init = {}, touchInit = {}) {
        const element = await this.getInteractiveElement();
        this.simulateTouchPress(element, init, touchInit);
    }
    /**
     * Simulates a `contextmenu` event for touch. Use this along with `startTap()`
     * to generate a tap-and-hold context menu interaction.
     *
     * @param init Additional event options.
     */
    async startTapContextMenu(init = {}) {
        const element = await this.getInteractiveElement();
        this.simulateContextmenu(element, init);
    }
    /**
     * Finished a touch tap. Use this along with `startTap()` to customize the
     * length or number of taps.
     *
     * This will NOT generate a `click` event.
     *
     * @param init Additional event options.
     * @param touchInit Additional touch event options.
     */
    async endTap(init = {}, touchInit = {}) {
        const element = await this.getInteractiveElement();
        this.simulateTouchRelease(element, init, touchInit);
    }
    /**
     * Simulates a `click` event for touch. Use this along with `endTap()` to
     * control the timing of tap and click events.
     *
     * @param init Additional event options.
     */
    async endTapClick(init = {}) {
        const element = await this.getInteractiveElement();
        this.simulateClick(element, {
            pointerType: 'touch',
            ...init,
        });
    }
    /**
     * Cancels a touch tap.
     *
     * @param init Additional event options.
     * @param touchInit Additional touch event options.
     */
    async cancelTap(init = {}, touchInit = {}) {
        const element = await this.getInteractiveElement();
        this.simulateTouchCancel(element, init, touchInit);
    }
    /**
     * Hovers over the element with a simulated mouse.
     */
    async startHover() {
        const element = await this.getInteractiveElement();
        this.simulateStartHover(element);
    }
    /**
     * Moves the simulated mouse cursor off of the element.
     */
    async endHover() {
        const element = await this.getInteractiveElement();
        this.simulateEndHover(element);
    }
    /**
     * Simulates focusing an element with the keyboard.
     *
     * @param init Additional event options.
     */
    async focusWithKeyboard(init = {}) {
        const element = await this.getInteractiveElement();
        this.simulateKeyboardFocus(element);
    }
    /**
     * Simulates focusing an element with a pointer.
     */
    async focusWithPointer() {
        const element = await this.getInteractiveElement();
        await this.startHover();
        this.simulatePointerFocus(element);
    }
    /**
     * Simulates unfocusing an element.
     */
    async blur() {
        const element = await this.getInteractiveElement();
        await this.endHover();
        this.simulateBlur(element);
    }
    /**
     * Simulates a keypress on an element.
     *
     * @param key The key to press.
     * @param init Additional event options.
     */
    async keypress(key, init = {}) {
        const element = await this.getInteractiveElement();
        this.simulateKeypress(element, key, init);
    }
    /**
     * Simulates submitting the element's associated form element.
     *
     * @param form (Optional) form to submit, defaults to the elemnt's form.
     * @return The submitted form data or null if the element has no associated
     * form.
     */
    submitForm(form = this.element.form) {
        if (!form) {
            return new FormData();
        }
        return new Promise((resolve) => {
            const submitListener = (event) => {
                event.preventDefault();
                const data = new FormData(form);
                resolve(data);
                return false;
            };
            form.addEventListener('submit', submitListener, { once: true });
            form.requestSubmit();
        });
    }
    /**
     * Returns the element that should be used for interaction simulation.
     * Defaults to the host element itself.
     *
     * Subclasses should override this if the interactive element is not the host.
     *
     * @return The element to use in simulation.
     */
    async getInteractiveElement() {
        return this.element;
    }
    /**
     * Adds a pseudo class to an element. The element's shadow root styles (or
     * document if not in a shadow root) will be transformed to support
     * simulated pseudo classes.
     *
     * @param element The element to add a pseudo class to.
     * @param pseudoClass The pseudo class to add.
     */
    addPseudoClass(element, pseudoClass) {
        if (!this.transformPseudoClasses.includes(pseudoClass)) {
            return;
        }
        const root = element.getRootNode();
        if (element.shadowRoot) {
            transformPseudoClasses(element.shadowRoot.adoptedStyleSheets || [], this.transformPseudoClasses);
        }
        transformPseudoClasses(root.styleSheets, this.transformPseudoClasses);
        transformPseudoClasses(root.adoptedStyleSheets || [], this.transformPseudoClasses);
        element.classList.add(getTransformedPseudoClass(pseudoClass));
        this.patchForTransformedPseudoClasses(element);
    }
    /**
     * Removes a pseudo class from an element.
     *
     * @param element The element to remove a pseudo class from.
     * @param pseudoClass The pseudo class to remove.
     */
    removePseudoClass(element, pseudoClass) {
        element.classList.remove(getTransformedPseudoClass(pseudoClass));
    }
    /**
     * Simulates a click event.
     *
     * @param element The element to click.
     * @param init Additional event options.
     */
    simulateClick(element, init = {}) {
        // Firefox does not support some simulations with PointerEvents, such as
        // selecting an <input type="checkbox">. Use MouseEvent for browser support.
        element.dispatchEvent(new MouseEvent('click', {
            ...this.createMouseEventInit(element),
            ...init,
        }));
    }
    /**
     * Simulates a contextmenu event.
     *
     * @param element The element to generate an event for.
     * @param init Additional event options.
     */
    simulateContextmenu(element, init = {}) {
        element.dispatchEvent(new MouseEvent('contextmenu', {
            ...this.createMouseEventInit(element),
            button: 2,
            buttons: 2,
            ...init,
        }));
    }
    /**
     * Simulates focusing with a keyboard. The difference between this and
     * `simulatePointerFocus` is that keyboard focus will include the
     * `:focus-visible` pseudo class.
     *
     * @param element The element to focus with a keyboard.
     */
    simulateKeyboardFocus(element) {
        this.simulateKeydown(element.ownerDocument, 'Tab');
        this.addPseudoClass(element, ':focus-visible');
        this.simulatePointerFocus(element);
        this.simulateKeyup(element, 'Tab');
    }
    /**
     * Simulates focusing with a pointer.
     *
     * @param element The element to focus with a pointer.
     */
    simulatePointerFocus(element) {
        this.addPseudoClass(element, ':focus');
        this.forEachNodeFrom(element, (el) => {
            this.addPseudoClass(el, ':focus-within');
        });
        element.dispatchEvent(new FocusEvent('focus', { composed: true }));
        element.dispatchEvent(new FocusEvent('focusin', { bubbles: true, composed: true }));
    }
    /**
     * Simulates unfocusing an element.
     *
     * @param element The element to blur.
     */
    simulateBlur(element) {
        this.removePseudoClass(element, ':focus');
        this.removePseudoClass(element, ':focus-visible');
        this.forEachNodeFrom(element, (el) => {
            this.removePseudoClass(el, ':focus-within');
        });
        element.dispatchEvent(new FocusEvent('blur', { composed: true }));
        element.dispatchEvent(new FocusEvent('focusout', { bubbles: true, composed: true }));
    }
    /**
     * Simulates a mouse pointer hovering over an element.
     *
     * @param element The element to hover over.
     * @param init Additional event options.
     */
    simulateStartHover(element, init = {}) {
        this.forEachNodeFrom(element, (el) => {
            this.addPseudoClass(el, ':hover');
        });
        const rect = element.getBoundingClientRect();
        const mouseInit = this.createMouseEventInit(element);
        const mouseEnterInit = {
            ...mouseInit,
            bubbles: false,
            clientX: rect.left,
            clientY: rect.top,
            screenX: rect.left,
            screenY: rect.top,
        };
        const pointerInit = {
            ...mouseInit,
            isPrimary: true,
            pointerType: 'mouse',
        };
        const pointerEnterInit = {
            ...pointerInit,
            ...mouseEnterInit,
            ...init,
        };
        element.dispatchEvent(new PointerEvent('pointerover', pointerInit));
        element.dispatchEvent(new PointerEvent('pointerenter', pointerEnterInit));
        element.dispatchEvent(new MouseEvent('mouseover', mouseInit));
        element.dispatchEvent(new MouseEvent('mouseenter', mouseEnterInit));
    }
    /**
     * Simulates a mouse pointer leaving the element.
     *
     * @param element The element to stop hovering over.
     * @param init Additional event options.
     */
    simulateEndHover(element, init = {}) {
        this.forEachNodeFrom(element, (el) => {
            this.removePseudoClass(el, ':hover');
        });
        const rect = element.getBoundingClientRect();
        const mouseInit = this.createMouseEventInit(element);
        const mouseLeaveInit = {
            ...mouseInit,
            bubbles: false,
            clientX: rect.left - 1,
            clientY: rect.top - 1,
            screenX: rect.left - 1,
            screenY: rect.top - 1,
        };
        const pointerInit = {
            ...mouseInit,
            isPrimary: true,
            pointerType: 'mouse',
            ...init,
        };
        const pointerLeaveInit = {
            ...pointerInit,
            ...mouseLeaveInit,
        };
        element.dispatchEvent(new PointerEvent('pointerout', pointerInit));
        element.dispatchEvent(new PointerEvent('pointerleave', pointerLeaveInit));
        element.dispatchEvent(new MouseEvent('pointerout', mouseInit));
        element.dispatchEvent(new MouseEvent('mouseleave', mouseLeaveInit));
    }
    /**
     * Simulates a mouse press and hold on an element.
     *
     * @param element The element to press with a mouse.
     * @param init Additional event options.
     */
    simulateMousePress(element, init = {}) {
        this.addPseudoClass(element, ':active');
        this.forEachNodeFrom(element, (el) => {
            this.addPseudoClass(el, ':active');
        });
        const mouseInit = this.createMouseEventInit(element);
        const pointerInit = {
            ...mouseInit,
            isPrimary: true,
            pointerType: 'mouse',
            ...init,
        };
        element.dispatchEvent(new PointerEvent('pointerdown', pointerInit));
        element.dispatchEvent(new MouseEvent('mousedown', mouseInit));
        this.simulatePointerFocus(element);
    }
    /**
     * Simulates a mouse press release from an element.
     *
     * @param element The element to release pressing from.
     * @param init Additional event options.
     */
    simulateMouseRelease(element, init = {}) {
        this.removePseudoClass(element, ':active');
        this.forEachNodeFrom(element, (el) => {
            this.removePseudoClass(el, ':active');
        });
        const mouseInit = this.createMouseEventInit(element);
        const pointerInit = {
            ...mouseInit,
            isPrimary: true,
            pointerType: 'mouse',
            ...init,
        };
        element.dispatchEvent(new PointerEvent('pointerup', pointerInit));
        element.dispatchEvent(new MouseEvent('mouseup', mouseInit));
    }
    /**
     * Simulates a touch press and hold on an element.
     *
     * @param element The element to press with a touch pointer.
     * @param init Additional event options.
     */
    simulateTouchPress(element, init = {}, touchInit = {}) {
        this.addPseudoClass(element, ':active');
        this.forEachNodeFrom(element, (el) => {
            this.addPseudoClass(el, ':active');
        });
        const mouseInit = this.createMouseEventInit(element);
        const pointerInit = {
            ...mouseInit,
            isPrimary: true,
            pointerType: 'touch',
            ...init,
        };
        element.dispatchEvent(new PointerEvent('pointerdown', pointerInit));
        // Firefox does not support TouchEvent constructor
        if (window.TouchEvent) {
            const touch = this.createTouch(element);
            element.dispatchEvent(new TouchEvent('touchstart', {
                touches: [touch],
                targetTouches: [touch],
                changedTouches: [touch],
                ...touchInit,
            }));
        }
        this.simulatePointerFocus(element);
    }
    /**
     * Simulates a touch press release from an element.
     *
     * @param element The element to release pressing from.
     * @param init Additional event options.
     */
    simulateTouchRelease(element, init = {}, touchInit = {}) {
        this.removePseudoClass(element, ':active');
        this.forEachNodeFrom(element, (el) => {
            this.removePseudoClass(el, ':active');
        });
        const mouseInit = this.createMouseEventInit(element);
        const pointerInit = {
            ...mouseInit,
            isPrimary: true,
            pointerType: 'touch',
            ...init,
        };
        element.dispatchEvent(new PointerEvent('pointerup', pointerInit));
        // Firefox does not support TouchEvent constructor
        if (window.TouchEvent) {
            const touch = this.createTouch(element);
            element.dispatchEvent(new TouchEvent('touchend', { changedTouches: [touch], ...touchInit }));
        }
    }
    /**
     * Simulates a touch cancel from an element.
     *
     * @param element The element to cancel a touch for.
     * @param init Additional event options.
     */
    simulateTouchCancel(element, init = {}, touchInit = {}) {
        this.removePseudoClass(element, ':active');
        this.forEachNodeFrom(element, (el) => {
            this.removePseudoClass(el, ':active');
        });
        const mouseInit = this.createMouseEventInit(element);
        const pointerInit = {
            ...mouseInit,
            isPrimary: true,
            pointerType: 'touch',
            ...init,
        };
        element.dispatchEvent(new PointerEvent('pointercancel', pointerInit));
        // Firefox does not support TouchEvent constructor
        if (window.TouchEvent) {
            const touch = this.createTouch(element);
            element.dispatchEvent(new TouchEvent('touchcancel', { changedTouches: [touch], ...touchInit }));
        }
    }
    /**
     * Simulates a keypress on an element.
     *
     * @param element The element to press a key on.
     * @param key The key to press.
     * @param init Additional event options.
     */
    simulateKeypress(element, key, init = {}) {
        this.simulateKeydown(element, key, init);
        this.simulateKeyup(element, key, init);
    }
    /**
     * Simulates a keydown press on an element.
     *
     * @param element The element to press a key on.
     * @param key The key to press.
     * @param init Additional event options.
     */
    simulateKeydown(element, key, init = {}) {
        element.dispatchEvent(new KeyboardEvent('keydown', {
            ...init,
            key,
            bubbles: true,
            composed: true,
            cancelable: true,
        }));
    }
    /**
     * Simulates a keyup release from an element.
     *
     * @param element The element to release a key from.
     * @param key The key to release.
     * @param init Additional keyboard options.
     */
    simulateKeyup(element, key, init = {}) {
        element.dispatchEvent(new KeyboardEvent('keyup', {
            ...init,
            key,
            bubbles: true,
            composed: true,
            cancelable: true,
        }));
    }
    /**
     * Creates a MouseEventInit for an element. The default x/y coordinates of the
     * event init will be in the center of the element.
     *
     * @param element The element to create a `MouseEventInit` for.
     * @return The init object for a `MouseEvent`.
     */
    createMouseEventInit(element) {
        const rect = element.getBoundingClientRect();
        return {
            bubbles: true,
            cancelable: true,
            composed: true,
            clientX: (rect.left + rect.right) / 2,
            clientY: (rect.top + rect.bottom) / 2,
            screenX: (rect.left + rect.right) / 2,
            screenY: (rect.top + rect.bottom) / 2,
            // Primary button (usually the left button)
            button: 0,
            buttons: 1,
        };
    }
    /**
     * Creates a Touch instance for an element. The default x/y coordinates of the
     * touch will be in the center of the element. This can be used in the
     * `TouchEvent` constructor.
     *
     * @param element The element to create a touch for.
     * @param identifier Optional identifier for the touch. Defaults to 0 for
     *     every touch instance.
     * @return The `Touch` instance.
     */
    createTouch(element, identifier = 0) {
        const rect = element.getBoundingClientRect();
        return new Touch({
            identifier,
            target: element,
            clientX: (rect.left + rect.right) / 2,
            clientY: (rect.top + rect.bottom) / 2,
            screenX: (rect.left + rect.right) / 2,
            screenY: (rect.top + rect.bottom) / 2,
            pageX: (rect.left + rect.right) / 2,
            pageY: (rect.top + rect.bottom) / 2,
            touchType: 'direct',
        });
    }
    /**
     * Visit each node up the parent tree from the given child until reaching the
     * given parent.
     *
     * This is used to perform logic such as adding/removing recursive pseudo
     * classes like `:hover`.
     *
     * @param child The first child element to start from.
     * @param callback A callback that is invoked with each `HTMLElement` node
     *     from the child to the parent.
     * @param parent The last parent element to visit.
     */
    forEachNodeFrom(child, callback, parent = this.element) {
        let nextNode = child;
        while (nextNode && nextNode !== this.element) {
            const currentNode = nextNode;
            nextNode = currentNode.parentNode || currentNode.host;
            if (!(currentNode instanceof HTMLElement)) {
                continue;
            }
            callback(currentNode);
            if (nextNode instanceof HTMLElement && nextNode.shadowRoot) {
                const slot = currentNode.getAttribute('slot');
                const slotSelector = slot ? `slot[name=${slot}]` : 'slot:not([name])';
                const slotElement = nextNode.shadowRoot.querySelector(slotSelector);
                if (slotElement) {
                    this.forEachNodeFrom(slotElement, callback, nextNode);
                }
            }
        }
        callback(parent);
    }
    /**
     * Patch an element's methods, such as `querySelector` and `matches` to
     * handle transformed pseudo classes.
     *
     * For example, `element.matches(':focus')` will return true when the
     * `._focus` class is applied.
     *
     * @param element The element to patch.
     */
    patchForTransformedPseudoClasses(element) {
        if (this.patchedElements.has(element)) {
            return;
        }
        // Patch functions to handle pseudo selectors.
        const getSelector = (selector) => {
            if (this.transformPseudoClasses.includes(selector)) {
                return `.${getTransformedPseudoClass(selector)}`;
            }
            return selector;
        };
        const superMatches = this.element.matches;
        element.matches = (selector) => {
            return superMatches.call(element, getSelector(selector));
        };
        const superQuerySelector = this.element.querySelector;
        element.querySelector = (selector) => {
            return superQuerySelector.call(element, getSelector(selector));
        };
        const superQuerySelectorAll = this.element.querySelectorAll;
        element.querySelectorAll = (selector) => {
            return superQuerySelectorAll.call(element, getSelector(selector));
        };
        this.patchedElements.add(element);
    }
}
//# sourceMappingURL=harness.js.map
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\@material\web\testing\harness.js.map
================================================================================

{"version":3,"file":"harness.js","sourceRoot":"","sources":["harness.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n  defaultTransformPseudoClasses,\n  getTransformedPseudoClass,\n  transformPseudoClasses,\n} from './transform-pseudo-classes.js';\n\n/**\n * Retrieves the element type from a `Harness` type.\n *\n * @template H The harness type.\n */\nexport type HarnessElement<H extends Harness> = H extends Harness<infer E>\n  ? ElementWithHarness<E, H>\n  : never;\n\n/**\n * Harnesses will attach themselves to their element for convenience.\n *\n * @template E The element type.\n * @template H The harness type.\n */\nexport type ElementWithHarness<\n  E extends HTMLElement = HTMLElement,\n  H extends Harness<E> = Harness<E>,\n> = E & {\n  /**\n   * The harness for this element.\n   */\n  harness: H;\n\n  /**\n   * Associated form element.\n   */\n  form?: HTMLFormElement | null;\n};\n\n/**\n * Checks whether or not an element has a Harness attached to it on the\n * `element.harness` property.\n *\n * @param element The element to check.\n * @return True if the element has a harness property.\n */\nexport function isElementWithHarness(\n  element: Element,\n): element is ElementWithHarness {\n  return (element as unknown as ElementWithHarness).harness instanceof Harness;\n}\n\n/**\n * A test harness class that can be used to simulate interaction with an\n * element.\n *\n * @template E The harness's element type.\n */\nexport class Harness<E extends HTMLElement = HTMLElement> {\n  /**\n   * The pseudo classes that should be transformed for simulation. Component\n   * subclasses may override this to add additional pseudo classes.\n   */\n  protected transformPseudoClasses = defaultTransformPseudoClasses;\n\n  /**\n   * The element that this harness controls.\n   */\n  readonly element: E & ElementWithHarness<E, this>;\n\n  /**\n   * A set of elements that have already been patched to support transformed\n   * pseudo classes.\n   */\n  private readonly patchedElements = new WeakSet<HTMLElement>();\n\n  /**\n   * Creates a new harness for the given element.\n   *\n   * @param element The element that this harness controls.\n   */\n  constructor(element: E) {\n    this.element = element as ElementWithHarness<E, this>;\n    this.element.harness = this;\n  }\n\n  /**\n   * Resets the element's simulated classes to the default state.\n   */\n  async reset() {\n    const element = await this.getInteractiveElement();\n    for (const pseudoClass of this.transformPseudoClasses) {\n      this.forEachNodeFrom(element, (el) => {\n        this.removePseudoClass(el, pseudoClass);\n      });\n    }\n  }\n\n  /**\n   * Hovers and clicks on an element. This will generate a `click` event.\n   *\n   * @param init Additional event options.\n   */\n  async clickWithMouse(init: PointerEventInit = {}) {\n    await this.startClickWithMouse(init);\n    await this.endClickWithMouse(init);\n  }\n\n  /**\n   * Begins a click with a mouse. Use this along with `endClickWithMouse()` to\n   * customize the length of the click.\n   *\n   * @param init Additional event options.\n   */\n  async startClickWithMouse(init: PointerEventInit = {}) {\n    const element = await this.getInteractiveElement();\n    await this.startHover();\n    this.simulateMousePress(element, init);\n  }\n\n  /**\n   * Finishes a click with a mouse. Use this along with `startClickWithMouse()`\n   * to customize the length of the click. This will generate a `click` event.\n   *\n   * @param init Additional event options.\n   */\n  async endClickWithMouse(init: PointerEventInit = {}) {\n    const element = await this.getInteractiveElement();\n    this.simulateMouseRelease(element, init);\n    if ((init?.button ?? 0) === 0) {\n      // Dispatch a click for left-click only (default).\n      this.simulateClick(element, init);\n    }\n  }\n\n  /**\n   * Clicks an element with the keyboard (defaults to spacebar). This will\n   * generate a `click` event.\n   *\n   * @param init Additional event options.\n   */\n  async clickWithKeyboard(init: KeyboardEventInit = {}) {\n    const element = await this.getInteractiveElement();\n    await this.startClickWithKeyboard(init);\n    await this.endClickWithKeyboard(init);\n    this.simulateClick(element, init);\n  }\n\n  /**\n   * Begins a click with the keyboard (defaults to spacebar). Use this along\n   * with `endClickWithKeyboard()` to customize the length of the click.\n   *\n   * @param init Additional event options.\n   */\n  async startClickWithKeyboard(init: KeyboardEventInit = {}) {\n    const element = await this.getInteractiveElement();\n    await this.focusWithKeyboard(init);\n    this.simulateKeydown(element, init.key ?? ' ', init);\n    this.simulateClick(element, init);\n  }\n\n  /**\n   * Finishes a click with the keyboard (defaults to spacebar). Use this along\n   * with `startClickWithKeyboard()` to customize the length of the click.\n   *\n   * @param init Additional event options.\n   */\n  async endClickWithKeyboard(init: KeyboardEventInit = {}) {\n    const element = await this.getInteractiveElement();\n    this.simulateKeyup(element, init.key ?? ' ', init);\n    this.simulateClick(element, init);\n  }\n\n  /**\n   * Right-clicks and opens a context menu. This will generate a `contextmenu`\n   * event.\n   */\n  async rightClickWithMouse() {\n    const element = await this.getInteractiveElement();\n    const rightMouseButton = {button: 2, buttons: 2};\n    await this.startClickWithMouse(rightMouseButton);\n    // Note: contextmenu right clicks do not generate the up events\n    this.simulateContextmenu(element, rightMouseButton);\n  }\n\n  /**\n   * Taps once on the element with a simulated touch. This will generate a\n   * `click` event.\n   *\n   * @param init Additional event options.\n   * @param touchInit Additional touch event options.\n   */\n  async tap(init: PointerEventInit = {}, touchInit: TouchEventInit = {}) {\n    const element = await this.getInteractiveElement();\n    this.simulateTouchPress(element, init, touchInit);\n    this.simulateTouchRelease(element, init, touchInit);\n    if ((init?.isPrimary ?? true) === true) {\n      // Dispatch a click for primary touches only (default).\n      await this.endTapClick(init);\n    }\n  }\n\n  /**\n   * Begins a touch tap. Use this along with `endTap()` to customize the length\n   * or number of taps.\n   *\n   * @param init Additional event options.\n   * @param touchInit Additional touch event options.\n   */\n  async startTap(init: PointerEventInit = {}, touchInit: TouchEventInit = {}) {\n    const element = await this.getInteractiveElement();\n    this.simulateTouchPress(element, init, touchInit);\n  }\n\n  /**\n   * Simulates a `contextmenu` event for touch. Use this along with `startTap()`\n   * to generate a tap-and-hold context menu interaction.\n   *\n   * @param init Additional event options.\n   */\n  async startTapContextMenu(init: MouseEventInit = {}) {\n    const element = await this.getInteractiveElement();\n    this.simulateContextmenu(element, init);\n  }\n\n  /**\n   * Finished a touch tap. Use this along with `startTap()` to customize the\n   * length or number of taps.\n   *\n   * This will NOT generate a `click` event.\n   *\n   * @param init Additional event options.\n   * @param touchInit Additional touch event options.\n   */\n  async endTap(init: PointerEventInit = {}, touchInit: TouchEventInit = {}) {\n    const element = await this.getInteractiveElement();\n    this.simulateTouchRelease(element, init, touchInit);\n  }\n\n  /**\n   * Simulates a `click` event for touch. Use this along with `endTap()` to\n   * control the timing of tap and click events.\n   *\n   * @param init Additional event options.\n   */\n  async endTapClick(init: PointerEventInit = {}) {\n    const element = await this.getInteractiveElement();\n    this.simulateClick(element, {\n      pointerType: 'touch',\n      ...init,\n    });\n  }\n\n  /**\n   * Cancels a touch tap.\n   *\n   * @param init Additional event options.\n   * @param touchInit Additional touch event options.\n   */\n  async cancelTap(init: PointerEventInit = {}, touchInit: TouchEventInit = {}) {\n    const element = await this.getInteractiveElement();\n    this.simulateTouchCancel(element, init, touchInit);\n  }\n\n  /**\n   * Hovers over the element with a simulated mouse.\n   */\n  async startHover() {\n    const element = await this.getInteractiveElement();\n    this.simulateStartHover(element);\n  }\n\n  /**\n   * Moves the simulated mouse cursor off of the element.\n   */\n  async endHover() {\n    const element = await this.getInteractiveElement();\n    this.simulateEndHover(element);\n  }\n\n  /**\n   * Simulates focusing an element with the keyboard.\n   *\n   * @param init Additional event options.\n   */\n  async focusWithKeyboard(init: KeyboardEventInit = {}) {\n    const element = await this.getInteractiveElement();\n    this.simulateKeyboardFocus(element);\n  }\n\n  /**\n   * Simulates focusing an element with a pointer.\n   */\n  async focusWithPointer() {\n    const element = await this.getInteractiveElement();\n    await this.startHover();\n    this.simulatePointerFocus(element);\n  }\n\n  /**\n   * Simulates unfocusing an element.\n   */\n  async blur() {\n    const element = await this.getInteractiveElement();\n    await this.endHover();\n    this.simulateBlur(element);\n  }\n\n  /**\n   * Simulates a keypress on an element.\n   *\n   * @param key The key to press.\n   * @param init Additional event options.\n   */\n  async keypress(key: string, init: KeyboardEventInit = {}) {\n    const element = await this.getInteractiveElement();\n    this.simulateKeypress(element, key, init);\n  }\n\n  /**\n   * Simulates submitting the element's associated form element.\n   *\n   * @param form (Optional) form to submit, defaults to the elemnt's form.\n   * @return The submitted form data or null if the element has no associated\n   * form.\n   */\n  submitForm(form = this.element.form) {\n    if (!form) {\n      return new FormData();\n    }\n    return new Promise<FormData>((resolve) => {\n      const submitListener = (event: SubmitEvent) => {\n        event.preventDefault();\n        const data = new FormData(form);\n        resolve(data);\n        return false;\n      };\n\n      form.addEventListener('submit', submitListener, {once: true});\n      form.requestSubmit();\n    });\n  }\n\n  /**\n   * Returns the element that should be used for interaction simulation.\n   * Defaults to the host element itself.\n   *\n   * Subclasses should override this if the interactive element is not the host.\n   *\n   * @return The element to use in simulation.\n   */\n  protected async getInteractiveElement(): Promise<HTMLElement> {\n    return this.element;\n  }\n\n  /**\n   * Adds a pseudo class to an element. The element's shadow root styles (or\n   * document if not in a shadow root) will be transformed to support\n   * simulated pseudo classes.\n   *\n   * @param element The element to add a pseudo class to.\n   * @param pseudoClass The pseudo class to add.\n   */\n  protected addPseudoClass(element: HTMLElement, pseudoClass: string) {\n    if (!this.transformPseudoClasses.includes(pseudoClass)) {\n      return;\n    }\n\n    const root = element.getRootNode() as Document | ShadowRoot;\n    if (element.shadowRoot) {\n      transformPseudoClasses(\n        element.shadowRoot.adoptedStyleSheets || [],\n        this.transformPseudoClasses,\n      );\n    }\n\n    transformPseudoClasses(root.styleSheets, this.transformPseudoClasses);\n    transformPseudoClasses(\n      root.adoptedStyleSheets || [],\n      this.transformPseudoClasses,\n    );\n    element.classList.add(getTransformedPseudoClass(pseudoClass));\n    this.patchForTransformedPseudoClasses(element);\n  }\n\n  /**\n   * Removes a pseudo class from an element.\n   *\n   * @param element The element to remove a pseudo class from.\n   * @param pseudoClass The pseudo class to remove.\n   */\n  protected removePseudoClass(element: HTMLElement, pseudoClass: string) {\n    element.classList.remove(getTransformedPseudoClass(pseudoClass));\n  }\n\n  /**\n   * Simulates a click event.\n   *\n   * @param element The element to click.\n   * @param init Additional event options.\n   */\n  protected simulateClick(element: HTMLElement, init: MouseEventInit = {}) {\n    // Firefox does not support some simulations with PointerEvents, such as\n    // selecting an <input type=\"checkbox\">. Use MouseEvent for browser support.\n    element.dispatchEvent(\n      new MouseEvent('click', {\n        ...this.createMouseEventInit(element),\n        ...init,\n      }),\n    );\n  }\n\n  /**\n   * Simulates a contextmenu event.\n   *\n   * @param element The element to generate an event for.\n   * @param init Additional event options.\n   */\n  protected simulateContextmenu(\n    element: HTMLElement,\n    init: MouseEventInit = {},\n  ) {\n    element.dispatchEvent(\n      new MouseEvent('contextmenu', {\n        ...this.createMouseEventInit(element),\n        button: 2,\n        buttons: 2,\n        ...init,\n      }),\n    );\n  }\n\n  /**\n   * Simulates focusing with a keyboard. The difference between this and\n   * `simulatePointerFocus` is that keyboard focus will include the\n   * `:focus-visible` pseudo class.\n   *\n   * @param element The element to focus with a keyboard.\n   */\n  protected simulateKeyboardFocus(element: HTMLElement) {\n    this.simulateKeydown(element.ownerDocument, 'Tab');\n    this.addPseudoClass(element, ':focus-visible');\n    this.simulatePointerFocus(element);\n    this.simulateKeyup(element, 'Tab');\n  }\n\n  /**\n   * Simulates focusing with a pointer.\n   *\n   * @param element The element to focus with a pointer.\n   */\n  protected simulatePointerFocus(element: HTMLElement) {\n    this.addPseudoClass(element, ':focus');\n    this.forEachNodeFrom(element, (el) => {\n      this.addPseudoClass(el, ':focus-within');\n    });\n    element.dispatchEvent(new FocusEvent('focus', {composed: true}));\n    element.dispatchEvent(\n      new FocusEvent('focusin', {bubbles: true, composed: true}),\n    );\n  }\n\n  /**\n   * Simulates unfocusing an element.\n   *\n   * @param element The element to blur.\n   */\n  protected simulateBlur(element: HTMLElement) {\n    this.removePseudoClass(element, ':focus');\n    this.removePseudoClass(element, ':focus-visible');\n    this.forEachNodeFrom(element, (el) => {\n      this.removePseudoClass(el, ':focus-within');\n    });\n    element.dispatchEvent(new FocusEvent('blur', {composed: true}));\n    element.dispatchEvent(\n      new FocusEvent('focusout', {bubbles: true, composed: true}),\n    );\n  }\n\n  /**\n   * Simulates a mouse pointer hovering over an element.\n   *\n   * @param element The element to hover over.\n   * @param init Additional event options.\n   */\n  protected simulateStartHover(\n    element: HTMLElement,\n    init: PointerEventInit = {},\n  ) {\n    this.forEachNodeFrom(element, (el) => {\n      this.addPseudoClass(el, ':hover');\n    });\n    const rect = element.getBoundingClientRect();\n    const mouseInit = this.createMouseEventInit(element);\n    const mouseEnterInit = {\n      ...mouseInit,\n      bubbles: false,\n      clientX: rect.left,\n      clientY: rect.top,\n      screenX: rect.left,\n      screenY: rect.top,\n    };\n\n    const pointerInit = {\n      ...mouseInit,\n      isPrimary: true,\n      pointerType: 'mouse',\n    };\n\n    const pointerEnterInit: PointerEventInit = {\n      ...pointerInit,\n      ...mouseEnterInit,\n      ...init,\n    };\n\n    element.dispatchEvent(new PointerEvent('pointerover', pointerInit));\n    element.dispatchEvent(new PointerEvent('pointerenter', pointerEnterInit));\n    element.dispatchEvent(new MouseEvent('mouseover', mouseInit));\n    element.dispatchEvent(new MouseEvent('mouseenter', mouseEnterInit));\n  }\n\n  /**\n   * Simulates a mouse pointer leaving the element.\n   *\n   * @param element The element to stop hovering over.\n   * @param init Additional event options.\n   */\n  protected simulateEndHover(\n    element: HTMLElement,\n    init: PointerEventInit = {},\n  ) {\n    this.forEachNodeFrom(element, (el) => {\n      this.removePseudoClass(el, ':hover');\n    });\n    const rect = element.getBoundingClientRect();\n    const mouseInit = this.createMouseEventInit(element);\n    const mouseLeaveInit = {\n      ...mouseInit,\n      bubbles: false,\n      clientX: rect.left - 1,\n      clientY: rect.top - 1,\n      screenX: rect.left - 1,\n      screenY: rect.top - 1,\n    };\n\n    const pointerInit: PointerEventInit = {\n      ...mouseInit,\n      isPrimary: true,\n      pointerType: 'mouse',\n      ...init,\n    };\n\n    const pointerLeaveInit: PointerEventInit = {\n      ...pointerInit,\n      ...mouseLeaveInit,\n    };\n\n    element.dispatchEvent(new PointerEvent('pointerout', pointerInit));\n    element.dispatchEvent(new PointerEvent('pointerleave', pointerLeaveInit));\n    element.dispatchEvent(new MouseEvent('pointerout', mouseInit));\n    element.dispatchEvent(new MouseEvent('mouseleave', mouseLeaveInit));\n  }\n\n  /**\n   * Simulates a mouse press and hold on an element.\n   *\n   * @param element The element to press with a mouse.\n   * @param init Additional event options.\n   */\n  protected simulateMousePress(\n    element: HTMLElement,\n    init: PointerEventInit = {},\n  ) {\n    this.addPseudoClass(element, ':active');\n    this.forEachNodeFrom(element, (el) => {\n      this.addPseudoClass(el, ':active');\n    });\n    const mouseInit = this.createMouseEventInit(element);\n    const pointerInit: PointerEventInit = {\n      ...mouseInit,\n      isPrimary: true,\n      pointerType: 'mouse',\n      ...init,\n    };\n\n    element.dispatchEvent(new PointerEvent('pointerdown', pointerInit));\n    element.dispatchEvent(new MouseEvent('mousedown', mouseInit));\n    this.simulatePointerFocus(element);\n  }\n\n  /**\n   * Simulates a mouse press release from an element.\n   *\n   * @param element The element to release pressing from.\n   * @param init Additional event options.\n   */\n  protected simulateMouseRelease(\n    element: HTMLElement,\n    init: PointerEventInit = {},\n  ) {\n    this.removePseudoClass(element, ':active');\n    this.forEachNodeFrom(element, (el) => {\n      this.removePseudoClass(el, ':active');\n    });\n    const mouseInit = this.createMouseEventInit(element);\n    const pointerInit: PointerEventInit = {\n      ...mouseInit,\n      isPrimary: true,\n      pointerType: 'mouse',\n      ...init,\n    };\n\n    element.dispatchEvent(new PointerEvent('pointerup', pointerInit));\n    element.dispatchEvent(new MouseEvent('mouseup', mouseInit));\n  }\n\n  /**\n   * Simulates a touch press and hold on an element.\n   *\n   * @param element The element to press with a touch pointer.\n   * @param init Additional event options.\n   */\n  protected simulateTouchPress(\n    element: HTMLElement,\n    init: PointerEventInit = {},\n    touchInit: TouchEventInit = {},\n  ) {\n    this.addPseudoClass(element, ':active');\n    this.forEachNodeFrom(element, (el) => {\n      this.addPseudoClass(el, ':active');\n    });\n    const mouseInit = this.createMouseEventInit(element);\n    const pointerInit: PointerEventInit = {\n      ...mouseInit,\n      isPrimary: true,\n      pointerType: 'touch',\n      ...init,\n    };\n\n    element.dispatchEvent(new PointerEvent('pointerdown', pointerInit));\n    // Firefox does not support TouchEvent constructor\n    if (window.TouchEvent) {\n      const touch = this.createTouch(element);\n      element.dispatchEvent(\n        new TouchEvent('touchstart', {\n          touches: [touch],\n          targetTouches: [touch],\n          changedTouches: [touch],\n          ...touchInit,\n        }),\n      );\n    }\n    this.simulatePointerFocus(element);\n  }\n\n  /**\n   * Simulates a touch press release from an element.\n   *\n   * @param element The element to release pressing from.\n   * @param init Additional event options.\n   */\n  protected simulateTouchRelease(\n    element: HTMLElement,\n    init: PointerEventInit = {},\n    touchInit: TouchEventInit = {},\n  ) {\n    this.removePseudoClass(element, ':active');\n    this.forEachNodeFrom(element, (el) => {\n      this.removePseudoClass(el, ':active');\n    });\n    const mouseInit = this.createMouseEventInit(element);\n    const pointerInit: PointerEventInit = {\n      ...mouseInit,\n      isPrimary: true,\n      pointerType: 'touch',\n      ...init,\n    };\n\n    element.dispatchEvent(new PointerEvent('pointerup', pointerInit));\n    // Firefox does not support TouchEvent constructor\n    if (window.TouchEvent) {\n      const touch = this.createTouch(element);\n      element.dispatchEvent(\n        new TouchEvent('touchend', {changedTouches: [touch], ...touchInit}),\n      );\n    }\n  }\n\n  /**\n   * Simulates a touch cancel from an element.\n   *\n   * @param element The element to cancel a touch for.\n   * @param init Additional event options.\n   */\n  protected simulateTouchCancel(\n    element: HTMLElement,\n    init: PointerEventInit = {},\n    touchInit: TouchEventInit = {},\n  ) {\n    this.removePseudoClass(element, ':active');\n    this.forEachNodeFrom(element, (el) => {\n      this.removePseudoClass(el, ':active');\n    });\n    const mouseInit = this.createMouseEventInit(element);\n    const pointerInit: PointerEventInit = {\n      ...mouseInit,\n      isPrimary: true,\n      pointerType: 'touch',\n      ...init,\n    };\n\n    element.dispatchEvent(new PointerEvent('pointercancel', pointerInit));\n    // Firefox does not support TouchEvent constructor\n    if (window.TouchEvent) {\n      const touch = this.createTouch(element);\n      element.dispatchEvent(\n        new TouchEvent('touchcancel', {changedTouches: [touch], ...touchInit}),\n      );\n    }\n  }\n\n  /**\n   * Simulates a keypress on an element.\n   *\n   * @param element The element to press a key on.\n   * @param key The key to press.\n   * @param init Additional event options.\n   */\n  protected simulateKeypress(\n    element: EventTarget,\n    key: string,\n    init: KeyboardEventInit = {},\n  ) {\n    this.simulateKeydown(element, key, init);\n    this.simulateKeyup(element, key, init);\n  }\n\n  /**\n   * Simulates a keydown press on an element.\n   *\n   * @param element The element to press a key on.\n   * @param key The key to press.\n   * @param init Additional event options.\n   */\n  protected simulateKeydown(\n    element: EventTarget,\n    key: string,\n    init: KeyboardEventInit = {},\n  ) {\n    element.dispatchEvent(\n      new KeyboardEvent('keydown', {\n        ...init,\n        key,\n        bubbles: true,\n        composed: true,\n        cancelable: true,\n      }),\n    );\n  }\n\n  /**\n   * Simulates a keyup release from an element.\n   *\n   * @param element The element to release a key from.\n   * @param key The key to release.\n   * @param init Additional keyboard options.\n   */\n  protected simulateKeyup(\n    element: EventTarget,\n    key: string,\n    init: KeyboardEventInit = {},\n  ) {\n    element.dispatchEvent(\n      new KeyboardEvent('keyup', {\n        ...init,\n        key,\n        bubbles: true,\n        composed: true,\n        cancelable: true,\n      }),\n    );\n  }\n\n  /**\n   * Creates a MouseEventInit for an element. The default x/y coordinates of the\n   * event init will be in the center of the element.\n   *\n   * @param element The element to create a `MouseEventInit` for.\n   * @return The init object for a `MouseEvent`.\n   */\n  protected createMouseEventInit(element: HTMLElement): MouseEventInit {\n    const rect = element.getBoundingClientRect();\n    return {\n      bubbles: true,\n      cancelable: true,\n      composed: true,\n      clientX: (rect.left + rect.right) / 2,\n      clientY: (rect.top + rect.bottom) / 2,\n      screenX: (rect.left + rect.right) / 2,\n      screenY: (rect.top + rect.bottom) / 2,\n      // Primary button (usually the left button)\n      button: 0,\n      buttons: 1,\n    };\n  }\n\n  /**\n   * Creates a Touch instance for an element. The default x/y coordinates of the\n   * touch will be in the center of the element. This can be used in the\n   * `TouchEvent` constructor.\n   *\n   * @param element The element to create a touch for.\n   * @param identifier Optional identifier for the touch. Defaults to 0 for\n   *     every touch instance.\n   * @return The `Touch` instance.\n   */\n  protected createTouch(element: HTMLElement, identifier = 0): Touch {\n    const rect = element.getBoundingClientRect();\n    return new Touch({\n      identifier,\n      target: element,\n      clientX: (rect.left + rect.right) / 2,\n      clientY: (rect.top + rect.bottom) / 2,\n      screenX: (rect.left + rect.right) / 2,\n      screenY: (rect.top + rect.bottom) / 2,\n      pageX: (rect.left + rect.right) / 2,\n      pageY: (rect.top + rect.bottom) / 2,\n      touchType: 'direct',\n    });\n  }\n\n  /**\n   * Visit each node up the parent tree from the given child until reaching the\n   * given parent.\n   *\n   * This is used to perform logic such as adding/removing recursive pseudo\n   * classes like `:hover`.\n   *\n   * @param child The first child element to start from.\n   * @param callback A callback that is invoked with each `HTMLElement` node\n   *     from the child to the parent.\n   * @param parent The last parent element to visit.\n   */\n  protected forEachNodeFrom(\n    child: HTMLElement,\n    callback: (node: HTMLElement) => void,\n    parent: HTMLElement = this.element,\n  ) {\n    let nextNode: Node | null = child;\n    while (nextNode && nextNode !== this.element) {\n      const currentNode: Node = nextNode;\n      nextNode = currentNode.parentNode || (currentNode as ShadowRoot).host;\n\n      if (!(currentNode instanceof HTMLElement)) {\n        continue;\n      }\n\n      callback(currentNode);\n\n      if (nextNode instanceof HTMLElement && nextNode.shadowRoot) {\n        const slot = currentNode.getAttribute('slot');\n        const slotSelector = slot ? `slot[name=${slot}]` : 'slot:not([name])';\n        const slotElement =\n          nextNode.shadowRoot.querySelector<HTMLSlotElement>(slotSelector);\n        if (slotElement) {\n          this.forEachNodeFrom(slotElement, callback, nextNode);\n        }\n      }\n    }\n\n    callback(parent);\n  }\n\n  /**\n   * Patch an element's methods, such as `querySelector` and `matches` to\n   * handle transformed pseudo classes.\n   *\n   * For example, `element.matches(':focus')` will return true when the\n   * `._focus` class is applied.\n   *\n   * @param element The element to patch.\n   */\n  protected patchForTransformedPseudoClasses(element: HTMLElement) {\n    if (this.patchedElements.has(element)) {\n      return;\n    }\n\n    // Patch functions to handle pseudo selectors.\n    const getSelector = (selector: string) => {\n      if (this.transformPseudoClasses.includes(selector)) {\n        return `.${getTransformedPseudoClass(selector)}`;\n      }\n\n      return selector;\n    };\n\n    const superMatches = this.element.matches;\n    element.matches = (selector: string) => {\n      return superMatches.call(element, getSelector(selector));\n    };\n\n    const superQuerySelector = this.element.querySelector;\n    element.querySelector = (selector: string) => {\n      return superQuerySelector.call(element, getSelector(selector));\n    };\n\n    const superQuerySelectorAll = this.element.querySelectorAll;\n    element.querySelectorAll = (selector: string) => {\n      return superQuerySelectorAll.call(element, getSelector(selector));\n    };\n\n    this.patchedElements.add(element);\n  }\n}\n"]}
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\@material\web\testing\transform-pseudo-classes.d.ts
================================================================================

/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Array of pseudo classes to transform by default. These pseudo classes
 * represent state interactions from the user (such as :hover) or the browser
 * (such as :autofill) that cannot be reproduced with HTML markup.
 */
export declare const defaultTransformPseudoClasses: string[];
/**
 * Retrieves the transformed class name for a given pseudo class.
 *
 * @param pseudoClass The pseudo class to transform.
 * @return The transform pseudo class string.
 */
export declare function getTransformedPseudoClass(pseudoClass: string): string;
/**
 * Transforms a document's stylesheets' pseudo classes into normal classes with
 * a new stylesheet.
 *
 * Pseudo classes are given an underscore in their transformation. For example,
 * `:hover` transforms to `._hover`.
 *
 * ```css
 * .mdc-foo:hover {
 *   color: teal;
 * }
 * ```
 * ```css
 * .mdc-foo._hover {
 *   color: teal;
 * }
 * ```
 *
 * @param pseudoClasses An optional array of pseudo class names to transform.
 */
export declare function transformPseudoClasses(stylesheets: Iterable<CSSStyleSheet>, pseudoClasses?: string[]): void;

================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\@material\web\testing\transform-pseudo-classes.js
================================================================================

/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Array of pseudo classes to transform by default. These pseudo classes
 * represent state interactions from the user (such as :hover) or the browser
 * (such as :autofill) that cannot be reproduced with HTML markup.
 */
export const defaultTransformPseudoClasses = [
    ':active',
    ':autofill',
    ':focus',
    ':focus-visible',
    ':focus-within',
    ':hover',
    ':invalid',
    ':link',
    ':paused',
    ':playing',
    ':user-invalid',
    ':valid',
    ':visited',
];
/**
 * Retrieves the transformed class name for a given pseudo class.
 *
 * @param pseudoClass The pseudo class to transform.
 * @return The transform pseudo class string.
 */
export function getTransformedPseudoClass(pseudoClass) {
    return `_${pseudoClass.substring(1)}`;
}
/**
 * A weak set of stylesheets to use as reference for whether or not a stylesheet
 * has been transformed.
 */
const transformedStyleSheets = new WeakSet();
/**
 * Transforms a document's stylesheets' pseudo classes into normal classes with
 * a new stylesheet.
 *
 * Pseudo classes are given an underscore in their transformation. For example,
 * `:hover` transforms to `._hover`.
 *
 * ```css
 * .mdc-foo:hover {
 *   color: teal;
 * }
 * ```
 * ```css
 * .mdc-foo._hover {
 *   color: teal;
 * }
 * ```
 *
 * @param pseudoClasses An optional array of pseudo class names to transform.
 */
export function transformPseudoClasses(stylesheets, pseudoClasses = defaultTransformPseudoClasses) {
    for (const stylesheet of stylesheets) {
        if (transformedStyleSheets.has(stylesheet)) {
            continue;
        }
        let rules;
        try {
            rules = stylesheet.cssRules;
        }
        catch {
            continue;
        }
        for (let j = rules.length - 1; j >= 0; j--) {
            visitRule(rules[j], stylesheet, j, pseudoClasses);
        }
        transformedStyleSheets.add(stylesheet);
    }
}
/**
 * Determines whether or not the CSSRule is a CSSGroupingRule.
 *
 * Cannot check instanceof because FF treats a CSSStyleRule as a subclass of
 * CSSGroupingRule unlike Chrome and Safari
 */
function isCSSGroupingRule(rule) {
    return (!!rule?.cssRules &&
        !rule.selectorText);
}
/**
 * Visits a rule for the given stylesheet and adds a rule that replaces any
 * pseudo classes with a regular transformed class for simulation styling.
 *
 * @param rule The CSS rule to transform.
 * @param stylesheet The rule's parent stylesheet to update.
 * @param index The index of the rule in the parent stylesheet.
 * @param pseudoClasses An array of pseudo classes to search for and replace.
 */
function visitRule(rule, stylesheet, index, pseudoClasses) {
    if (isCSSGroupingRule(rule)) {
        for (let i = rule.cssRules.length - 1; i >= 0; i--) {
            visitRule(rule.cssRules[i], rule, i, pseudoClasses);
        }
        return;
    }
    if (!(rule instanceof CSSStyleRule)) {
        return;
    }
    try {
        let { selectorText } = rule;
        // match :foo, ensuring that it does not have a paren at the end
        // (no pseudo class functions like :foo())
        const regex = /(:(?![\w-]+\()[\w-]+)/g;
        const matches = Array.from(selectorText.matchAll(regex)).filter((match) => {
            // don't match pseudo elements like ::foo
            if (match.index != null && selectorText[match.index - 1] === ':') {
                return false;
            }
            return pseudoClasses.includes(match[1]);
        });
        if (!matches.length) {
            return;
        }
        matches.reverse();
        selectorText = rearrangePseudoElements(selectorText);
        for (const match of matches) {
            selectorText =
                selectorText.substring(0, match.index) +
                    `.${getTransformedPseudoClass(match[1])}` +
                    selectorText.substring(match.index + match[1].length);
        }
        const css = `${selectorText} {${rule.style.cssText}}`;
        stylesheet.insertRule(css, index + 1);
    }
    catch (error) {
        // Catch exception to skip the rule that cannot be parsed.
        console.error(error);
    }
}
/**
 * Re-arranges a selector's pseudo elements to appear at the end of the
 * selector. This prevents invalid CSS when replacing pseudo classes that
 * appear after a pseudo element.
 *
 * @example
 * // '.foo::before:hover' -> '.foo::before._hover' is invalid
 *
 * rearrangePseudoElements('.foo::before:hover'); // '.foo:hover::before'
 * // '.foo:hover::before' -> '.foo._hover::before' is valid
 *
 * @param selectorText The selector text string to re-arrange.
 * @return The re-arranged selector text.
 */
function rearrangePseudoElements(selectorText) {
    const pseudoElementsBeforeClasses = Array.from(selectorText.matchAll(/(?:::[\w-]+)+(?=:[\w-])/g));
    pseudoElementsBeforeClasses.reverse();
    for (const match of pseudoElementsBeforeClasses) {
        const pseudoElement = match[0];
        const pseudoElementIndex = match.index;
        const endOfCompoundSelector = selectorText
            .substring(pseudoElementIndex)
            .match(/(\s(?!([^\s].)*\))|,|$)/);
        const index = endOfCompoundSelector.index + pseudoElementIndex;
        selectorText =
            selectorText.substring(0, index) +
                pseudoElement +
                selectorText.substring(index);
        selectorText =
            selectorText.substring(0, pseudoElementIndex) +
                selectorText.substring(pseudoElementIndex + pseudoElement.length);
    }
    return selectorText;
}
//# sourceMappingURL=transform-pseudo-classes.js.map
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\@material\web\testing\transform-pseudo-classes.js.map
================================================================================

{"version":3,"file":"transform-pseudo-classes.js","sourceRoot":"","sources":["transform-pseudo-classes.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Array of pseudo classes to transform by default. These pseudo classes\n * represent state interactions from the user (such as :hover) or the browser\n * (such as :autofill) that cannot be reproduced with HTML markup.\n */\nexport const defaultTransformPseudoClasses = [\n  ':active',\n  ':autofill',\n  ':focus',\n  ':focus-visible',\n  ':focus-within',\n  ':hover',\n  ':invalid',\n  ':link',\n  ':paused',\n  ':playing',\n  ':user-invalid',\n  ':valid',\n  ':visited',\n];\n\n/**\n * Retrieves the transformed class name for a given pseudo class.\n *\n * @param pseudoClass The pseudo class to transform.\n * @return The transform pseudo class string.\n */\nexport function getTransformedPseudoClass(pseudoClass: string) {\n  return `_${pseudoClass.substring(1)}`;\n}\n\n/**\n * A weak set of stylesheets to use as reference for whether or not a stylesheet\n * has been transformed.\n */\nconst transformedStyleSheets = new WeakSet<CSSStyleSheet>();\n\n/**\n * Transforms a document's stylesheets' pseudo classes into normal classes with\n * a new stylesheet.\n *\n * Pseudo classes are given an underscore in their transformation. For example,\n * `:hover` transforms to `._hover`.\n *\n * ```css\n * .mdc-foo:hover {\n *   color: teal;\n * }\n * ```\n * ```css\n * .mdc-foo._hover {\n *   color: teal;\n * }\n * ```\n *\n * @param pseudoClasses An optional array of pseudo class names to transform.\n */\nexport function transformPseudoClasses(\n  stylesheets: Iterable<CSSStyleSheet>,\n  pseudoClasses = defaultTransformPseudoClasses,\n) {\n  for (const stylesheet of stylesheets) {\n    if (transformedStyleSheets.has(stylesheet)) {\n      continue;\n    }\n\n    let rules: CSSRuleList;\n    try {\n      rules = stylesheet.cssRules;\n    } catch {\n      continue;\n    }\n\n    for (let j = rules.length - 1; j >= 0; j--) {\n      visitRule(rules[j], stylesheet, j, pseudoClasses);\n    }\n\n    transformedStyleSheets.add(stylesheet);\n  }\n}\n\n/**\n * Determines whether or not the CSSRule is a CSSGroupingRule.\n *\n * Cannot check instanceof because FF treats a CSSStyleRule as a subclass of\n * CSSGroupingRule unlike Chrome and Safari\n */\nfunction isCSSGroupingRule(rule: CSSRule): rule is CSSGroupingRule {\n  return (\n    !!(rule as CSSGroupingRule)?.cssRules &&\n    !(rule as CSSStyleRule).selectorText\n  );\n}\n\n/**\n * Visits a rule for the given stylesheet and adds a rule that replaces any\n * pseudo classes with a regular transformed class for simulation styling.\n *\n * @param rule The CSS rule to transform.\n * @param stylesheet The rule's parent stylesheet to update.\n * @param index The index of the rule in the parent stylesheet.\n * @param pseudoClasses An array of pseudo classes to search for and replace.\n */\nfunction visitRule(\n  rule: CSSRule,\n  stylesheet: CSSStyleSheet | CSSGroupingRule,\n  index: number,\n  pseudoClasses: string[],\n) {\n  if (isCSSGroupingRule(rule)) {\n    for (let i = rule.cssRules.length - 1; i >= 0; i--) {\n      visitRule(rule.cssRules[i], rule, i, pseudoClasses);\n    }\n    return;\n  }\n\n  if (!(rule instanceof CSSStyleRule)) {\n    return;\n  }\n\n  try {\n    let {selectorText} = rule;\n    // match :foo, ensuring that it does not have a paren at the end\n    // (no pseudo class functions like :foo())\n    const regex = /(:(?![\\w-]+\\()[\\w-]+)/g;\n    const matches = Array.from(selectorText.matchAll(regex)).filter((match) => {\n      // don't match pseudo elements like ::foo\n      if (match.index != null && selectorText[match.index - 1] === ':') {\n        return false;\n      }\n      return pseudoClasses.includes(match[1]);\n    });\n\n    if (!matches.length) {\n      return;\n    }\n\n    matches.reverse();\n    selectorText = rearrangePseudoElements(selectorText);\n    for (const match of matches) {\n      selectorText =\n        selectorText.substring(0, match.index!) +\n        `.${getTransformedPseudoClass(match[1])}` +\n        selectorText.substring(match.index! + match[1].length);\n    }\n\n    const css = `${selectorText} {${rule.style.cssText}}`;\n    stylesheet.insertRule(css, index + 1);\n  } catch (error: unknown) {\n    // Catch exception to skip the rule that cannot be parsed.\n    console.error(error);\n  }\n}\n\n/**\n * Re-arranges a selector's pseudo elements to appear at the end of the\n * selector. This prevents invalid CSS when replacing pseudo classes that\n * appear after a pseudo element.\n *\n * @example\n * // '.foo::before:hover' -> '.foo::before._hover' is invalid\n *\n * rearrangePseudoElements('.foo::before:hover'); // '.foo:hover::before'\n * // '.foo:hover::before' -> '.foo._hover::before' is valid\n *\n * @param selectorText The selector text string to re-arrange.\n * @return The re-arranged selector text.\n */\nfunction rearrangePseudoElements(selectorText: string) {\n  const pseudoElementsBeforeClasses = Array.from(\n    selectorText.matchAll(/(?:::[\\w-]+)+(?=:[\\w-])/g),\n  );\n  pseudoElementsBeforeClasses.reverse();\n  for (const match of pseudoElementsBeforeClasses) {\n    const pseudoElement = match[0];\n    const pseudoElementIndex = match.index!;\n    const endOfCompoundSelector = selectorText\n      .substring(pseudoElementIndex)\n      .match(/(\\s(?!([^\\s].)*\\))|,|$)/)!;\n    const index = endOfCompoundSelector.index! + pseudoElementIndex;\n    selectorText =\n      selectorText.substring(0, index) +\n      pseudoElement +\n      selectorText.substring(index);\n    selectorText =\n      selectorText.substring(0, pseudoElementIndex) +\n      selectorText.substring(pseudoElementIndex + pseudoElement.length);\n  }\n\n  return selectorText;\n}\n"]}