=== Directory: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\foreground-child ===


================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\foreground-child\LICENSE
================================================================================

The ISC License

Copyright (c) 2015-2023 Isaac Z. Schlueter and Contributors

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\foreground-child\package.json
================================================================================

{
  "name": "foreground-child",
  "version": "3.3.0",
  "description": "Run a child as if it's the foreground process. Give it stdio. Exit when it exits.",
  "main": "./dist/commonjs/index.js",
  "types": "./dist/commonjs/index.d.ts",
  "exports": {
    "./watchdog": {
      "import": {
        "source": "./src/watchdog.ts",
        "types": "./dist/esm/watchdog.d.ts",
        "default": "./dist/esm/watchdog.js"
      },
      "require": {
        "source": "./src/watchdog.ts",
        "types": "./dist/commonjs/watchdog.d.ts",
        "default": "./dist/commonjs/watchdog.js"
      }
    },
    "./proxy-signals": {
      "import": {
        "source": "./src/proxy-signals.ts",
        "types": "./dist/esm/proxy-signals.d.ts",
        "default": "./dist/esm/proxy-signals.js"
      },
      "require": {
        "source": "./src/proxy-signals.ts",
        "types": "./dist/commonjs/proxy-signals.d.ts",
        "default": "./dist/commonjs/proxy-signals.js"
      }
    },
    "./package.json": "./package.json",
    ".": {
      "import": {
        "source": "./src/index.ts",
        "types": "./dist/esm/index.d.ts",
        "default": "./dist/esm/index.js"
      },
      "require": {
        "source": "./src/index.ts",
        "types": "./dist/commonjs/index.d.ts",
        "default": "./dist/commonjs/index.js"
      }
    }
  },
  "files": [
    "dist"
  ],
  "engines": {
    "node": ">=14"
  },
  "dependencies": {
    "cross-spawn": "^7.0.0",
    "signal-exit": "^4.0.1"
  },
  "scripts": {
    "preversion": "npm test",
    "postversion": "npm publish",
    "prepublishOnly": "git push origin --follow-tags",
    "prepare": "tshy",
    "pretest": "npm run prepare",
    "presnap": "npm run prepare",
    "test": "tap",
    "snap": "tap",
    "format": "prettier --write . --log-level warn",
    "typedoc": "typedoc --tsconfig .tshy/esm.json ./src/*.ts"
  },
  "prettier": {
    "experimentalTernaries": true,
    "semi": false,
    "printWidth": 75,
    "tabWidth": 2,
    "useTabs": false,
    "singleQuote": true,
    "jsxSingleQuote": false,
    "bracketSameLine": true,
    "arrowParens": "avoid",
    "endOfLine": "lf"
  },
  "tap": {
    "typecheck": true
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/tapjs/foreground-child.git"
  },
  "author": "Isaac Z. Schlueter <i@izs.me> (http://blog.izs.me/)",
  "license": "ISC",
  "devDependencies": {
    "@types/cross-spawn": "^6.0.2",
    "@types/node": "^18.15.11",
    "@types/tap": "^15.0.8",
    "prettier": "^3.3.2",
    "tap": "^19.2.5",
    "tshy": "^1.15.1",
    "typedoc": "^0.24.2",
    "typescript": "^5.0.2"
  },
  "funding": {
    "url": "https://github.com/sponsors/isaacs"
  },
  "tshy": {
    "exports": {
      "./watchdog": "./src/watchdog.ts",
      "./proxy-signals": "./src/proxy-signals.ts",
      "./package.json": "./package.json",
      ".": "./src/index.ts"
    }
  },
  "type": "module"
}

================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\foreground-child\README.md
================================================================================

# foreground-child

Run a child as if it's the foreground process. Give it stdio. Exit
when it exits.

Mostly this module is here to support some use cases around
wrapping child processes for test coverage and such. But it's
also generally useful any time you want one program to execute
another as if it's the "main" process, for example, if a program
takes a `--cmd` argument to execute in some way.

## USAGE

```js
import { foregroundChild } from 'foreground-child'
// hybrid module, this also works:
// const { foregroundChild } = require('foreground-child')

// cats out this file
const child = foregroundChild('cat', [__filename])

// At this point, it's best to just do nothing else.
// return or whatever.
// If the child gets a signal, or just exits, then this
// parent process will exit in the same way.
```

You can provide custom spawn options by passing an object after
the program and arguments:

```js
const child = foregroundChild(`cat ${__filename}`, { shell: true })
```

A callback can optionally be provided, if you want to perform an
action before your foreground-child exits:

```js
const child = foregroundChild('cat', [__filename], spawnOptions, () => {
  doSomeActions()
})
```

The callback can return a Promise in order to perform
asynchronous actions. If the callback does not return a promise,
then it must complete its actions within a single JavaScript
tick.

```js
const child = foregroundChild('cat', [__filename], async () => {
  await doSomeAsyncActions()
})
```

If the callback throws or rejects, then it will be unhandled, and
node will exit in error.

If the callback returns a string value, then that will be used as
the signal to exit the parent process. If it returns a number,
then that number will be used as the parent exit status code. If
it returns boolean `false`, then the parent process will not be
terminated. If it returns `undefined`, then it will exit with the
same signal/code as the child process.

## Caveats

The "normal" standard IO file descriptors (0, 1, and 2 for stdin,
stdout, and stderr respectively) are shared with the child process.
Additionally, if there is an IPC channel set up in the parent, then
messages are proxied to the child on file descriptor 3.

In Node, it's possible to also map arbitrary file descriptors
into a child process. In these cases, foreground-child will not
map the file descriptors into the child. If file descriptors 0,
1, or 2 are used for the IPC channel, then strange behavior may
happen (like printing IPC messages to stderr, for example).

Note that a SIGKILL will always kill the parent process, but
will not proxy the signal to the child process, because SIGKILL
cannot be caught. In order to address this, a special "watchdog"
child process is spawned which will send a SIGKILL to the child
process if it does not terminate within half a second after the
watchdog receives a SIGHUP due to its parent terminating.

On Windows, issuing a `process.kill(process.pid, signal)` with a
fatal termination signal may cause the process to exit with a `1`
status code rather than reporting the signal properly. This
module tries to do the right thing, but on Windows systems, you
may see that incorrect result. There is as far as I'm aware no
workaround for this.

## util: `foreground-child/proxy-signals`

If you just want to proxy the signals to a child process that the
main process receives, you can use the `proxy-signals` export
from this package.

```js
import { proxySignals } from 'foreground-child/proxy-signals'

const childProcess = spawn('command', ['some', 'args'])
proxySignals(childProcess)
```

Now, any fatal signal received by the current process will be
proxied to the child process.

It doesn't go in the other direction; ie, signals sent to the
child process will not affect the parent. For that, listen to the
child `exit` or `close` events, and handle them appropriately.

## util: `foreground-child/watchdog`

If you are spawning a child process, and want to ensure that it
isn't left dangling if the parent process exits, you can use the
watchdog utility exported by this module.

```js
import { watchdog } from 'foreground-child/watchdog'

const childProcess = spawn('command', ['some', 'args'])
const watchdogProcess = watchdog(childProcess)

// watchdogProcess is a reference to the process monitoring the
// parent and child. There's usually no reason to do anything
// with it, as it's silent and will terminate
// automatically when it's no longer needed.
```
