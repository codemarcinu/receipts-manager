=== Directory: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\@material\web\slider\internal ===


================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\@material\web\slider\internal\forced-colors-styles.css
================================================================================

@media(forced-colors: active){:host{--md-slider-active-track-color: CanvasText;--md-slider-disabled-active-track-color: GrayText;--md-slider-disabled-active-track-opacity: 1;--md-slider-disabled-handle-color: GrayText;--md-slider-disabled-inactive-track-color: GrayText;--md-slider-disabled-inactive-track-opacity: 1;--md-slider-focus-handle-color: CanvasText;--md-slider-handle-color: CanvasText;--md-slider-handle-shadow-color: Canvas;--md-slider-hover-handle-color: CanvasText;--md-slider-hover-state-layer-color: Canvas;--md-slider-hover-state-layer-opacity: 1;--md-slider-inactive-track-color: Canvas;--md-slider-label-container-color: Canvas;--md-slider-label-text-color: CanvasText;--md-slider-pressed-handle-color: CanvasText;--md-slider-pressed-state-layer-color: Canvas;--md-slider-pressed-state-layer-opacity: 1;--md-slider-with-overlap-handle-outline-color: CanvasText}.label,.label::before{border:var(--_with-overlap-handle-outline-color) solid var(--_with-overlap-handle-outline-width)}:host(:not([disabled])) .track::before{border:1px solid var(--_active-track-color)}.tickmarks::before{background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='CanvasText'%3E%3Ccircle cx='2' cy='2'  r='1'/%3E%3C/svg%3E")}.tickmarks::after{background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='Canvas'%3E%3Ccircle cx='2' cy='2' r='1'/%3E%3C/svg%3E")}:host([disabled]) .tickmarks::before{background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='Canvas'%3E%3Ccircle cx='2' cy='2'  r='1'/%3E%3C/svg%3E")}}/*# sourceMappingURL=forced-colors-styles.css.map */

================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\@material\web\slider\internal\forced-colors-styles.css.map
================================================================================

{"version":3,"sourceRoot":"","sources":["forced-colors-styles.scss","_slider.scss"],"names":[],"mappings":"AASA,8BACE,MCiBI,60BDYJ,sBAEE,iGAKF,uCACE,4CAIF,mBAgBE,sJAKF,kBAIE,iJAIF,qCAIE","file":"forced-colors-styles.css"}
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\@material\web\slider\internal\forced-colors-styles.d.ts
================================================================================

export declare const styles: import("lit").CSSResult;

================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\@material\web\slider\internal\forced-colors-styles.js
================================================================================

/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
// Generated stylesheet for ./slider/internal/forced-colors-styles.css.
import { css } from 'lit';
export const styles = css `@media(forced-colors: active){:host{--md-slider-active-track-color: CanvasText;--md-slider-disabled-active-track-color: GrayText;--md-slider-disabled-active-track-opacity: 1;--md-slider-disabled-handle-color: GrayText;--md-slider-disabled-inactive-track-color: GrayText;--md-slider-disabled-inactive-track-opacity: 1;--md-slider-focus-handle-color: CanvasText;--md-slider-handle-color: CanvasText;--md-slider-handle-shadow-color: Canvas;--md-slider-hover-handle-color: CanvasText;--md-slider-hover-state-layer-color: Canvas;--md-slider-hover-state-layer-opacity: 1;--md-slider-inactive-track-color: Canvas;--md-slider-label-container-color: Canvas;--md-slider-label-text-color: CanvasText;--md-slider-pressed-handle-color: CanvasText;--md-slider-pressed-state-layer-color: Canvas;--md-slider-pressed-state-layer-opacity: 1;--md-slider-with-overlap-handle-outline-color: CanvasText}.label,.label::before{border:var(--_with-overlap-handle-outline-color) solid var(--_with-overlap-handle-outline-width)}:host(:not([disabled])) .track::before{border:1px solid var(--_active-track-color)}.tickmarks::before{background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='CanvasText'%3E%3Ccircle cx='2' cy='2'  r='1'/%3E%3C/svg%3E")}.tickmarks::after{background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='Canvas'%3E%3Ccircle cx='2' cy='2' r='1'/%3E%3C/svg%3E")}:host([disabled]) .tickmarks::before{background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='Canvas'%3E%3Ccircle cx='2' cy='2'  r='1'/%3E%3C/svg%3E")}}
`;
//# sourceMappingURL=forced-colors-styles.js.map
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\@material\web\slider\internal\forced-colors-styles.js.map
================================================================================

{"version":3,"file":"forced-colors-styles.js","sourceRoot":"","sources":["forced-colors-styles.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AACH,uEAAuE;AACvE,OAAO,EAAC,GAAG,EAAC,MAAM,KAAK,CAAC;AACxB,MAAM,CAAC,MAAM,MAAM,GAAG,GAAG,CAAA;CACxB,CAAC","sourcesContent":["/**\n * @license\n * Copyright 2024 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n// Generated stylesheet for ./slider/internal/forced-colors-styles.css.\nimport {css} from 'lit';\nexport const styles = css`@media(forced-colors: active){:host{--md-slider-active-track-color: CanvasText;--md-slider-disabled-active-track-color: GrayText;--md-slider-disabled-active-track-opacity: 1;--md-slider-disabled-handle-color: GrayText;--md-slider-disabled-inactive-track-color: GrayText;--md-slider-disabled-inactive-track-opacity: 1;--md-slider-focus-handle-color: CanvasText;--md-slider-handle-color: CanvasText;--md-slider-handle-shadow-color: Canvas;--md-slider-hover-handle-color: CanvasText;--md-slider-hover-state-layer-color: Canvas;--md-slider-hover-state-layer-opacity: 1;--md-slider-inactive-track-color: Canvas;--md-slider-label-container-color: Canvas;--md-slider-label-text-color: CanvasText;--md-slider-pressed-handle-color: CanvasText;--md-slider-pressed-state-layer-color: Canvas;--md-slider-pressed-state-layer-opacity: 1;--md-slider-with-overlap-handle-outline-color: CanvasText}.label,.label::before{border:var(--_with-overlap-handle-outline-color) solid var(--_with-overlap-handle-outline-width)}:host(:not([disabled])) .track::before{border:1px solid var(--_active-track-color)}.tickmarks::before{background-image:url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='CanvasText'%3E%3Ccircle cx='2' cy='2'  r='1'/%3E%3C/svg%3E\")}.tickmarks::after{background-image:url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='Canvas'%3E%3Ccircle cx='2' cy='2' r='1'/%3E%3C/svg%3E\")}:host([disabled]) .tickmarks::before{background-image:url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='Canvas'%3E%3Ccircle cx='2' cy='2'  r='1'/%3E%3C/svg%3E\")}}\n`;\n"]}
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\@material\web\slider\internal\forced-colors-styles.scss
================================================================================

//
// Copyright 2022 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use './slider';
// go/keep-sorted end

@media (forced-colors: active) {
  :host {
    $container-color: CanvasText; // white
    $color: Canvas; // black
    $disabled-color: GrayText;
    @include slider.theme(
      (
        active-track-color: $container-color,
        disabled-active-track-color: $disabled-color,
        disabled-active-track-opacity: 1,
        disabled-handle-color: $disabled-color,
        disabled-inactive-track-color: $disabled-color,
        disabled-inactive-track-opacity: 1,
        focus-handle-color: $container-color,
        handle-color: $container-color,
        handle-shadow-color: $color,
        hover-handle-color: $container-color,
        hover-state-layer-color: $color,
        hover-state-layer-opacity: 1,
        inactive-track-color: $color,
        label-container-color: $color,
        label-text-color: $container-color,
        pressed-handle-color: $container-color,
        pressed-state-layer-color: $color,
        pressed-state-layer-opacity: 1,
        with-overlap-handle-outline-color: $container-color,
      )
    );
  }

  .label,
  .label::before {
    border: var(--_with-overlap-handle-outline-color) solid
      var(--_with-overlap-handle-outline-width);
  }

  // inactive track
  :host(:not([disabled])) .track::before {
    border: 1px solid var(--_active-track-color);
  }

  // inactive-track
  .tickmarks::before {
    // A url must be used when forced-colors is active as it's the only value
    // that is respected. The radial-gradient is not displayed. This is a
    // stop-gap solution so ticks are displayed at all when forced-colors is
    // active.
    // Note:
    // * The SVG has no viewBox which lets the svg take its dimensions from
    //   background-size.
    // * The fill is set directly. Using currentColor does not seem to work,
    //   hence the duplication of background-image.
    // * This approach does not respect tick sizes. Instead they will always be
    //   1px wide. This is a limitation of using the url, as I'm not sure how
    //   to pass in a custom property to change the `r` attribute.
    // TODO(b/298051946): Tick marks cannot be resized in HCM
    // stylelint-disable function-url-quotes -- SVG data URI
    // SVG is optimized for data URI (https://codepen.io/tigt/post/optimizing-svgs-in-data-uris)
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='CanvasText'%3E%3Ccircle cx='2' cy='2'  r='1'/%3E%3C/svg%3E");
    // stylelint-enable function-url-quotes
  }

  // active-track
  .tickmarks::after {
    // See inactive-track documentation for background-image.
    // stylelint-disable function-url-quotes -- SVG data URI
    // TODO(b/298051946): Tick marks cannot be resized in HCM
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='Canvas'%3E%3Ccircle cx='2' cy='2' r='1'/%3E%3C/svg%3E");
    // stylelint-enable function-url-quotes
  }

  :host([disabled]) .tickmarks::before {
    // TODO(b/298051946): Tick marks cannot be resized in HCM
    // stylelint-disable function-url-quotes -- SVG data URI
    // SVG is optimized for data URI (https://codepen.io/tigt/post/optimizing-svgs-in-data-uris)
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='Canvas'%3E%3Ccircle cx='2' cy='2'  r='1'/%3E%3C/svg%3E");
    // stylelint-enable function-url-quotes
  }
}

================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\@material\web\slider\internal\slider-styles.css
================================================================================

:host{--_active-track-color: var(--md-slider-active-track-color, var(--md-sys-color-primary, #6750a4));--_active-track-height: var(--md-slider-active-track-height, 4px);--_active-track-shape: var(--md-slider-active-track-shape, var(--md-sys-shape-corner-full, 9999px));--_disabled-active-track-color: var(--md-slider-disabled-active-track-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-active-track-opacity: var(--md-slider-disabled-active-track-opacity, 0.38);--_disabled-handle-color: var(--md-slider-disabled-handle-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-handle-elevation: var(--md-slider-disabled-handle-elevation, 0);--_disabled-inactive-track-color: var(--md-slider-disabled-inactive-track-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-inactive-track-opacity: var(--md-slider-disabled-inactive-track-opacity, 0.12);--_focus-handle-color: var(--md-slider-focus-handle-color, var(--md-sys-color-primary, #6750a4));--_handle-color: var(--md-slider-handle-color, var(--md-sys-color-primary, #6750a4));--_handle-elevation: var(--md-slider-handle-elevation, 1);--_handle-height: var(--md-slider-handle-height, 20px);--_handle-shadow-color: var(--md-slider-handle-shadow-color, var(--md-sys-color-shadow, #000));--_handle-shape: var(--md-slider-handle-shape, var(--md-sys-shape-corner-full, 9999px));--_handle-width: var(--md-slider-handle-width, 20px);--_hover-handle-color: var(--md-slider-hover-handle-color, var(--md-sys-color-primary, #6750a4));--_hover-state-layer-color: var(--md-slider-hover-state-layer-color, var(--md-sys-color-primary, #6750a4));--_hover-state-layer-opacity: var(--md-slider-hover-state-layer-opacity, 0.08);--_inactive-track-color: var(--md-slider-inactive-track-color, var(--md-sys-color-surface-container-highest, #e6e0e9));--_inactive-track-height: var(--md-slider-inactive-track-height, 4px);--_inactive-track-shape: var(--md-slider-inactive-track-shape, var(--md-sys-shape-corner-full, 9999px));--_label-container-color: var(--md-slider-label-container-color, var(--md-sys-color-primary, #6750a4));--_label-container-height: var(--md-slider-label-container-height, 28px);--_pressed-handle-color: var(--md-slider-pressed-handle-color, var(--md-sys-color-primary, #6750a4));--_pressed-state-layer-color: var(--md-slider-pressed-state-layer-color, var(--md-sys-color-primary, #6750a4));--_pressed-state-layer-opacity: var(--md-slider-pressed-state-layer-opacity, 0.12);--_state-layer-size: var(--md-slider-state-layer-size, 40px);--_with-overlap-handle-outline-color: var(--md-slider-with-overlap-handle-outline-color, var(--md-sys-color-on-primary, #fff));--_with-overlap-handle-outline-width: var(--md-slider-with-overlap-handle-outline-width, 1px);--_with-tick-marks-active-container-color: var(--md-slider-with-tick-marks-active-container-color, var(--md-sys-color-on-primary, #fff));--_with-tick-marks-container-size: var(--md-slider-with-tick-marks-container-size, 2px);--_with-tick-marks-disabled-container-color: var(--md-slider-with-tick-marks-disabled-container-color, var(--md-sys-color-on-surface, #1d1b20));--_with-tick-marks-inactive-container-color: var(--md-slider-with-tick-marks-inactive-container-color, var(--md-sys-color-on-surface-variant, #49454f));--_label-text-color: var(--md-slider-label-text-color, var(--md-sys-color-on-primary, #fff));--_label-text-font: var(--md-slider-label-text-font, var(--md-sys-typescale-label-medium-font, var(--md-ref-typeface-plain, Roboto)));--_label-text-line-height: var(--md-slider-label-text-line-height, var(--md-sys-typescale-label-medium-line-height, 1rem));--_label-text-size: var(--md-slider-label-text-size, var(--md-sys-typescale-label-medium-size, 0.75rem));--_label-text-weight: var(--md-slider-label-text-weight, var(--md-sys-typescale-label-medium-weight, var(--md-ref-typeface-weight-medium, 500)));--_start-fraction: 0;--_end-fraction: 0;--_tick-count: 0;display:inline-flex;vertical-align:middle;min-inline-size:200px;--md-elevation-level: var(--_handle-elevation);--md-elevation-shadow-color: var(--_handle-shadow-color)}md-focus-ring{height:48px;inset:unset;width:48px}md-elevation{transition-duration:250ms}@media(prefers-reduced-motion){.label{transition-duration:0}}:host([disabled]){opacity:var(--_disabled-active-track-opacity);--md-elevation-level: var(--_disabled-handle-elevation)}.container{flex:1;display:flex;align-items:center;position:relative;block-size:var(--_state-layer-size);pointer-events:none;touch-action:none}.track,.tickmarks{position:absolute;inset:0;display:flex;align-items:center}.track::before,.tickmarks::before,.track::after,.tickmarks::after{position:absolute;content:"";inset-inline-start:calc(var(--_state-layer-size)/2 - var(--_with-tick-marks-container-size));inset-inline-end:calc(var(--_state-layer-size)/2 - var(--_with-tick-marks-container-size));background-size:calc((100% - var(--_with-tick-marks-container-size)*2)/var(--_tick-count)) 100%}.track::before,.tickmarks::before{block-size:var(--_inactive-track-height);border-radius:var(--_inactive-track-shape)}.track::before{background:var(--_inactive-track-color)}.tickmarks::before{background-image:radial-gradient(circle at var(--_with-tick-marks-container-size) center, var(--_with-tick-marks-inactive-container-color) 0, var(--_with-tick-marks-inactive-container-color) calc(var(--_with-tick-marks-container-size) / 2), transparent calc(var(--_with-tick-marks-container-size) / 2))}:host([disabled]) .track::before{opacity:calc(1/var(--_disabled-active-track-opacity)*var(--_disabled-inactive-track-opacity));background:var(--_disabled-inactive-track-color)}.track::after,.tickmarks::after{block-size:var(--_active-track-height);border-radius:var(--_active-track-shape);clip-path:inset(0 calc(var(--_with-tick-marks-container-size) * min((1 - var(--_end-fraction)) * 1000000000, 1) + (100% - var(--_with-tick-marks-container-size) * 2) * (1 - var(--_end-fraction))) 0 calc(var(--_with-tick-marks-container-size) * min(var(--_start-fraction) * 1000000000, 1) + (100% - var(--_with-tick-marks-container-size) * 2) * var(--_start-fraction)))}.track::after{background:var(--_active-track-color)}.tickmarks::after{background-image:radial-gradient(circle at var(--_with-tick-marks-container-size) center, var(--_with-tick-marks-active-container-color) 0, var(--_with-tick-marks-active-container-color) calc(var(--_with-tick-marks-container-size) / 2), transparent calc(var(--_with-tick-marks-container-size) / 2))}.track:dir(rtl)::after{clip-path:inset(0 calc(var(--_with-tick-marks-container-size) * min(var(--_start-fraction) * 1000000000, 1) + (100% - var(--_with-tick-marks-container-size) * 2) * var(--_start-fraction)) 0 calc(var(--_with-tick-marks-container-size) * min((1 - var(--_end-fraction)) * 1000000000, 1) + (100% - var(--_with-tick-marks-container-size) * 2) * (1 - var(--_end-fraction))))}.tickmarks:dir(rtl)::after{clip-path:inset(0 calc(var(--_with-tick-marks-container-size) * min(var(--_start-fraction) * 1000000000, 1) + (100% - var(--_with-tick-marks-container-size) * 2) * var(--_start-fraction)) 0 calc(var(--_with-tick-marks-container-size) * min((1 - var(--_end-fraction)) * 1000000000, 1) + (100% - var(--_with-tick-marks-container-size) * 2) * (1 - var(--_end-fraction))))}:host([disabled]) .track::after{background:var(--_disabled-active-track-color)}:host([disabled]) .tickmarks::before{background-image:radial-gradient(circle at var(--_with-tick-marks-container-size) center, var(--_with-tick-marks-disabled-container-color) 0, var(--_with-tick-marks-disabled-container-color) calc(var(--_with-tick-marks-container-size) / 2), transparent calc(var(--_with-tick-marks-container-size) / 2))}.handleContainerPadded{position:relative;block-size:100%;inline-size:100%;padding-inline:calc(var(--_state-layer-size)/2)}.handleContainerBlock{position:relative;block-size:100%;inline-size:100%}.handleContainer{position:absolute;inset-block-start:0;inset-block-end:0;inset-inline-start:calc(100%*var(--_start-fraction));inline-size:calc(100%*(var(--_end-fraction) - var(--_start-fraction)))}.handle{position:absolute;block-size:var(--_state-layer-size);inline-size:var(--_state-layer-size);border-radius:var(--_handle-shape);display:flex;place-content:center;place-items:center}.handleNub{position:absolute;height:var(--_handle-height);width:var(--_handle-width);border-radius:var(--_handle-shape);background:var(--_handle-color)}:host([disabled]) .handleNub{background:var(--_disabled-handle-color)}input.end:focus~.handleContainerPadded .handle.end>.handleNub,input.start:focus~.handleContainerPadded .handle.start>.handleNub{background:var(--_focus-handle-color)}.container>.handleContainerPadded .handle.hover>.handleNub{background:var(--_hover-handle-color)}:host(:not([disabled])) input.end:active~.handleContainerPadded .handle.end>.handleNub,:host(:not([disabled])) input.start:active~.handleContainerPadded .handle.start>.handleNub{background:var(--_pressed-handle-color)}.onTop.isOverlapping .label,.onTop.isOverlapping .label::before{outline:var(--_with-overlap-handle-outline-color) solid var(--_with-overlap-handle-outline-width)}.onTop.isOverlapping .handleNub{border:var(--_with-overlap-handle-outline-color) solid var(--_with-overlap-handle-outline-width)}.handle.start{inset-inline-start:calc(0px - var(--_state-layer-size)/2)}.handle.end{inset-inline-end:calc(0px - var(--_state-layer-size)/2)}.label{position:absolute;box-sizing:border-box;display:flex;padding:4px;place-content:center;place-items:center;border-radius:var(--md-sys-shape-corner-full, 9999px);color:var(--_label-text-color);font-family:var(--_label-text-font);font-size:var(--_label-text-size);line-height:var(--_label-text-line-height);font-weight:var(--_label-text-weight);inset-block-end:100%;min-inline-size:var(--_label-container-height);min-block-size:var(--_label-container-height);background:var(--_label-container-color);transition:transform 100ms cubic-bezier(0.2, 0, 0, 1);transform-origin:center bottom;transform:scale(0)}:host(:focus-within) .label,.handleContainer.hover .label,:where(:has(input:active)) .label{transform:scale(1)}.label::before,.label::after{position:absolute;display:block;content:"";background:inherit}.label::before{inline-size:calc(var(--_label-container-height)/2);block-size:calc(var(--_label-container-height)/2);bottom:calc(var(--_label-container-height)/-10);transform:rotate(45deg)}.label::after{inset:0px;border-radius:inherit}.labelContent{z-index:1}input[type=range]{opacity:0;-webkit-tap-highlight-color:rgba(0,0,0,0);position:absolute;box-sizing:border-box;height:100%;width:100%;margin:0;background:rgba(0,0,0,0);cursor:pointer;pointer-events:auto;appearance:none}input[type=range]:focus{outline:none}::-webkit-slider-runnable-track{-webkit-appearance:none}::-moz-range-track{appearance:none}::-webkit-slider-thumb{-webkit-appearance:none;appearance:none;block-size:var(--_handle-height);inline-size:var(--_handle-width);opacity:0;z-index:2}input.end::-webkit-slider-thumb{--_track-and-knob-padding: calc( (var(--_state-layer-size) - var(--_handle-width)) / 2 );--_x-translate: calc( var(--_track-and-knob-padding) - 2 * var(--_end-fraction) * var(--_track-and-knob-padding) );transform:translateX(var(--_x-translate))}input.end:dir(rtl)::-webkit-slider-thumb{transform:translateX(calc(-1 * var(--_x-translate)))}input.start::-webkit-slider-thumb{--_track-and-knob-padding: calc( (var(--_state-layer-size) - var(--_handle-width)) / 2 );--_x-translate: calc( var(--_track-and-knob-padding) - 2 * var(--_start-fraction) * var(--_track-and-knob-padding) );transform:translateX(var(--_x-translate))}input.start:dir(rtl)::-webkit-slider-thumb{transform:translateX(calc(-1 * var(--_x-translate)))}::-moz-range-thumb{appearance:none;block-size:var(--_state-layer-size);inline-size:var(--_state-layer-size);transform:scaleX(0);opacity:0;z-index:2}.ranged input.start{clip-path:inset(0 calc(100% - (var(--_state-layer-size) / 2 + (100% - var(--_state-layer-size)) * (var(--_start-fraction) + (var(--_end-fraction) - var(--_start-fraction)) / 2))) 0 0)}.ranged input.start:dir(rtl){clip-path:inset(0 0 0 calc(100% - (var(--_state-layer-size) / 2 + (100% - var(--_state-layer-size)) * (var(--_start-fraction) + (var(--_end-fraction) - var(--_start-fraction)) / 2))))}.ranged input.end{clip-path:inset(0 0 0 calc(var(--_state-layer-size) / 2 + (100% - var(--_state-layer-size)) * (var(--_start-fraction) + (var(--_end-fraction) - var(--_start-fraction)) / 2)))}.ranged input.end:dir(rtl){clip-path:inset(0 calc(var(--_state-layer-size) / 2 + (100% - var(--_state-layer-size)) * (var(--_start-fraction) + (var(--_end-fraction) - var(--_start-fraction)) / 2)) 0 0)}.onTop{z-index:1}.handle{--md-ripple-hover-color: var(--_hover-state-layer-color);--md-ripple-hover-opacity: var(--_hover-state-layer-opacity);--md-ripple-pressed-color: var(--_pressed-state-layer-color);--md-ripple-pressed-opacity: var(--_pressed-state-layer-opacity)}md-ripple{border-radius:50%;height:var(--_state-layer-size);width:var(--_state-layer-size)}/*# sourceMappingURL=slider-styles.css.map */

================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\@material\web\slider\internal\slider-styles.css.map
================================================================================

{"version":3,"sourceRoot":"","sources":["_slider.scss","../../elevation/internal/_elevation.scss","../../ripple/internal/_ripple.scss"],"names":[],"mappings":"AA+DE,MAEI,owHAIF,qBACA,mBACA,iBAEA,oBACA,sBACA,sBCrDE,wGD+DJ,cACE,YACA,YACA,WAGF,aACE,0BAIF,+BACE,OACE,uBAOJ,kBACE,8CCpFE,wDD6FJ,WACE,OACA,aACA,mBACA,kBACA,oCAEA,oBAEA,kBAGF,kBAEE,kBACA,QACA,aACA,mBAIF,kEAKE,kBACA,WAKA,mBAHiB,0EAIjB,iBAJiB,0EAOjB,gGAOF,kCAEE,yCACA,2CAGF,eACE,wCAGF,mBACE,+SAKF,iCAGE,8FAIA,iDAIF,gCAEE,uCACA,yCACA,iXAGF,cACE,sCAGF,kBACE,2SAMF,uBACE,iXAGF,2BACE,iXAGF,gCACE,+CAGF,qCACE,+SAWF,uBACE,kBACA,gBACA,iBACA,gDAGF,sBACE,kBACA,gBACA,iBAGF,iBACE,kBACA,oBACA,kBACA,qDACA,uEAIF,QACE,kBACA,oCACA,qCACA,mCACA,aACA,qBACA,mBAGF,WACE,kBACA,6BACA,2BACA,mCACA,gCAGF,6BACE,yCAGF,gIAEE,sCAIF,2DACE,sCAIA,kLAEE,wCAKF,gEAEE,kGAIF,gCACE,iGAKJ,cACE,0DAEF,YACE,wDAIF,OACE,kBACA,sBACA,aACA,YACA,qBACA,mBACA,sDAEA,+BACA,oCACA,kCACA,2CACA,sCAEA,qBACA,+CACA,8CACA,yCACA,sDAEA,+BACA,mBAKF,4FAGE,mBAGF,6BAEE,kBACA,cACA,WACA,mBAIF,eAGE,YADgB,uCAEhB,WAFgB,uCAGhB,gDACA,wBAIF,cACE,UACA,sBAIF,cACE,UAOF,kBACE,UACA,0CACA,kBACA,sBAEA,YACA,WACA,SACA,yBACA,eACA,oBACA,gBAGF,wBACE,aAGF,gCACE,wBAGF,mBACE,gBAGF,uBACE,wBACA,gBAEA,iCACA,iCACA,UACA,UAgGF,gCAEE,yFAGA,mHAIA,0CAGF,yCACE,qDAbF,kCAEE,yFAGA,qHAIA,0CAGF,2CACE,qDAvGF,mBACE,gBACA,oCACA,qCACA,oBACA,UACA,UAgBF,oBACE,wLAIF,6BACE,wLAIF,kBACE,+KAIF,2BACE,+KAGF,OACE,UAIF,QExbI,oPFmcJ,UACE,kBACA,gCACA","file":"slider-styles.css"}
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\@material\web\slider\internal\slider-styles.d.ts
================================================================================

export declare const styles: import("lit").CSSResult;

================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\@material\web\slider\internal\slider-styles.js
================================================================================

/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
// Generated stylesheet for ./slider/internal/slider-styles.css.
import { css } from 'lit';
export const styles = css `:host{--_active-track-color: var(--md-slider-active-track-color, var(--md-sys-color-primary, #6750a4));--_active-track-height: var(--md-slider-active-track-height, 4px);--_active-track-shape: var(--md-slider-active-track-shape, var(--md-sys-shape-corner-full, 9999px));--_disabled-active-track-color: var(--md-slider-disabled-active-track-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-active-track-opacity: var(--md-slider-disabled-active-track-opacity, 0.38);--_disabled-handle-color: var(--md-slider-disabled-handle-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-handle-elevation: var(--md-slider-disabled-handle-elevation, 0);--_disabled-inactive-track-color: var(--md-slider-disabled-inactive-track-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-inactive-track-opacity: var(--md-slider-disabled-inactive-track-opacity, 0.12);--_focus-handle-color: var(--md-slider-focus-handle-color, var(--md-sys-color-primary, #6750a4));--_handle-color: var(--md-slider-handle-color, var(--md-sys-color-primary, #6750a4));--_handle-elevation: var(--md-slider-handle-elevation, 1);--_handle-height: var(--md-slider-handle-height, 20px);--_handle-shadow-color: var(--md-slider-handle-shadow-color, var(--md-sys-color-shadow, #000));--_handle-shape: var(--md-slider-handle-shape, var(--md-sys-shape-corner-full, 9999px));--_handle-width: var(--md-slider-handle-width, 20px);--_hover-handle-color: var(--md-slider-hover-handle-color, var(--md-sys-color-primary, #6750a4));--_hover-state-layer-color: var(--md-slider-hover-state-layer-color, var(--md-sys-color-primary, #6750a4));--_hover-state-layer-opacity: var(--md-slider-hover-state-layer-opacity, 0.08);--_inactive-track-color: var(--md-slider-inactive-track-color, var(--md-sys-color-surface-container-highest, #e6e0e9));--_inactive-track-height: var(--md-slider-inactive-track-height, 4px);--_inactive-track-shape: var(--md-slider-inactive-track-shape, var(--md-sys-shape-corner-full, 9999px));--_label-container-color: var(--md-slider-label-container-color, var(--md-sys-color-primary, #6750a4));--_label-container-height: var(--md-slider-label-container-height, 28px);--_pressed-handle-color: var(--md-slider-pressed-handle-color, var(--md-sys-color-primary, #6750a4));--_pressed-state-layer-color: var(--md-slider-pressed-state-layer-color, var(--md-sys-color-primary, #6750a4));--_pressed-state-layer-opacity: var(--md-slider-pressed-state-layer-opacity, 0.12);--_state-layer-size: var(--md-slider-state-layer-size, 40px);--_with-overlap-handle-outline-color: var(--md-slider-with-overlap-handle-outline-color, var(--md-sys-color-on-primary, #fff));--_with-overlap-handle-outline-width: var(--md-slider-with-overlap-handle-outline-width, 1px);--_with-tick-marks-active-container-color: var(--md-slider-with-tick-marks-active-container-color, var(--md-sys-color-on-primary, #fff));--_with-tick-marks-container-size: var(--md-slider-with-tick-marks-container-size, 2px);--_with-tick-marks-disabled-container-color: var(--md-slider-with-tick-marks-disabled-container-color, var(--md-sys-color-on-surface, #1d1b20));--_with-tick-marks-inactive-container-color: var(--md-slider-with-tick-marks-inactive-container-color, var(--md-sys-color-on-surface-variant, #49454f));--_label-text-color: var(--md-slider-label-text-color, var(--md-sys-color-on-primary, #fff));--_label-text-font: var(--md-slider-label-text-font, var(--md-sys-typescale-label-medium-font, var(--md-ref-typeface-plain, Roboto)));--_label-text-line-height: var(--md-slider-label-text-line-height, var(--md-sys-typescale-label-medium-line-height, 1rem));--_label-text-size: var(--md-slider-label-text-size, var(--md-sys-typescale-label-medium-size, 0.75rem));--_label-text-weight: var(--md-slider-label-text-weight, var(--md-sys-typescale-label-medium-weight, var(--md-ref-typeface-weight-medium, 500)));--_start-fraction: 0;--_end-fraction: 0;--_tick-count: 0;display:inline-flex;vertical-align:middle;min-inline-size:200px;--md-elevation-level: var(--_handle-elevation);--md-elevation-shadow-color: var(--_handle-shadow-color)}md-focus-ring{height:48px;inset:unset;width:48px}md-elevation{transition-duration:250ms}@media(prefers-reduced-motion){.label{transition-duration:0}}:host([disabled]){opacity:var(--_disabled-active-track-opacity);--md-elevation-level: var(--_disabled-handle-elevation)}.container{flex:1;display:flex;align-items:center;position:relative;block-size:var(--_state-layer-size);pointer-events:none;touch-action:none}.track,.tickmarks{position:absolute;inset:0;display:flex;align-items:center}.track::before,.tickmarks::before,.track::after,.tickmarks::after{position:absolute;content:"";inset-inline-start:calc(var(--_state-layer-size)/2 - var(--_with-tick-marks-container-size));inset-inline-end:calc(var(--_state-layer-size)/2 - var(--_with-tick-marks-container-size));background-size:calc((100% - var(--_with-tick-marks-container-size)*2)/var(--_tick-count)) 100%}.track::before,.tickmarks::before{block-size:var(--_inactive-track-height);border-radius:var(--_inactive-track-shape)}.track::before{background:var(--_inactive-track-color)}.tickmarks::before{background-image:radial-gradient(circle at var(--_with-tick-marks-container-size) center, var(--_with-tick-marks-inactive-container-color) 0, var(--_with-tick-marks-inactive-container-color) calc(var(--_with-tick-marks-container-size) / 2), transparent calc(var(--_with-tick-marks-container-size) / 2))}:host([disabled]) .track::before{opacity:calc(1/var(--_disabled-active-track-opacity)*var(--_disabled-inactive-track-opacity));background:var(--_disabled-inactive-track-color)}.track::after,.tickmarks::after{block-size:var(--_active-track-height);border-radius:var(--_active-track-shape);clip-path:inset(0 calc(var(--_with-tick-marks-container-size) * min((1 - var(--_end-fraction)) * 1000000000, 1) + (100% - var(--_with-tick-marks-container-size) * 2) * (1 - var(--_end-fraction))) 0 calc(var(--_with-tick-marks-container-size) * min(var(--_start-fraction) * 1000000000, 1) + (100% - var(--_with-tick-marks-container-size) * 2) * var(--_start-fraction)))}.track::after{background:var(--_active-track-color)}.tickmarks::after{background-image:radial-gradient(circle at var(--_with-tick-marks-container-size) center, var(--_with-tick-marks-active-container-color) 0, var(--_with-tick-marks-active-container-color) calc(var(--_with-tick-marks-container-size) / 2), transparent calc(var(--_with-tick-marks-container-size) / 2))}.track:dir(rtl)::after{clip-path:inset(0 calc(var(--_with-tick-marks-container-size) * min(var(--_start-fraction) * 1000000000, 1) + (100% - var(--_with-tick-marks-container-size) * 2) * var(--_start-fraction)) 0 calc(var(--_with-tick-marks-container-size) * min((1 - var(--_end-fraction)) * 1000000000, 1) + (100% - var(--_with-tick-marks-container-size) * 2) * (1 - var(--_end-fraction))))}.tickmarks:dir(rtl)::after{clip-path:inset(0 calc(var(--_with-tick-marks-container-size) * min(var(--_start-fraction) * 1000000000, 1) + (100% - var(--_with-tick-marks-container-size) * 2) * var(--_start-fraction)) 0 calc(var(--_with-tick-marks-container-size) * min((1 - var(--_end-fraction)) * 1000000000, 1) + (100% - var(--_with-tick-marks-container-size) * 2) * (1 - var(--_end-fraction))))}:host([disabled]) .track::after{background:var(--_disabled-active-track-color)}:host([disabled]) .tickmarks::before{background-image:radial-gradient(circle at var(--_with-tick-marks-container-size) center, var(--_with-tick-marks-disabled-container-color) 0, var(--_with-tick-marks-disabled-container-color) calc(var(--_with-tick-marks-container-size) / 2), transparent calc(var(--_with-tick-marks-container-size) / 2))}.handleContainerPadded{position:relative;block-size:100%;inline-size:100%;padding-inline:calc(var(--_state-layer-size)/2)}.handleContainerBlock{position:relative;block-size:100%;inline-size:100%}.handleContainer{position:absolute;inset-block-start:0;inset-block-end:0;inset-inline-start:calc(100%*var(--_start-fraction));inline-size:calc(100%*(var(--_end-fraction) - var(--_start-fraction)))}.handle{position:absolute;block-size:var(--_state-layer-size);inline-size:var(--_state-layer-size);border-radius:var(--_handle-shape);display:flex;place-content:center;place-items:center}.handleNub{position:absolute;height:var(--_handle-height);width:var(--_handle-width);border-radius:var(--_handle-shape);background:var(--_handle-color)}:host([disabled]) .handleNub{background:var(--_disabled-handle-color)}input.end:focus~.handleContainerPadded .handle.end>.handleNub,input.start:focus~.handleContainerPadded .handle.start>.handleNub{background:var(--_focus-handle-color)}.container>.handleContainerPadded .handle.hover>.handleNub{background:var(--_hover-handle-color)}:host(:not([disabled])) input.end:active~.handleContainerPadded .handle.end>.handleNub,:host(:not([disabled])) input.start:active~.handleContainerPadded .handle.start>.handleNub{background:var(--_pressed-handle-color)}.onTop.isOverlapping .label,.onTop.isOverlapping .label::before{outline:var(--_with-overlap-handle-outline-color) solid var(--_with-overlap-handle-outline-width)}.onTop.isOverlapping .handleNub{border:var(--_with-overlap-handle-outline-color) solid var(--_with-overlap-handle-outline-width)}.handle.start{inset-inline-start:calc(0px - var(--_state-layer-size)/2)}.handle.end{inset-inline-end:calc(0px - var(--_state-layer-size)/2)}.label{position:absolute;box-sizing:border-box;display:flex;padding:4px;place-content:center;place-items:center;border-radius:var(--md-sys-shape-corner-full, 9999px);color:var(--_label-text-color);font-family:var(--_label-text-font);font-size:var(--_label-text-size);line-height:var(--_label-text-line-height);font-weight:var(--_label-text-weight);inset-block-end:100%;min-inline-size:var(--_label-container-height);min-block-size:var(--_label-container-height);background:var(--_label-container-color);transition:transform 100ms cubic-bezier(0.2, 0, 0, 1);transform-origin:center bottom;transform:scale(0)}:host(:focus-within) .label,.handleContainer.hover .label,:where(:has(input:active)) .label{transform:scale(1)}.label::before,.label::after{position:absolute;display:block;content:"";background:inherit}.label::before{inline-size:calc(var(--_label-container-height)/2);block-size:calc(var(--_label-container-height)/2);bottom:calc(var(--_label-container-height)/-10);transform:rotate(45deg)}.label::after{inset:0px;border-radius:inherit}.labelContent{z-index:1}input[type=range]{opacity:0;-webkit-tap-highlight-color:rgba(0,0,0,0);position:absolute;box-sizing:border-box;height:100%;width:100%;margin:0;background:rgba(0,0,0,0);cursor:pointer;pointer-events:auto;appearance:none}input[type=range]:focus{outline:none}::-webkit-slider-runnable-track{-webkit-appearance:none}::-moz-range-track{appearance:none}::-webkit-slider-thumb{-webkit-appearance:none;appearance:none;block-size:var(--_handle-height);inline-size:var(--_handle-width);opacity:0;z-index:2}input.end::-webkit-slider-thumb{--_track-and-knob-padding: calc( (var(--_state-layer-size) - var(--_handle-width)) / 2 );--_x-translate: calc( var(--_track-and-knob-padding) - 2 * var(--_end-fraction) * var(--_track-and-knob-padding) );transform:translateX(var(--_x-translate))}input.end:dir(rtl)::-webkit-slider-thumb{transform:translateX(calc(-1 * var(--_x-translate)))}input.start::-webkit-slider-thumb{--_track-and-knob-padding: calc( (var(--_state-layer-size) - var(--_handle-width)) / 2 );--_x-translate: calc( var(--_track-and-knob-padding) - 2 * var(--_start-fraction) * var(--_track-and-knob-padding) );transform:translateX(var(--_x-translate))}input.start:dir(rtl)::-webkit-slider-thumb{transform:translateX(calc(-1 * var(--_x-translate)))}::-moz-range-thumb{appearance:none;block-size:var(--_state-layer-size);inline-size:var(--_state-layer-size);transform:scaleX(0);opacity:0;z-index:2}.ranged input.start{clip-path:inset(0 calc(100% - (var(--_state-layer-size) / 2 + (100% - var(--_state-layer-size)) * (var(--_start-fraction) + (var(--_end-fraction) - var(--_start-fraction)) / 2))) 0 0)}.ranged input.start:dir(rtl){clip-path:inset(0 0 0 calc(100% - (var(--_state-layer-size) / 2 + (100% - var(--_state-layer-size)) * (var(--_start-fraction) + (var(--_end-fraction) - var(--_start-fraction)) / 2))))}.ranged input.end{clip-path:inset(0 0 0 calc(var(--_state-layer-size) / 2 + (100% - var(--_state-layer-size)) * (var(--_start-fraction) + (var(--_end-fraction) - var(--_start-fraction)) / 2)))}.ranged input.end:dir(rtl){clip-path:inset(0 calc(var(--_state-layer-size) / 2 + (100% - var(--_state-layer-size)) * (var(--_start-fraction) + (var(--_end-fraction) - var(--_start-fraction)) / 2)) 0 0)}.onTop{z-index:1}.handle{--md-ripple-hover-color: var(--_hover-state-layer-color);--md-ripple-hover-opacity: var(--_hover-state-layer-opacity);--md-ripple-pressed-color: var(--_pressed-state-layer-color);--md-ripple-pressed-opacity: var(--_pressed-state-layer-opacity)}md-ripple{border-radius:50%;height:var(--_state-layer-size);width:var(--_state-layer-size)}
`;
//# sourceMappingURL=slider-styles.js.map
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\@material\web\slider\internal\slider-styles.js.map
================================================================================

{"version":3,"file":"slider-styles.js","sourceRoot":"","sources":["slider-styles.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AACH,gEAAgE;AAChE,OAAO,EAAC,GAAG,EAAC,MAAM,KAAK,CAAC;AACxB,MAAM,CAAC,MAAM,MAAM,GAAG,GAAG,CAAA;CACxB,CAAC","sourcesContent":["/**\n * @license\n * Copyright 2024 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n// Generated stylesheet for ./slider/internal/slider-styles.css.\nimport {css} from 'lit';\nexport const styles = css`:host{--_active-track-color: var(--md-slider-active-track-color, var(--md-sys-color-primary, #6750a4));--_active-track-height: var(--md-slider-active-track-height, 4px);--_active-track-shape: var(--md-slider-active-track-shape, var(--md-sys-shape-corner-full, 9999px));--_disabled-active-track-color: var(--md-slider-disabled-active-track-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-active-track-opacity: var(--md-slider-disabled-active-track-opacity, 0.38);--_disabled-handle-color: var(--md-slider-disabled-handle-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-handle-elevation: var(--md-slider-disabled-handle-elevation, 0);--_disabled-inactive-track-color: var(--md-slider-disabled-inactive-track-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-inactive-track-opacity: var(--md-slider-disabled-inactive-track-opacity, 0.12);--_focus-handle-color: var(--md-slider-focus-handle-color, var(--md-sys-color-primary, #6750a4));--_handle-color: var(--md-slider-handle-color, var(--md-sys-color-primary, #6750a4));--_handle-elevation: var(--md-slider-handle-elevation, 1);--_handle-height: var(--md-slider-handle-height, 20px);--_handle-shadow-color: var(--md-slider-handle-shadow-color, var(--md-sys-color-shadow, #000));--_handle-shape: var(--md-slider-handle-shape, var(--md-sys-shape-corner-full, 9999px));--_handle-width: var(--md-slider-handle-width, 20px);--_hover-handle-color: var(--md-slider-hover-handle-color, var(--md-sys-color-primary, #6750a4));--_hover-state-layer-color: var(--md-slider-hover-state-layer-color, var(--md-sys-color-primary, #6750a4));--_hover-state-layer-opacity: var(--md-slider-hover-state-layer-opacity, 0.08);--_inactive-track-color: var(--md-slider-inactive-track-color, var(--md-sys-color-surface-container-highest, #e6e0e9));--_inactive-track-height: var(--md-slider-inactive-track-height, 4px);--_inactive-track-shape: var(--md-slider-inactive-track-shape, var(--md-sys-shape-corner-full, 9999px));--_label-container-color: var(--md-slider-label-container-color, var(--md-sys-color-primary, #6750a4));--_label-container-height: var(--md-slider-label-container-height, 28px);--_pressed-handle-color: var(--md-slider-pressed-handle-color, var(--md-sys-color-primary, #6750a4));--_pressed-state-layer-color: var(--md-slider-pressed-state-layer-color, var(--md-sys-color-primary, #6750a4));--_pressed-state-layer-opacity: var(--md-slider-pressed-state-layer-opacity, 0.12);--_state-layer-size: var(--md-slider-state-layer-size, 40px);--_with-overlap-handle-outline-color: var(--md-slider-with-overlap-handle-outline-color, var(--md-sys-color-on-primary, #fff));--_with-overlap-handle-outline-width: var(--md-slider-with-overlap-handle-outline-width, 1px);--_with-tick-marks-active-container-color: var(--md-slider-with-tick-marks-active-container-color, var(--md-sys-color-on-primary, #fff));--_with-tick-marks-container-size: var(--md-slider-with-tick-marks-container-size, 2px);--_with-tick-marks-disabled-container-color: var(--md-slider-with-tick-marks-disabled-container-color, var(--md-sys-color-on-surface, #1d1b20));--_with-tick-marks-inactive-container-color: var(--md-slider-with-tick-marks-inactive-container-color, var(--md-sys-color-on-surface-variant, #49454f));--_label-text-color: var(--md-slider-label-text-color, var(--md-sys-color-on-primary, #fff));--_label-text-font: var(--md-slider-label-text-font, var(--md-sys-typescale-label-medium-font, var(--md-ref-typeface-plain, Roboto)));--_label-text-line-height: var(--md-slider-label-text-line-height, var(--md-sys-typescale-label-medium-line-height, 1rem));--_label-text-size: var(--md-slider-label-text-size, var(--md-sys-typescale-label-medium-size, 0.75rem));--_label-text-weight: var(--md-slider-label-text-weight, var(--md-sys-typescale-label-medium-weight, var(--md-ref-typeface-weight-medium, 500)));--_start-fraction: 0;--_end-fraction: 0;--_tick-count: 0;display:inline-flex;vertical-align:middle;min-inline-size:200px;--md-elevation-level: var(--_handle-elevation);--md-elevation-shadow-color: var(--_handle-shadow-color)}md-focus-ring{height:48px;inset:unset;width:48px}md-elevation{transition-duration:250ms}@media(prefers-reduced-motion){.label{transition-duration:0}}:host([disabled]){opacity:var(--_disabled-active-track-opacity);--md-elevation-level: var(--_disabled-handle-elevation)}.container{flex:1;display:flex;align-items:center;position:relative;block-size:var(--_state-layer-size);pointer-events:none;touch-action:none}.track,.tickmarks{position:absolute;inset:0;display:flex;align-items:center}.track::before,.tickmarks::before,.track::after,.tickmarks::after{position:absolute;content:\"\";inset-inline-start:calc(var(--_state-layer-size)/2 - var(--_with-tick-marks-container-size));inset-inline-end:calc(var(--_state-layer-size)/2 - var(--_with-tick-marks-container-size));background-size:calc((100% - var(--_with-tick-marks-container-size)*2)/var(--_tick-count)) 100%}.track::before,.tickmarks::before{block-size:var(--_inactive-track-height);border-radius:var(--_inactive-track-shape)}.track::before{background:var(--_inactive-track-color)}.tickmarks::before{background-image:radial-gradient(circle at var(--_with-tick-marks-container-size) center, var(--_with-tick-marks-inactive-container-color) 0, var(--_with-tick-marks-inactive-container-color) calc(var(--_with-tick-marks-container-size) / 2), transparent calc(var(--_with-tick-marks-container-size) / 2))}:host([disabled]) .track::before{opacity:calc(1/var(--_disabled-active-track-opacity)*var(--_disabled-inactive-track-opacity));background:var(--_disabled-inactive-track-color)}.track::after,.tickmarks::after{block-size:var(--_active-track-height);border-radius:var(--_active-track-shape);clip-path:inset(0 calc(var(--_with-tick-marks-container-size) * min((1 - var(--_end-fraction)) * 1000000000, 1) + (100% - var(--_with-tick-marks-container-size) * 2) * (1 - var(--_end-fraction))) 0 calc(var(--_with-tick-marks-container-size) * min(var(--_start-fraction) * 1000000000, 1) + (100% - var(--_with-tick-marks-container-size) * 2) * var(--_start-fraction)))}.track::after{background:var(--_active-track-color)}.tickmarks::after{background-image:radial-gradient(circle at var(--_with-tick-marks-container-size) center, var(--_with-tick-marks-active-container-color) 0, var(--_with-tick-marks-active-container-color) calc(var(--_with-tick-marks-container-size) / 2), transparent calc(var(--_with-tick-marks-container-size) / 2))}.track:dir(rtl)::after{clip-path:inset(0 calc(var(--_with-tick-marks-container-size) * min(var(--_start-fraction) * 1000000000, 1) + (100% - var(--_with-tick-marks-container-size) * 2) * var(--_start-fraction)) 0 calc(var(--_with-tick-marks-container-size) * min((1 - var(--_end-fraction)) * 1000000000, 1) + (100% - var(--_with-tick-marks-container-size) * 2) * (1 - var(--_end-fraction))))}.tickmarks:dir(rtl)::after{clip-path:inset(0 calc(var(--_with-tick-marks-container-size) * min(var(--_start-fraction) * 1000000000, 1) + (100% - var(--_with-tick-marks-container-size) * 2) * var(--_start-fraction)) 0 calc(var(--_with-tick-marks-container-size) * min((1 - var(--_end-fraction)) * 1000000000, 1) + (100% - var(--_with-tick-marks-container-size) * 2) * (1 - var(--_end-fraction))))}:host([disabled]) .track::after{background:var(--_disabled-active-track-color)}:host([disabled]) .tickmarks::before{background-image:radial-gradient(circle at var(--_with-tick-marks-container-size) center, var(--_with-tick-marks-disabled-container-color) 0, var(--_with-tick-marks-disabled-container-color) calc(var(--_with-tick-marks-container-size) / 2), transparent calc(var(--_with-tick-marks-container-size) / 2))}.handleContainerPadded{position:relative;block-size:100%;inline-size:100%;padding-inline:calc(var(--_state-layer-size)/2)}.handleContainerBlock{position:relative;block-size:100%;inline-size:100%}.handleContainer{position:absolute;inset-block-start:0;inset-block-end:0;inset-inline-start:calc(100%*var(--_start-fraction));inline-size:calc(100%*(var(--_end-fraction) - var(--_start-fraction)))}.handle{position:absolute;block-size:var(--_state-layer-size);inline-size:var(--_state-layer-size);border-radius:var(--_handle-shape);display:flex;place-content:center;place-items:center}.handleNub{position:absolute;height:var(--_handle-height);width:var(--_handle-width);border-radius:var(--_handle-shape);background:var(--_handle-color)}:host([disabled]) .handleNub{background:var(--_disabled-handle-color)}input.end:focus~.handleContainerPadded .handle.end>.handleNub,input.start:focus~.handleContainerPadded .handle.start>.handleNub{background:var(--_focus-handle-color)}.container>.handleContainerPadded .handle.hover>.handleNub{background:var(--_hover-handle-color)}:host(:not([disabled])) input.end:active~.handleContainerPadded .handle.end>.handleNub,:host(:not([disabled])) input.start:active~.handleContainerPadded .handle.start>.handleNub{background:var(--_pressed-handle-color)}.onTop.isOverlapping .label,.onTop.isOverlapping .label::before{outline:var(--_with-overlap-handle-outline-color) solid var(--_with-overlap-handle-outline-width)}.onTop.isOverlapping .handleNub{border:var(--_with-overlap-handle-outline-color) solid var(--_with-overlap-handle-outline-width)}.handle.start{inset-inline-start:calc(0px - var(--_state-layer-size)/2)}.handle.end{inset-inline-end:calc(0px - var(--_state-layer-size)/2)}.label{position:absolute;box-sizing:border-box;display:flex;padding:4px;place-content:center;place-items:center;border-radius:var(--md-sys-shape-corner-full, 9999px);color:var(--_label-text-color);font-family:var(--_label-text-font);font-size:var(--_label-text-size);line-height:var(--_label-text-line-height);font-weight:var(--_label-text-weight);inset-block-end:100%;min-inline-size:var(--_label-container-height);min-block-size:var(--_label-container-height);background:var(--_label-container-color);transition:transform 100ms cubic-bezier(0.2, 0, 0, 1);transform-origin:center bottom;transform:scale(0)}:host(:focus-within) .label,.handleContainer.hover .label,:where(:has(input:active)) .label{transform:scale(1)}.label::before,.label::after{position:absolute;display:block;content:\"\";background:inherit}.label::before{inline-size:calc(var(--_label-container-height)/2);block-size:calc(var(--_label-container-height)/2);bottom:calc(var(--_label-container-height)/-10);transform:rotate(45deg)}.label::after{inset:0px;border-radius:inherit}.labelContent{z-index:1}input[type=range]{opacity:0;-webkit-tap-highlight-color:rgba(0,0,0,0);position:absolute;box-sizing:border-box;height:100%;width:100%;margin:0;background:rgba(0,0,0,0);cursor:pointer;pointer-events:auto;appearance:none}input[type=range]:focus{outline:none}::-webkit-slider-runnable-track{-webkit-appearance:none}::-moz-range-track{appearance:none}::-webkit-slider-thumb{-webkit-appearance:none;appearance:none;block-size:var(--_handle-height);inline-size:var(--_handle-width);opacity:0;z-index:2}input.end::-webkit-slider-thumb{--_track-and-knob-padding: calc( (var(--_state-layer-size) - var(--_handle-width)) / 2 );--_x-translate: calc( var(--_track-and-knob-padding) - 2 * var(--_end-fraction) * var(--_track-and-knob-padding) );transform:translateX(var(--_x-translate))}input.end:dir(rtl)::-webkit-slider-thumb{transform:translateX(calc(-1 * var(--_x-translate)))}input.start::-webkit-slider-thumb{--_track-and-knob-padding: calc( (var(--_state-layer-size) - var(--_handle-width)) / 2 );--_x-translate: calc( var(--_track-and-knob-padding) - 2 * var(--_start-fraction) * var(--_track-and-knob-padding) );transform:translateX(var(--_x-translate))}input.start:dir(rtl)::-webkit-slider-thumb{transform:translateX(calc(-1 * var(--_x-translate)))}::-moz-range-thumb{appearance:none;block-size:var(--_state-layer-size);inline-size:var(--_state-layer-size);transform:scaleX(0);opacity:0;z-index:2}.ranged input.start{clip-path:inset(0 calc(100% - (var(--_state-layer-size) / 2 + (100% - var(--_state-layer-size)) * (var(--_start-fraction) + (var(--_end-fraction) - var(--_start-fraction)) / 2))) 0 0)}.ranged input.start:dir(rtl){clip-path:inset(0 0 0 calc(100% - (var(--_state-layer-size) / 2 + (100% - var(--_state-layer-size)) * (var(--_start-fraction) + (var(--_end-fraction) - var(--_start-fraction)) / 2))))}.ranged input.end{clip-path:inset(0 0 0 calc(var(--_state-layer-size) / 2 + (100% - var(--_state-layer-size)) * (var(--_start-fraction) + (var(--_end-fraction) - var(--_start-fraction)) / 2)))}.ranged input.end:dir(rtl){clip-path:inset(0 calc(var(--_state-layer-size) / 2 + (100% - var(--_state-layer-size)) * (var(--_start-fraction) + (var(--_end-fraction) - var(--_start-fraction)) / 2)) 0 0)}.onTop{z-index:1}.handle{--md-ripple-hover-color: var(--_hover-state-layer-color);--md-ripple-hover-opacity: var(--_hover-state-layer-opacity);--md-ripple-pressed-color: var(--_pressed-state-layer-color);--md-ripple-pressed-opacity: var(--_pressed-state-layer-opacity)}md-ripple{border-radius:50%;height:var(--_state-layer-size);width:var(--_state-layer-size)}\n`;\n"]}
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\@material\web\slider\internal\slider-styles.scss
================================================================================

//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

@use './slider';

@include slider.styles;

================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\@material\web\slider\internal\slider.d.ts
================================================================================

/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
import '../../elevation/elevation.js';
import '../../focus/md-focus-ring.js';
import '../../ripple/ripple.js';
import { LitElement, PropertyValues } from 'lit';
import { getFormValue } from '../../labs/behaviors/form-associated.js';
declare const sliderBaseClass: import("../../labs/behaviors/mixin.js").MixinReturn<(abstract new (...args: any[]) => import("../../labs/behaviors/element-internals.js").WithElementInternals) & typeof LitElement & import("../../labs/behaviors/form-associated.js").FormAssociatedConstructor, import("../../labs/behaviors/form-associated.js").FormAssociated>;
/**
 * Slider component.
 *
 *
 * @fires change {Event} The native `change` event on
 * [`<input>`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/change_event)
 * --bubbles
 * @fires input {InputEvent} The native `input` event on
 * [`<input>`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/input_event)
 * --bubbles --composed
 */
export declare class Slider extends sliderBaseClass {
    /** @nocollapse */
    static shadowRootOptions: ShadowRootInit;
    /**
     * The slider minimum value
     */
    min: number;
    /**
     * The slider maximum value
     */
    max: number;
    /**
     * The slider value displayed when range is false.
     */
    value?: number;
    /**
     * The slider start value displayed when range is true.
     */
    valueStart?: number;
    /**
     * The slider end value displayed when range is true.
     */
    valueEnd?: number;
    /**
     * An optional label for the slider's value displayed when range is
     * false; if not set, the label is the value itself.
     */
    valueLabel: string;
    /**
     * An optional label for the slider's start value displayed when
     * range is true; if not set, the label is the valueStart itself.
     */
    valueLabelStart: string;
    /**
     * An optional label for the slider's end value displayed when
     * range is true; if not set, the label is the valueEnd itself.
     */
    valueLabelEnd: string;
    /**
     * Aria label for the slider's start handle displayed when
     * range is true.
     */
    ariaLabelStart: string;
    /**
     * Aria value text for the slider's start value displayed when
     * range is true.
     */
    ariaValueTextStart: string;
    /**
     * Aria label for the slider's end handle displayed when
     * range is true.
     */
    ariaLabelEnd: string;
    /**
     * Aria value text for the slider's end value displayed when
     * range is true.
     */
    ariaValueTextEnd: string;
    /**
     * The step between values.
     */
    step: number;
    /**
     * Whether or not to show tick marks.
     */
    ticks: boolean;
    /**
     * Whether or not to show a value label when activated.
     */
    labeled: boolean;
    /**
     * Whether or not to show a value range. When false, the slider displays
     * a slideable handle for the value property; when true, it displays
     * slideable handles for the valueStart and valueEnd properties.
     */
    range: boolean;
    /**
     * The HTML name to use in form submission for a range slider's starting
     * value. Use `name` instead if both the start and end values should use the
     * same name.
     */
    get nameStart(): string;
    set nameStart(name: string);
    /**
     * The HTML name to use in form submission for a range slider's ending value.
     * Use `name` instead if both the start and end values should use the same
     * name.
     */
    get nameEnd(): string;
    set nameEnd(name: string);
    private readonly inputStart;
    private readonly handleStart;
    private readonly rippleStart;
    private readonly inputEnd;
    private readonly handleEnd;
    private readonly rippleEnd;
    private handleStartHover;
    private handleEndHover;
    private startOnTop;
    private handlesOverlapping;
    private renderValueStart?;
    private renderValueEnd?;
    private get renderAriaLabelStart();
    private get renderAriaValueTextStart();
    private get renderAriaLabelEnd();
    private get renderAriaValueTextEnd();
    private ripplePointerId;
    private isRedispatchingEvent;
    private action?;
    constructor();
    focus(): void;
    protected willUpdate(changed: PropertyValues): void;
    protected updated(changed: PropertyValues): void;
    protected render(): import("lit-html").TemplateResult<1>;
    private renderTrack;
    private renderLabel;
    private renderHandle;
    private renderInput;
    private toggleRippleHover;
    private handleFocus;
    private startAction;
    private finishAction;
    private handleKeydown;
    private handleKeyup;
    private handleDown;
    private handleUp;
    /**
     * The move handler tracks handle hovering to facilitate proper ripple
     * behavior on the slider handle. This is needed because user interaction with
     * the native input is leveraged to position the handle. Because the separate
     * displayed handle element has pointer events disabled (to allow interaction
     * with the input) and the input's handle is a pseudo-element, neither can be
     * the ripple's interactive element. Therefore the input is the ripple's
     * interactive element and has a `ripple` directive; however the ripple
     * is gated on the handle being hovered. In addition, because the ripple
     * hover state is being specially handled, it must be triggered independent
     * of the directive. This is done based on the hover state when the
     * slider is updated.
     */
    private handleMove;
    private handleEnter;
    private handleLeave;
    private updateOnTop;
    private needsClamping;
    private isActionFlipped;
    private flipAction;
    private clampAction;
    private handleInput;
    private handleChange;
    disabled: boolean;
    name: string;
    [getFormValue](): string | FormData;
    formResetCallback(): void;
    formStateRestoreCallback(state: string | Array<[string, string]> | null): void;
}
export {};

================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\@material\web\slider\internal\slider.js
================================================================================

/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
import { __decorate } from "tslib";
import '../../elevation/elevation.js';
import '../../focus/md-focus-ring.js';
import '../../ripple/ripple.js';
import { html, isServer, LitElement, nothing } from 'lit';
import { property, query, queryAsync, state } from 'lit/decorators.js';
import { classMap } from 'lit/directives/class-map.js';
import { styleMap } from 'lit/directives/style-map.js';
import { when } from 'lit/directives/when.js';
import { requestUpdateOnAriaChange } from '../../internal/aria/delegate.js';
import { dispatchActivationClick, isActivationClick, } from '../../internal/events/form-label-activation.js';
import { redispatchEvent } from '../../internal/events/redispatch-event.js';
import { mixinElementInternals } from '../../labs/behaviors/element-internals.js';
import { getFormValue, mixinFormAssociated, } from '../../labs/behaviors/form-associated.js';
// Disable warning for classMap with destructuring
// tslint:disable:no-implicit-dictionary-conversion
// Separate variable needed for closure.
const sliderBaseClass = mixinFormAssociated(mixinElementInternals(LitElement));
/**
 * Slider component.
 *
 *
 * @fires change {Event} The native `change` event on
 * [`<input>`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/change_event)
 * --bubbles
 * @fires input {InputEvent} The native `input` event on
 * [`<input>`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/input_event)
 * --bubbles --composed
 */
export class Slider extends sliderBaseClass {
    /**
     * The HTML name to use in form submission for a range slider's starting
     * value. Use `name` instead if both the start and end values should use the
     * same name.
     */
    get nameStart() {
        return this.getAttribute('name-start') ?? this.name;
    }
    set nameStart(name) {
        this.setAttribute('name-start', name);
    }
    /**
     * The HTML name to use in form submission for a range slider's ending value.
     * Use `name` instead if both the start and end values should use the same
     * name.
     */
    get nameEnd() {
        return this.getAttribute('name-end') ?? this.nameStart;
    }
    set nameEnd(name) {
        this.setAttribute('name-end', name);
    }
    // Note: start aria-* properties are only applied when range=true, which is
    // why they do not need to handle both cases.
    get renderAriaLabelStart() {
        // Needed for closure conformance
        const { ariaLabel } = this;
        return (this.ariaLabelStart ||
            (ariaLabel && `${ariaLabel} start`) ||
            this.valueLabelStart ||
            String(this.valueStart));
    }
    get renderAriaValueTextStart() {
        return (this.ariaValueTextStart || this.valueLabelStart || String(this.valueStart));
    }
    // Note: end aria-* properties are applied for single and range sliders, which
    // is why it needs to handle `this.range` (while start aria-* properties do
    // not).
    get renderAriaLabelEnd() {
        // Needed for closure conformance
        const { ariaLabel } = this;
        if (this.range) {
            return (this.ariaLabelEnd ||
                (ariaLabel && `${ariaLabel} end`) ||
                this.valueLabelEnd ||
                String(this.valueEnd));
        }
        return ariaLabel || this.valueLabel || String(this.value);
    }
    get renderAriaValueTextEnd() {
        if (this.range) {
            return (this.ariaValueTextEnd || this.valueLabelEnd || String(this.valueEnd));
        }
        // Needed for conformance
        const { ariaValueText } = this;
        return ariaValueText || this.valueLabel || String(this.value);
    }
    constructor() {
        super();
        /**
         * The slider minimum value
         */
        this.min = 0;
        /**
         * The slider maximum value
         */
        this.max = 100;
        /**
         * An optional label for the slider's value displayed when range is
         * false; if not set, the label is the value itself.
         */
        this.valueLabel = '';
        /**
         * An optional label for the slider's start value displayed when
         * range is true; if not set, the label is the valueStart itself.
         */
        this.valueLabelStart = '';
        /**
         * An optional label for the slider's end value displayed when
         * range is true; if not set, the label is the valueEnd itself.
         */
        this.valueLabelEnd = '';
        /**
         * Aria label for the slider's start handle displayed when
         * range is true.
         */
        this.ariaLabelStart = '';
        /**
         * Aria value text for the slider's start value displayed when
         * range is true.
         */
        this.ariaValueTextStart = '';
        /**
         * Aria label for the slider's end handle displayed when
         * range is true.
         */
        this.ariaLabelEnd = '';
        /**
         * Aria value text for the slider's end value displayed when
         * range is true.
         */
        this.ariaValueTextEnd = '';
        /**
         * The step between values.
         */
        this.step = 1;
        /**
         * Whether or not to show tick marks.
         */
        this.ticks = false;
        /**
         * Whether or not to show a value label when activated.
         */
        this.labeled = false;
        /**
         * Whether or not to show a value range. When false, the slider displays
         * a slideable handle for the value property; when true, it displays
         * slideable handles for the valueStart and valueEnd properties.
         */
        this.range = false;
        // handle hover/pressed states are set manually since the handle
        // does not receive pointer events so that the native inputs are
        // interaction targets.
        this.handleStartHover = false;
        this.handleEndHover = false;
        this.startOnTop = false;
        this.handlesOverlapping = false;
        // used in synthetic events generated to control ripple hover state.
        this.ripplePointerId = 1;
        // flag to prevent processing of re-dispatched input event.
        this.isRedispatchingEvent = false;
        if (!isServer) {
            this.addEventListener('click', (event) => {
                if (!isActivationClick(event) || !this.inputEnd) {
                    return;
                }
                this.focus();
                dispatchActivationClick(this.inputEnd);
            });
        }
    }
    focus() {
        this.inputEnd?.focus();
    }
    willUpdate(changed) {
        this.renderValueStart = changed.has('valueStart')
            ? this.valueStart
            : this.inputStart?.valueAsNumber;
        const endValueChanged = (changed.has('valueEnd') && this.range) || changed.has('value');
        this.renderValueEnd = endValueChanged
            ? this.range
                ? this.valueEnd
                : this.value
            : this.inputEnd?.valueAsNumber;
        // manually handle ripple hover state since the handle is pointer events
        // none.
        if (changed.get('handleStartHover') !== undefined) {
            this.toggleRippleHover(this.rippleStart, this.handleStartHover);
        }
        else if (changed.get('handleEndHover') !== undefined) {
            this.toggleRippleHover(this.rippleEnd, this.handleEndHover);
        }
    }
    updated(changed) {
        // Validate input rendered value and re-render if necessary. This ensures
        // the rendred handle stays in sync with the input thumb which is used for
        // interaction. These can get out of sync if a supplied value does not
        // map to an exactly stepped value between min and max.
        if (this.range) {
            this.renderValueStart = this.inputStart.valueAsNumber;
        }
        this.renderValueEnd = this.inputEnd.valueAsNumber;
        // update values if they are unset
        // when using a range, default to equi-distant between
        // min - valueStart - valueEnd - max
        if (this.range) {
            const segment = (this.max - this.min) / 3;
            if (this.valueStart === undefined) {
                this.inputStart.valueAsNumber = this.min + segment;
                // read actual value from input
                const v = this.inputStart.valueAsNumber;
                this.valueStart = this.renderValueStart = v;
            }
            if (this.valueEnd === undefined) {
                this.inputEnd.valueAsNumber = this.min + 2 * segment;
                // read actual value from input
                const v = this.inputEnd.valueAsNumber;
                this.valueEnd = this.renderValueEnd = v;
            }
        }
        else {
            this.value ?? (this.value = this.renderValueEnd);
        }
        if (changed.has('range') ||
            changed.has('renderValueStart') ||
            changed.has('renderValueEnd') ||
            this.isUpdatePending) {
            // Only check if the handle nubs are overlapping, as the ripple touch
            // target extends subtantially beyond the boundary of the handle nub.
            const startNub = this.handleStart?.querySelector('.handleNub');
            const endNub = this.handleEnd?.querySelector('.handleNub');
            this.handlesOverlapping = isOverlapping(startNub, endNub);
        }
        // called to finish the update imediately;
        // note, this is a no-op unless an update is scheduled
        this.performUpdate();
    }
    render() {
        const step = this.step === 0 ? 1 : this.step;
        const range = Math.max(this.max - this.min, step);
        const startFraction = this.range
            ? ((this.renderValueStart ?? this.min) - this.min) / range
            : 0;
        const endFraction = ((this.renderValueEnd ?? this.min) - this.min) / range;
        const containerStyles = {
            // for clipping inputs and active track.
            '--_start-fraction': String(startFraction),
            '--_end-fraction': String(endFraction),
            // for generating tick marks
            '--_tick-count': String(range / step),
        };
        const containerClasses = { ranged: this.range };
        // optional label values to show in place of the value.
        const labelStart = this.valueLabelStart || String(this.renderValueStart);
        const labelEnd = (this.range ? this.valueLabelEnd : this.valueLabel) ||
            String(this.renderValueEnd);
        const inputStartProps = {
            start: true,
            value: this.renderValueStart,
            ariaLabel: this.renderAriaLabelStart,
            ariaValueText: this.renderAriaValueTextStart,
            ariaMin: this.min,
            ariaMax: this.valueEnd ?? this.max,
        };
        const inputEndProps = {
            start: false,
            value: this.renderValueEnd,
            ariaLabel: this.renderAriaLabelEnd,
            ariaValueText: this.renderAriaValueTextEnd,
            ariaMin: this.range ? this.valueStart ?? this.min : this.min,
            ariaMax: this.max,
        };
        const handleStartProps = {
            start: true,
            hover: this.handleStartHover,
            label: labelStart,
        };
        const handleEndProps = {
            start: false,
            hover: this.handleEndHover,
            label: labelEnd,
        };
        const handleContainerClasses = {
            hover: this.handleStartHover || this.handleEndHover,
        };
        return html ` <div
      class="container ${classMap(containerClasses)}"
      style=${styleMap(containerStyles)}>
      ${when(this.range, () => this.renderInput(inputStartProps))}
      ${this.renderInput(inputEndProps)} ${this.renderTrack()}
      <div class="handleContainerPadded">
        <div class="handleContainerBlock">
          <div class="handleContainer ${classMap(handleContainerClasses)}">
            ${when(this.range, () => this.renderHandle(handleStartProps))}
            ${this.renderHandle(handleEndProps)}
          </div>
        </div>
      </div>
    </div>`;
    }
    renderTrack() {
        return html `
      <div class="track"></div>
      ${this.ticks ? html `<div class="tickmarks"></div>` : nothing}
    `;
    }
    renderLabel(value) {
        return html `<div class="label" aria-hidden="true">
      <span class="labelContent" part="label">${value}</span>
    </div>`;
    }
    renderHandle({ start, hover, label, }) {
        const onTop = !this.disabled && start === this.startOnTop;
        const isOverlapping = !this.disabled && this.handlesOverlapping;
        const name = start ? 'start' : 'end';
        return html `<div
      class="handle ${classMap({
            [name]: true,
            hover,
            onTop,
            isOverlapping,
        })}">
      <md-focus-ring part="focus-ring" for=${name}></md-focus-ring>
      <md-ripple
        for=${name}
        class=${name}
        ?disabled=${this.disabled}></md-ripple>
      <div class="handleNub">
        <md-elevation part="elevation"></md-elevation>
      </div>
      ${when(this.labeled, () => this.renderLabel(label))}
    </div>`;
    }
    renderInput({ start, value, ariaLabel, ariaValueText, ariaMin, ariaMax, }) {
        // Slider requires min/max set to the overall min/max for both inputs.
        // This is reported to screen readers, which is why we need aria-valuemin
        // and aria-valuemax.
        const name = start ? `start` : `end`;
        return html `<input
      type="range"
      class="${classMap({
            start,
            end: !start,
        })}"
      @focus=${this.handleFocus}
      @pointerdown=${this.handleDown}
      @pointerup=${this.handleUp}
      @pointerenter=${this.handleEnter}
      @pointermove=${this.handleMove}
      @pointerleave=${this.handleLeave}
      @keydown=${this.handleKeydown}
      @keyup=${this.handleKeyup}
      @input=${this.handleInput}
      @change=${this.handleChange}
      id=${name}
      .disabled=${this.disabled}
      .min=${String(this.min)}
      aria-valuemin=${ariaMin}
      .max=${String(this.max)}
      aria-valuemax=${ariaMax}
      .step=${String(this.step)}
      .value=${String(value)}
      .tabIndex=${start ? 1 : 0}
      aria-label=${ariaLabel || nothing}
      aria-valuetext=${ariaValueText} />`;
    }
    async toggleRippleHover(ripple, hovering) {
        const rippleEl = await ripple;
        if (!rippleEl) {
            return;
        }
        // TODO(b/269799771): improve slider ripple connection
        if (hovering) {
            rippleEl.handlePointerenter(new PointerEvent('pointerenter', {
                isPrimary: true,
                pointerId: this.ripplePointerId,
            }));
        }
        else {
            rippleEl.handlePointerleave(new PointerEvent('pointerleave', {
                isPrimary: true,
                pointerId: this.ripplePointerId,
            }));
        }
    }
    handleFocus(event) {
        this.updateOnTop(event.target);
    }
    startAction(event) {
        const target = event.target;
        const fixed = target === this.inputStart ? this.inputEnd : this.inputStart;
        this.action = {
            canFlip: event.type === 'pointerdown',
            flipped: false,
            target,
            fixed,
            values: new Map([
                [target, target.valueAsNumber],
                [fixed, fixed?.valueAsNumber],
            ]),
        };
    }
    finishAction(event) {
        this.action = undefined;
    }
    handleKeydown(event) {
        this.startAction(event);
    }
    handleKeyup(event) {
        this.finishAction(event);
    }
    handleDown(event) {
        this.startAction(event);
        this.ripplePointerId = event.pointerId;
        const isStart = event.target === this.inputStart;
        // Since handle moves to pointer on down and there may not be a move,
        // it needs to be considered hovered..
        this.handleStartHover =
            !this.disabled && isStart && Boolean(this.handleStart);
        this.handleEndHover = !this.disabled && !isStart && Boolean(this.handleEnd);
    }
    async handleUp(event) {
        if (!this.action) {
            return;
        }
        const { target, values, flipped } = this.action;
        //  Async here for Firefox because input can be after pointerup
        //  when value is calmped.
        await new Promise(requestAnimationFrame);
        if (target !== undefined) {
            // Ensure Safari focuses input so label renders.
            // Ensure any flipped input is focused so the tab order is right.
            target.focus();
            // When action is flipped, change must be fired manually since the
            // real event target did not change.
            if (flipped && target.valueAsNumber !== values.get(target)) {
                target.dispatchEvent(new Event('change', { bubbles: true }));
            }
        }
        this.finishAction(event);
    }
    /**
     * The move handler tracks handle hovering to facilitate proper ripple
     * behavior on the slider handle. This is needed because user interaction with
     * the native input is leveraged to position the handle. Because the separate
     * displayed handle element has pointer events disabled (to allow interaction
     * with the input) and the input's handle is a pseudo-element, neither can be
     * the ripple's interactive element. Therefore the input is the ripple's
     * interactive element and has a `ripple` directive; however the ripple
     * is gated on the handle being hovered. In addition, because the ripple
     * hover state is being specially handled, it must be triggered independent
     * of the directive. This is done based on the hover state when the
     * slider is updated.
     */
    handleMove(event) {
        this.handleStartHover = !this.disabled && inBounds(event, this.handleStart);
        this.handleEndHover = !this.disabled && inBounds(event, this.handleEnd);
    }
    handleEnter(event) {
        this.handleMove(event);
    }
    handleLeave() {
        this.handleStartHover = false;
        this.handleEndHover = false;
    }
    updateOnTop(input) {
        this.startOnTop = input.classList.contains('start');
    }
    needsClamping() {
        if (!this.action) {
            return false;
        }
        const { target, fixed } = this.action;
        const isStart = target === this.inputStart;
        return isStart
            ? target.valueAsNumber > fixed.valueAsNumber
            : target.valueAsNumber < fixed.valueAsNumber;
    }
    // if start/end start coincident and the first drag input would e.g. move
    // start > end, avoid clamping and "flip" to use the other input
    // as the action target.
    isActionFlipped() {
        const { action } = this;
        if (!action) {
            return false;
        }
        const { target, fixed, values } = action;
        if (action.canFlip) {
            const coincident = values.get(target) === values.get(fixed);
            if (coincident && this.needsClamping()) {
                action.canFlip = false;
                action.flipped = true;
                action.target = fixed;
                action.fixed = target;
            }
        }
        return action.flipped;
    }
    // when flipped, apply the drag input to the flipped target and reset
    // the actual target.
    flipAction() {
        if (!this.action) {
            return false;
        }
        const { target, fixed, values } = this.action;
        const changed = target.valueAsNumber !== fixed.valueAsNumber;
        target.valueAsNumber = fixed.valueAsNumber;
        fixed.valueAsNumber = values.get(fixed);
        return changed;
    }
    // clamp such that start does not move beyond end and visa versa.
    clampAction() {
        if (!this.needsClamping() || !this.action) {
            return false;
        }
        const { target, fixed } = this.action;
        target.valueAsNumber = fixed.valueAsNumber;
        return true;
    }
    handleInput(event) {
        // avoid processing a re-dispatched event
        if (this.isRedispatchingEvent) {
            return;
        }
        let stopPropagation = false;
        let redispatch = false;
        if (this.range) {
            if (this.isActionFlipped()) {
                stopPropagation = true;
                redispatch = this.flipAction();
            }
            if (this.clampAction()) {
                stopPropagation = true;
                redispatch = false;
            }
        }
        const target = event.target;
        this.updateOnTop(target);
        // update value only on interaction
        if (this.range) {
            this.valueStart = this.inputStart.valueAsNumber;
            this.valueEnd = this.inputEnd.valueAsNumber;
        }
        else {
            this.value = this.inputEnd.valueAsNumber;
        }
        // control external visibility of input event
        if (stopPropagation) {
            event.stopPropagation();
        }
        // ensure event path is correct when flipped.
        if (redispatch) {
            this.isRedispatchingEvent = true;
            redispatchEvent(target, event);
            this.isRedispatchingEvent = false;
        }
    }
    handleChange(event) {
        // prevent keyboard triggered changes from dispatching for
        // clamped values; note, this only occurs for keyboard
        const changeTarget = event.target;
        const { target, values } = this.action ?? {};
        const squelch = target && target.valueAsNumber === values.get(changeTarget);
        if (!squelch) {
            redispatchEvent(this, event);
        }
        // ensure keyboard triggered change clears action.
        this.finishAction(event);
    }
    [getFormValue]() {
        if (this.range) {
            const data = new FormData();
            data.append(this.nameStart, String(this.valueStart));
            data.append(this.nameEnd, String(this.valueEnd));
            return data;
        }
        return String(this.value);
    }
    formResetCallback() {
        if (this.range) {
            const valueStart = this.getAttribute('value-start');
            this.valueStart = valueStart !== null ? Number(valueStart) : undefined;
            const valueEnd = this.getAttribute('value-end');
            this.valueEnd = valueEnd !== null ? Number(valueEnd) : undefined;
            return;
        }
        const value = this.getAttribute('value');
        this.value = value !== null ? Number(value) : undefined;
    }
    formStateRestoreCallback(state) {
        if (Array.isArray(state)) {
            const [[, valueStart], [, valueEnd]] = state;
            this.valueStart = Number(valueStart);
            this.valueEnd = Number(valueEnd);
            this.range = true;
            return;
        }
        this.value = Number(state);
        this.range = false;
    }
}
(() => {
    requestUpdateOnAriaChange(Slider);
})();
/** @nocollapse */
Slider.shadowRootOptions = {
    ...LitElement.shadowRootOptions,
    delegatesFocus: true,
};
__decorate([
    property({ type: Number })
], Slider.prototype, "min", void 0);
__decorate([
    property({ type: Number })
], Slider.prototype, "max", void 0);
__decorate([
    property({ type: Number })
], Slider.prototype, "value", void 0);
__decorate([
    property({ type: Number, attribute: 'value-start' })
], Slider.prototype, "valueStart", void 0);
__decorate([
    property({ type: Number, attribute: 'value-end' })
], Slider.prototype, "valueEnd", void 0);
__decorate([
    property({ attribute: 'value-label' })
], Slider.prototype, "valueLabel", void 0);
__decorate([
    property({ attribute: 'value-label-start' })
], Slider.prototype, "valueLabelStart", void 0);
__decorate([
    property({ attribute: 'value-label-end' })
], Slider.prototype, "valueLabelEnd", void 0);
__decorate([
    property({ attribute: 'aria-label-start' })
], Slider.prototype, "ariaLabelStart", void 0);
__decorate([
    property({ attribute: 'aria-valuetext-start' })
], Slider.prototype, "ariaValueTextStart", void 0);
__decorate([
    property({ attribute: 'aria-label-end' })
], Slider.prototype, "ariaLabelEnd", void 0);
__decorate([
    property({ attribute: 'aria-valuetext-end' })
], Slider.prototype, "ariaValueTextEnd", void 0);
__decorate([
    property({ type: Number })
], Slider.prototype, "step", void 0);
__decorate([
    property({ type: Boolean })
], Slider.prototype, "ticks", void 0);
__decorate([
    property({ type: Boolean })
], Slider.prototype, "labeled", void 0);
__decorate([
    property({ type: Boolean })
], Slider.prototype, "range", void 0);
__decorate([
    query('input.start')
], Slider.prototype, "inputStart", void 0);
__decorate([
    query('.handle.start')
], Slider.prototype, "handleStart", void 0);
__decorate([
    queryAsync('md-ripple.start')
], Slider.prototype, "rippleStart", void 0);
__decorate([
    query('input.end')
], Slider.prototype, "inputEnd", void 0);
__decorate([
    query('.handle.end')
], Slider.prototype, "handleEnd", void 0);
__decorate([
    queryAsync('md-ripple.end')
], Slider.prototype, "rippleEnd", void 0);
__decorate([
    state()
], Slider.prototype, "handleStartHover", void 0);
__decorate([
    state()
], Slider.prototype, "handleEndHover", void 0);
__decorate([
    state()
], Slider.prototype, "startOnTop", void 0);
__decorate([
    state()
], Slider.prototype, "handlesOverlapping", void 0);
__decorate([
    state()
], Slider.prototype, "renderValueStart", void 0);
__decorate([
    state()
], Slider.prototype, "renderValueEnd", void 0);
function inBounds({ x, y }, element) {
    if (!element) {
        return false;
    }
    const { top, left, bottom, right } = element.getBoundingClientRect();
    return x >= left && x <= right && y >= top && y <= bottom;
}
function isOverlapping(elA, elB) {
    if (!(elA && elB)) {
        return false;
    }
    const a = elA.getBoundingClientRect();
    const b = elB.getBoundingClientRect();
    return !(a.top > b.bottom ||
        a.right < b.left ||
        a.bottom < b.top ||
        a.left > b.right);
}
//# sourceMappingURL=slider.js.map
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\@material\web\slider\internal\slider.js.map
================================================================================

{"version":3,"file":"slider.js","sourceRoot":"","sources":["slider.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport '../../elevation/elevation.js';\nimport '../../focus/md-focus-ring.js';\nimport '../../ripple/ripple.js';\n\nimport {html, isServer, LitElement, nothing, PropertyValues} from 'lit';\nimport {property, query, queryAsync, state} from 'lit/decorators.js';\nimport {classMap} from 'lit/directives/class-map.js';\nimport {styleMap} from 'lit/directives/style-map.js';\nimport {when} from 'lit/directives/when.js';\n\nimport {ARIAMixinStrict} from '../../internal/aria/aria.js';\nimport {requestUpdateOnAriaChange} from '../../internal/aria/delegate.js';\nimport {\n  dispatchActivationClick,\n  isActivationClick,\n} from '../../internal/events/form-label-activation.js';\nimport {redispatchEvent} from '../../internal/events/redispatch-event.js';\nimport {mixinElementInternals} from '../../labs/behaviors/element-internals.js';\nimport {\n  getFormValue,\n  mixinFormAssociated,\n} from '../../labs/behaviors/form-associated.js';\nimport {MdRipple} from '../../ripple/ripple.js';\n\n// Disable warning for classMap with destructuring\n// tslint:disable:no-implicit-dictionary-conversion\n\n// Separate variable needed for closure.\nconst sliderBaseClass = mixinFormAssociated(mixinElementInternals(LitElement));\n\n/**\n * Slider component.\n *\n *\n * @fires change {Event} The native `change` event on\n * [`<input>`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/change_event)\n * --bubbles\n * @fires input {InputEvent} The native `input` event on\n * [`<input>`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/input_event)\n * --bubbles --composed\n */\nexport class Slider extends sliderBaseClass {\n  static {\n    requestUpdateOnAriaChange(Slider);\n  }\n\n  /** @nocollapse */\n  static override shadowRootOptions: ShadowRootInit = {\n    ...LitElement.shadowRootOptions,\n    delegatesFocus: true,\n  };\n\n  /**\n   * The slider minimum value\n   */\n  @property({type: Number}) min = 0;\n\n  /**\n   * The slider maximum value\n   */\n  @property({type: Number}) max = 100;\n\n  /**\n   * The slider value displayed when range is false.\n   */\n  @property({type: Number}) value?: number;\n\n  /**\n   * The slider start value displayed when range is true.\n   */\n  @property({type: Number, attribute: 'value-start'}) valueStart?: number;\n\n  /**\n   * The slider end value displayed when range is true.\n   */\n  @property({type: Number, attribute: 'value-end'}) valueEnd?: number;\n\n  /**\n   * An optional label for the slider's value displayed when range is\n   * false; if not set, the label is the value itself.\n   */\n  @property({attribute: 'value-label'}) valueLabel = '';\n\n  /**\n   * An optional label for the slider's start value displayed when\n   * range is true; if not set, the label is the valueStart itself.\n   */\n  @property({attribute: 'value-label-start'}) valueLabelStart = '';\n\n  /**\n   * An optional label for the slider's end value displayed when\n   * range is true; if not set, the label is the valueEnd itself.\n   */\n  @property({attribute: 'value-label-end'}) valueLabelEnd = '';\n\n  /**\n   * Aria label for the slider's start handle displayed when\n   * range is true.\n   */\n  @property({attribute: 'aria-label-start'}) ariaLabelStart = '';\n\n  /**\n   * Aria value text for the slider's start value displayed when\n   * range is true.\n   */\n  @property({attribute: 'aria-valuetext-start'}) ariaValueTextStart = '';\n\n  /**\n   * Aria label for the slider's end handle displayed when\n   * range is true.\n   */\n  @property({attribute: 'aria-label-end'}) ariaLabelEnd = '';\n\n  /**\n   * Aria value text for the slider's end value displayed when\n   * range is true.\n   */\n  @property({attribute: 'aria-valuetext-end'}) ariaValueTextEnd = '';\n\n  /**\n   * The step between values.\n   */\n  @property({type: Number}) step = 1;\n\n  /**\n   * Whether or not to show tick marks.\n   */\n  @property({type: Boolean}) ticks = false;\n\n  /**\n   * Whether or not to show a value label when activated.\n   */\n  @property({type: Boolean}) labeled = false;\n\n  /**\n   * Whether or not to show a value range. When false, the slider displays\n   * a slideable handle for the value property; when true, it displays\n   * slideable handles for the valueStart and valueEnd properties.\n   */\n  @property({type: Boolean}) range = false;\n\n  /**\n   * The HTML name to use in form submission for a range slider's starting\n   * value. Use `name` instead if both the start and end values should use the\n   * same name.\n   */\n  get nameStart() {\n    return this.getAttribute('name-start') ?? this.name;\n  }\n  set nameStart(name: string) {\n    this.setAttribute('name-start', name);\n  }\n\n  /**\n   * The HTML name to use in form submission for a range slider's ending value.\n   * Use `name` instead if both the start and end values should use the same\n   * name.\n   */\n  get nameEnd() {\n    return this.getAttribute('name-end') ?? this.nameStart;\n  }\n  set nameEnd(name: string) {\n    this.setAttribute('name-end', name);\n  }\n\n  @query('input.start') private readonly inputStart!: HTMLInputElement | null;\n  @query('.handle.start') private readonly handleStart!: HTMLDivElement | null;\n  @queryAsync('md-ripple.start')\n  private readonly rippleStart!: Promise<MdRipple | null>;\n\n  @query('input.end') private readonly inputEnd!: HTMLInputElement | null;\n  @query('.handle.end') private readonly handleEnd!: HTMLDivElement | null;\n  @queryAsync('md-ripple.end')\n  private readonly rippleEnd!: Promise<MdRipple | null>;\n\n  // handle hover/pressed states are set manually since the handle\n  // does not receive pointer events so that the native inputs are\n  // interaction targets.\n  @state() private handleStartHover = false;\n  @state() private handleEndHover = false;\n\n  @state() private startOnTop = false;\n  @state() private handlesOverlapping = false;\n\n  @state() private renderValueStart?: number;\n  @state() private renderValueEnd?: number;\n\n  // Note: start aria-* properties are only applied when range=true, which is\n  // why they do not need to handle both cases.\n  private get renderAriaLabelStart() {\n    // Needed for closure conformance\n    const {ariaLabel} = this as ARIAMixinStrict;\n    return (\n      this.ariaLabelStart ||\n      (ariaLabel && `${ariaLabel} start`) ||\n      this.valueLabelStart ||\n      String(this.valueStart)\n    );\n  }\n\n  private get renderAriaValueTextStart() {\n    return (\n      this.ariaValueTextStart || this.valueLabelStart || String(this.valueStart)\n    );\n  }\n\n  // Note: end aria-* properties are applied for single and range sliders, which\n  // is why it needs to handle `this.range` (while start aria-* properties do\n  // not).\n  private get renderAriaLabelEnd() {\n    // Needed for closure conformance\n    const {ariaLabel} = this as ARIAMixinStrict;\n    if (this.range) {\n      return (\n        this.ariaLabelEnd ||\n        (ariaLabel && `${ariaLabel} end`) ||\n        this.valueLabelEnd ||\n        String(this.valueEnd)\n      );\n    }\n\n    return ariaLabel || this.valueLabel || String(this.value);\n  }\n\n  private get renderAriaValueTextEnd() {\n    if (this.range) {\n      return (\n        this.ariaValueTextEnd || this.valueLabelEnd || String(this.valueEnd)\n      );\n    }\n\n    // Needed for conformance\n    const {ariaValueText} = this as ARIAMixinStrict;\n    return ariaValueText || this.valueLabel || String(this.value);\n  }\n\n  // used in synthetic events generated to control ripple hover state.\n  private ripplePointerId = 1;\n\n  // flag to prevent processing of re-dispatched input event.\n  private isRedispatchingEvent = false;\n\n  private action?: Action;\n\n  constructor() {\n    super();\n    if (!isServer) {\n      this.addEventListener('click', (event: MouseEvent) => {\n        if (!isActivationClick(event) || !this.inputEnd) {\n          return;\n        }\n        this.focus();\n        dispatchActivationClick(this.inputEnd);\n      });\n    }\n  }\n\n  override focus() {\n    this.inputEnd?.focus();\n  }\n\n  protected override willUpdate(changed: PropertyValues) {\n    this.renderValueStart = changed.has('valueStart')\n      ? this.valueStart\n      : this.inputStart?.valueAsNumber;\n    const endValueChanged =\n      (changed.has('valueEnd') && this.range) || changed.has('value');\n    this.renderValueEnd = endValueChanged\n      ? this.range\n        ? this.valueEnd\n        : this.value\n      : this.inputEnd?.valueAsNumber;\n    // manually handle ripple hover state since the handle is pointer events\n    // none.\n    if (changed.get('handleStartHover') !== undefined) {\n      this.toggleRippleHover(this.rippleStart, this.handleStartHover);\n    } else if (changed.get('handleEndHover') !== undefined) {\n      this.toggleRippleHover(this.rippleEnd, this.handleEndHover);\n    }\n  }\n\n  protected override updated(changed: PropertyValues) {\n    // Validate input rendered value and re-render if necessary. This ensures\n    // the rendred handle stays in sync with the input thumb which is used for\n    // interaction. These can get out of sync if a supplied value does not\n    // map to an exactly stepped value between min and max.\n    if (this.range) {\n      this.renderValueStart = this.inputStart!.valueAsNumber;\n    }\n    this.renderValueEnd = this.inputEnd!.valueAsNumber;\n    // update values if they are unset\n    // when using a range, default to equi-distant between\n    // min - valueStart - valueEnd - max\n    if (this.range) {\n      const segment = (this.max - this.min) / 3;\n      if (this.valueStart === undefined) {\n        this.inputStart!.valueAsNumber = this.min + segment;\n        // read actual value from input\n        const v = this.inputStart!.valueAsNumber;\n        this.valueStart = this.renderValueStart = v;\n      }\n      if (this.valueEnd === undefined) {\n        this.inputEnd!.valueAsNumber = this.min + 2 * segment;\n        // read actual value from input\n        const v = this.inputEnd!.valueAsNumber;\n        this.valueEnd = this.renderValueEnd = v;\n      }\n    } else {\n      this.value ??= this.renderValueEnd;\n    }\n    if (\n      changed.has('range') ||\n      changed.has('renderValueStart') ||\n      changed.has('renderValueEnd') ||\n      this.isUpdatePending\n    ) {\n      // Only check if the handle nubs are overlapping, as the ripple touch\n      // target extends subtantially beyond the boundary of the handle nub.\n      const startNub = this.handleStart?.querySelector('.handleNub');\n      const endNub = this.handleEnd?.querySelector('.handleNub');\n      this.handlesOverlapping = isOverlapping(startNub, endNub);\n    }\n    // called to finish the update imediately;\n    // note, this is a no-op unless an update is scheduled\n    this.performUpdate();\n  }\n\n  protected override render() {\n    const step = this.step === 0 ? 1 : this.step;\n    const range = Math.max(this.max - this.min, step);\n    const startFraction = this.range\n      ? ((this.renderValueStart ?? this.min) - this.min) / range\n      : 0;\n    const endFraction = ((this.renderValueEnd ?? this.min) - this.min) / range;\n    const containerStyles = {\n      // for clipping inputs and active track.\n      '--_start-fraction': String(startFraction),\n      '--_end-fraction': String(endFraction),\n      // for generating tick marks\n      '--_tick-count': String(range / step),\n    };\n    const containerClasses = {ranged: this.range};\n\n    // optional label values to show in place of the value.\n    const labelStart = this.valueLabelStart || String(this.renderValueStart);\n    const labelEnd =\n      (this.range ? this.valueLabelEnd : this.valueLabel) ||\n      String(this.renderValueEnd);\n\n    const inputStartProps = {\n      start: true,\n      value: this.renderValueStart,\n      ariaLabel: this.renderAriaLabelStart,\n      ariaValueText: this.renderAriaValueTextStart,\n      ariaMin: this.min,\n      ariaMax: this.valueEnd ?? this.max,\n    };\n\n    const inputEndProps = {\n      start: false,\n      value: this.renderValueEnd,\n      ariaLabel: this.renderAriaLabelEnd,\n      ariaValueText: this.renderAriaValueTextEnd,\n      ariaMin: this.range ? this.valueStart ?? this.min : this.min,\n      ariaMax: this.max,\n    };\n\n    const handleStartProps = {\n      start: true,\n      hover: this.handleStartHover,\n      label: labelStart,\n    };\n\n    const handleEndProps = {\n      start: false,\n      hover: this.handleEndHover,\n      label: labelEnd,\n    };\n\n    const handleContainerClasses = {\n      hover: this.handleStartHover || this.handleEndHover,\n    };\n\n    return html` <div\n      class=\"container ${classMap(containerClasses)}\"\n      style=${styleMap(containerStyles)}>\n      ${when(this.range, () => this.renderInput(inputStartProps))}\n      ${this.renderInput(inputEndProps)} ${this.renderTrack()}\n      <div class=\"handleContainerPadded\">\n        <div class=\"handleContainerBlock\">\n          <div class=\"handleContainer ${classMap(handleContainerClasses)}\">\n            ${when(this.range, () => this.renderHandle(handleStartProps))}\n            ${this.renderHandle(handleEndProps)}\n          </div>\n        </div>\n      </div>\n    </div>`;\n  }\n\n  private renderTrack() {\n    return html`\n      <div class=\"track\"></div>\n      ${this.ticks ? html`<div class=\"tickmarks\"></div>` : nothing}\n    `;\n  }\n\n  private renderLabel(value: string) {\n    return html`<div class=\"label\" aria-hidden=\"true\">\n      <span class=\"labelContent\" part=\"label\">${value}</span>\n    </div>`;\n  }\n\n  private renderHandle({\n    start,\n    hover,\n    label,\n  }: {\n    start: boolean;\n    hover: boolean;\n    label: string;\n  }) {\n    const onTop = !this.disabled && start === this.startOnTop;\n    const isOverlapping = !this.disabled && this.handlesOverlapping;\n    const name = start ? 'start' : 'end';\n    return html`<div\n      class=\"handle ${classMap({\n        [name]: true,\n        hover,\n        onTop,\n        isOverlapping,\n      })}\">\n      <md-focus-ring part=\"focus-ring\" for=${name}></md-focus-ring>\n      <md-ripple\n        for=${name}\n        class=${name}\n        ?disabled=${this.disabled}></md-ripple>\n      <div class=\"handleNub\">\n        <md-elevation part=\"elevation\"></md-elevation>\n      </div>\n      ${when(this.labeled, () => this.renderLabel(label))}\n    </div>`;\n  }\n\n  private renderInput({\n    start,\n    value,\n    ariaLabel,\n    ariaValueText,\n    ariaMin,\n    ariaMax,\n  }: {\n    start: boolean;\n    value?: number;\n    ariaLabel: string;\n    ariaValueText: string;\n    ariaMin: number;\n    ariaMax: number;\n  }) {\n    // Slider requires min/max set to the overall min/max for both inputs.\n    // This is reported to screen readers, which is why we need aria-valuemin\n    // and aria-valuemax.\n    const name = start ? `start` : `end`;\n    return html`<input\n      type=\"range\"\n      class=\"${classMap({\n        start,\n        end: !start,\n      })}\"\n      @focus=${this.handleFocus}\n      @pointerdown=${this.handleDown}\n      @pointerup=${this.handleUp}\n      @pointerenter=${this.handleEnter}\n      @pointermove=${this.handleMove}\n      @pointerleave=${this.handleLeave}\n      @keydown=${this.handleKeydown}\n      @keyup=${this.handleKeyup}\n      @input=${this.handleInput}\n      @change=${this.handleChange}\n      id=${name}\n      .disabled=${this.disabled}\n      .min=${String(this.min)}\n      aria-valuemin=${ariaMin}\n      .max=${String(this.max)}\n      aria-valuemax=${ariaMax}\n      .step=${String(this.step)}\n      .value=${String(value)}\n      .tabIndex=${start ? 1 : 0}\n      aria-label=${ariaLabel || nothing}\n      aria-valuetext=${ariaValueText} />`;\n  }\n\n  private async toggleRippleHover(\n    ripple: Promise<MdRipple | null>,\n    hovering: boolean,\n  ) {\n    const rippleEl = await ripple;\n    if (!rippleEl) {\n      return;\n    }\n    // TODO(b/269799771): improve slider ripple connection\n    if (hovering) {\n      rippleEl.handlePointerenter(\n        new PointerEvent('pointerenter', {\n          isPrimary: true,\n          pointerId: this.ripplePointerId,\n        }),\n      );\n    } else {\n      rippleEl.handlePointerleave(\n        new PointerEvent('pointerleave', {\n          isPrimary: true,\n          pointerId: this.ripplePointerId,\n        }),\n      );\n    }\n  }\n\n  private handleFocus(event: Event) {\n    this.updateOnTop(event.target as HTMLInputElement);\n  }\n\n  private startAction(event: Event) {\n    const target = event.target as HTMLInputElement;\n    const fixed =\n      target === this.inputStart ? this.inputEnd! : this.inputStart!;\n    this.action = {\n      canFlip: event.type === 'pointerdown',\n      flipped: false,\n      target,\n      fixed,\n      values: new Map([\n        [target, target.valueAsNumber],\n        [fixed, fixed?.valueAsNumber],\n      ]),\n    };\n  }\n\n  private finishAction(event: Event) {\n    this.action = undefined;\n  }\n\n  private handleKeydown(event: KeyboardEvent) {\n    this.startAction(event);\n  }\n\n  private handleKeyup(event: KeyboardEvent) {\n    this.finishAction(event);\n  }\n\n  private handleDown(event: PointerEvent) {\n    this.startAction(event);\n    this.ripplePointerId = event.pointerId;\n    const isStart = (event.target as HTMLInputElement) === this.inputStart;\n    // Since handle moves to pointer on down and there may not be a move,\n    // it needs to be considered hovered..\n    this.handleStartHover =\n      !this.disabled && isStart && Boolean(this.handleStart);\n    this.handleEndHover = !this.disabled && !isStart && Boolean(this.handleEnd);\n  }\n\n  private async handleUp(event: PointerEvent) {\n    if (!this.action) {\n      return;\n    }\n\n    const {target, values, flipped} = this.action;\n    //  Async here for Firefox because input can be after pointerup\n    //  when value is calmped.\n    await new Promise(requestAnimationFrame);\n    if (target !== undefined) {\n      // Ensure Safari focuses input so label renders.\n      // Ensure any flipped input is focused so the tab order is right.\n      target.focus();\n      // When action is flipped, change must be fired manually since the\n      // real event target did not change.\n      if (flipped && target.valueAsNumber !== values.get(target)!) {\n        target.dispatchEvent(new Event('change', {bubbles: true}));\n      }\n    }\n    this.finishAction(event);\n  }\n\n  /**\n   * The move handler tracks handle hovering to facilitate proper ripple\n   * behavior on the slider handle. This is needed because user interaction with\n   * the native input is leveraged to position the handle. Because the separate\n   * displayed handle element has pointer events disabled (to allow interaction\n   * with the input) and the input's handle is a pseudo-element, neither can be\n   * the ripple's interactive element. Therefore the input is the ripple's\n   * interactive element and has a `ripple` directive; however the ripple\n   * is gated on the handle being hovered. In addition, because the ripple\n   * hover state is being specially handled, it must be triggered independent\n   * of the directive. This is done based on the hover state when the\n   * slider is updated.\n   */\n  private handleMove(event: PointerEvent) {\n    this.handleStartHover = !this.disabled && inBounds(event, this.handleStart);\n    this.handleEndHover = !this.disabled && inBounds(event, this.handleEnd);\n  }\n\n  private handleEnter(event: PointerEvent) {\n    this.handleMove(event);\n  }\n\n  private handleLeave() {\n    this.handleStartHover = false;\n    this.handleEndHover = false;\n  }\n\n  private updateOnTop(input: HTMLInputElement) {\n    this.startOnTop = input.classList.contains('start');\n  }\n\n  private needsClamping() {\n    if (!this.action) {\n      return false;\n    }\n\n    const {target, fixed} = this.action;\n    const isStart = target === this.inputStart;\n    return isStart\n      ? target.valueAsNumber > fixed.valueAsNumber\n      : target.valueAsNumber < fixed.valueAsNumber;\n  }\n\n  // if start/end start coincident and the first drag input would e.g. move\n  // start > end, avoid clamping and \"flip\" to use the other input\n  // as the action target.\n  private isActionFlipped() {\n    const {action} = this;\n    if (!action) {\n      return false;\n    }\n\n    const {target, fixed, values} = action;\n    if (action.canFlip) {\n      const coincident = values.get(target) === values.get(fixed);\n      if (coincident && this.needsClamping()) {\n        action.canFlip = false;\n        action.flipped = true;\n        action.target = fixed;\n        action.fixed = target;\n      }\n    }\n    return action.flipped;\n  }\n\n  // when flipped, apply the drag input to the flipped target and reset\n  // the actual target.\n  private flipAction() {\n    if (!this.action) {\n      return false;\n    }\n\n    const {target, fixed, values} = this.action;\n    const changed = target.valueAsNumber !== fixed.valueAsNumber;\n    target.valueAsNumber = fixed.valueAsNumber;\n    fixed.valueAsNumber = values.get(fixed)!;\n    return changed;\n  }\n\n  // clamp such that start does not move beyond end and visa versa.\n  private clampAction() {\n    if (!this.needsClamping() || !this.action) {\n      return false;\n    }\n    const {target, fixed} = this.action;\n    target.valueAsNumber = fixed.valueAsNumber;\n    return true;\n  }\n\n  private handleInput(event: InputEvent) {\n    // avoid processing a re-dispatched event\n    if (this.isRedispatchingEvent) {\n      return;\n    }\n    let stopPropagation = false;\n    let redispatch = false;\n    if (this.range) {\n      if (this.isActionFlipped()) {\n        stopPropagation = true;\n        redispatch = this.flipAction();\n      }\n      if (this.clampAction()) {\n        stopPropagation = true;\n        redispatch = false;\n      }\n    }\n    const target = event.target as HTMLInputElement;\n    this.updateOnTop(target);\n    // update value only on interaction\n    if (this.range) {\n      this.valueStart = this.inputStart!.valueAsNumber;\n      this.valueEnd = this.inputEnd!.valueAsNumber;\n    } else {\n      this.value = this.inputEnd!.valueAsNumber;\n    }\n    // control external visibility of input event\n    if (stopPropagation) {\n      event.stopPropagation();\n    }\n    // ensure event path is correct when flipped.\n    if (redispatch) {\n      this.isRedispatchingEvent = true;\n      redispatchEvent(target, event);\n      this.isRedispatchingEvent = false;\n    }\n  }\n\n  private handleChange(event: Event) {\n    // prevent keyboard triggered changes from dispatching for\n    // clamped values; note, this only occurs for keyboard\n    const changeTarget = event.target as HTMLInputElement;\n    const {target, values} = this.action ?? {};\n    const squelch =\n      target && target.valueAsNumber === values!.get(changeTarget)!;\n    if (!squelch) {\n      redispatchEvent(this, event);\n    }\n    // ensure keyboard triggered change clears action.\n    this.finishAction(event);\n  }\n\n  // Writable mixin properties for lit-html binding, needed for lit-analyzer\n  declare disabled: boolean;\n  declare name: string;\n\n  override [getFormValue]() {\n    if (this.range) {\n      const data = new FormData();\n      data.append(this.nameStart, String(this.valueStart));\n      data.append(this.nameEnd, String(this.valueEnd));\n      return data;\n    }\n\n    return String(this.value);\n  }\n\n  override formResetCallback() {\n    if (this.range) {\n      const valueStart = this.getAttribute('value-start');\n      this.valueStart = valueStart !== null ? Number(valueStart) : undefined;\n      const valueEnd = this.getAttribute('value-end');\n      this.valueEnd = valueEnd !== null ? Number(valueEnd) : undefined;\n      return;\n    }\n    const value = this.getAttribute('value');\n    this.value = value !== null ? Number(value) : undefined;\n  }\n\n  override formStateRestoreCallback(\n    state: string | Array<[string, string]> | null,\n  ) {\n    if (Array.isArray(state)) {\n      const [[, valueStart], [, valueEnd]] = state;\n      this.valueStart = Number(valueStart);\n      this.valueEnd = Number(valueEnd);\n      this.range = true;\n      return;\n    }\n\n    this.value = Number(state);\n    this.range = false;\n  }\n}\n\nfunction inBounds({x, y}: PointerEvent, element?: HTMLElement | null) {\n  if (!element) {\n    return false;\n  }\n  const {top, left, bottom, right} = element.getBoundingClientRect();\n  return x >= left && x <= right && y >= top && y <= bottom;\n}\n\nfunction isOverlapping(\n  elA: Element | null | undefined,\n  elB: Element | null | undefined,\n) {\n  if (!(elA && elB)) {\n    return false;\n  }\n  const a = elA.getBoundingClientRect();\n  const b = elB.getBoundingClientRect();\n  return !(\n    a.top > b.bottom ||\n    a.right < b.left ||\n    a.bottom < b.top ||\n    a.left > b.right\n  );\n}\n\ninterface Action {\n  canFlip: boolean;\n  flipped: boolean;\n  target: HTMLInputElement;\n  fixed: HTMLInputElement;\n  values: Map<HTMLInputElement | undefined, number | undefined>;\n}\n"]}
================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\@material\web\slider\internal\_slider.scss
================================================================================

//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use 'sass:list';
@use 'sass:map';
// go/keep-sorted end
// go/keep-sorted start
@use '../../elevation/elevation';
@use '../../ripple/ripple';
@use '../../tokens';
// go/keep-sorted end

$_md-sys-motion: tokens.md-sys-motion-values();
$_md-sys-shape: tokens.md-sys-shape-values();

@mixin theme($tokens) {
  $supported-tokens: tokens.$md-comp-slider-supported-tokens;

  @each $token, $value in $tokens {
    @if list.index($supported-tokens, $token) == null {
      @error 'Token `#{$token}` is not a supported token.';
    }

    @if $value {
      --md-slider-#{$token}: #{$value};
    }
  }
}

@mixin styles() {
  $tokens: tokens.md-comp-slider-values(
    $exclude-custom-properties: false,
  );

  // The max clip is reduced by 1 full tick display which is 2x the container
  // size to account for always showing the active track on the outside
  // edge of the last tick.
  $_active-track-max-clip: calc(
    100% - var(--_with-tick-marks-container-size) * 2
  );
  // When the start fraction is !0, add clipping by the tick container size
  $_start-fraction-not-zero: min(var(--_start-fraction) * 1e9, 1);
  $_active-track-start-offset: calc(
    var(--_with-tick-marks-container-size) * $_start-fraction-not-zero
  );
  $_active-track-start-clip: calc(
    $_active-track-start-offset + $_active-track-max-clip *
      var(--_start-fraction)
  );

  // When the end fraction is !1, add clipping by the tick container size
  $_end-fraction-not-one: min((1 - var(--_end-fraction)) * 1e9, 1);
  $_active-track-end-offset: calc(
    var(--_with-tick-marks-container-size) * $_end-fraction-not-one
  );
  $_active-track-end-clip: calc(
    $_active-track-end-offset + $_active-track-max-clip *
      (1 - var(--_end-fraction))
  );

  :host {
    @each $token, $value in $tokens {
      --_#{$token}: #{$value};
    }

    // Set these to avoid token test failures
    --_start-fraction: 0;
    --_end-fraction: 0;
    --_tick-count: 0;

    display: inline-flex;
    vertical-align: middle;
    min-inline-size: 200px;

    @include elevation.theme(
      (
        level: var(--_handle-elevation),
        shadow-color: var(--_handle-shadow-color),
      )
    );
  }

  md-focus-ring {
    height: 48px;
    inset: unset;
    width: 48px;
  }

  md-elevation {
    transition-duration: map.get($_md-sys-motion, 'duration-medium1');
    transition-timing-function: map.get($_md-sys-motion, 'emphasized-easing');
  }

  @media (prefers-reduced-motion) {
    .label {
      transition-duration: 0;
    }
  }

  // Note, opacity for active track and handle controlled via host.
  // This avoids bleed through from the handle to the track since they overlap.
  // It also means the inactive track opacity is calc'd to compensate.
  :host([disabled]) {
    opacity: var(--_disabled-active-track-opacity);

    @include elevation.theme(
      (
        level: var(--_disabled-handle-elevation),
      )
    );
  }

  .container {
    flex: 1;
    display: flex;
    align-items: center;
    position: relative;
    block-size: var(--_state-layer-size);
    // note, only the native inputs are interactive.
    pointer-events: none;
    // ensure scrolling is prevented on mobile.
    touch-action: none;
  }

  .track,
  .tickmarks {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
  }

  // inactive-track
  .track::before,
  .tickmarks::before,
  // active-track
  .track::after,
  .tickmarks::after {
    position: absolute;
    content: '';
    // pad the track inward by half the ripple size offset by the tick container size.
    $_track-padding: calc(
      (var(--_state-layer-size) / 2) - var(--_with-tick-marks-container-size)
    );
    inset-inline-start: $_track-padding;
    inset-inline-end: $_track-padding;

    // ticks size: set here since it does not change.
    background-size: calc(
        (100% - var(--_with-tick-marks-container-size) * 2) / var(--_tick-count)
      )
      100%;
  }

  // inactive-track
  .track::before,
  .tickmarks::before {
    block-size: var(--_inactive-track-height);
    border-radius: var(--_inactive-track-shape);
  }

  .track::before {
    background: var(--_inactive-track-color);
  }

  .tickmarks::before {
    background-image: _get-tick-image(
      var(--_with-tick-marks-inactive-container-color)
    );
  }

  :host([disabled]) .track::before {
    // Note, the active track opacity is applied to the entire host,
    // so the inactive track is calc'd to compensate.
    opacity: calc(
      (1 / var(--_disabled-active-track-opacity)) *
        var(--_disabled-inactive-track-opacity)
    );
    background: var(--_disabled-inactive-track-color);
  }

  // active-track
  .track::after,
  .tickmarks::after {
    block-size: var(--_active-track-height);
    border-radius: var(--_active-track-shape);
    clip-path: inset(0 $_active-track-end-clip 0 $_active-track-start-clip);
  }

  .track::after {
    background: var(--_active-track-color);
  }

  .tickmarks::after {
    background-image: _get-tick-image(
      var(--_with-tick-marks-active-container-color)
    );
  }

  // rtl for active track clipping
  .track:dir(rtl)::after {
    clip-path: inset(0 $_active-track-start-clip 0 $_active-track-end-clip);
  }

  .tickmarks:dir(rtl)::after {
    clip-path: inset(0 $_active-track-start-clip 0 $_active-track-end-clip);
  }

  :host([disabled]) .track::after {
    background: var(--_disabled-active-track-color);
  }

  :host([disabled]) .tickmarks::before {
    background-image: _get-tick-image(
      var(--_with-tick-marks-disabled-container-color)
    );
  }

  // container for the handle that is inset with padding to be
  // track-sized so that the handle container can be positioned with % only
  // and avoid a Safari issue with not being able to transition values that
  // are calced from different units.
  // TODO remove when https://bugs.webkit.org/show_bug.cgi?id=23775 is
  // addressed.
  .handleContainerPadded {
    position: relative;
    block-size: 100%;
    inline-size: 100%;
    padding-inline: calc(var(--_state-layer-size) / 2);
  }

  .handleContainerBlock {
    position: relative;
    block-size: 100%;
    inline-size: 100%;
  }

  .handleContainer {
    position: absolute;
    inset-block-start: 0;
    inset-block-end: 0;
    inset-inline-start: calc(100% * var(--_start-fraction));
    inline-size: calc(100% * (var(--_end-fraction) - var(--_start-fraction)));
  }

  // handle
  .handle {
    position: absolute;
    block-size: var(--_state-layer-size);
    inline-size: var(--_state-layer-size);
    border-radius: var(--_handle-shape);
    display: flex;
    place-content: center;
    place-items: center;
  }

  .handleNub {
    position: absolute;
    height: var(--_handle-height);
    width: var(--_handle-width);
    border-radius: var(--_handle-shape);
    background: var(--_handle-color);
  }

  :host([disabled]) .handleNub {
    background: var(--_disabled-handle-color);
  }

  input.end:focus ~ .handleContainerPadded .handle.end > .handleNub,
  input.start:focus ~ .handleContainerPadded .handle.start > .handleNub {
    background: var(--_focus-handle-color);
  }

  // prefix classes exist to overcome specificity of focus styling.
  .container > .handleContainerPadded .handle.hover > .handleNub {
    background: var(--_hover-handle-color);
  }

  :host(:not([disabled])) {
    input.end:active ~ .handleContainerPadded .handle.end > .handleNub,
    input.start:active ~ .handleContainerPadded .handle.start > .handleNub {
      background: var(--_pressed-handle-color);
    }
  }

  .onTop.isOverlapping {
    .label,
    .label::before {
      outline: var(--_with-overlap-handle-outline-color) solid
        var(--_with-overlap-handle-outline-width);
    }

    .handleNub {
      border: var(--_with-overlap-handle-outline-color) solid
        var(--_with-overlap-handle-outline-width);
    }
  }

  .handle.start {
    inset-inline-start: calc(0px - var(--_state-layer-size) / 2);
  }
  .handle.end {
    inset-inline-end: calc(0px - var(--_state-layer-size) / 2);
  }

  // label
  .label {
    position: absolute;
    box-sizing: border-box;
    display: flex;
    padding: 4px;
    place-content: center;
    place-items: center;
    border-radius: map.get($_md-sys-shape, 'corner-full');

    color: var(--_label-text-color);
    font-family: var(--_label-text-font);
    font-size: var(--_label-text-size);
    line-height: var(--_label-text-line-height);
    font-weight: var(--_label-text-weight);

    inset-block-end: 100%;
    min-inline-size: var(--_label-container-height);
    min-block-size: var(--_label-container-height);
    background: var(--_label-container-color);
    transition: transform map.get($_md-sys-motion, 'duration-short2')
      map.get($_md-sys-motion, 'easing-emphasized');
    transform-origin: center bottom;
    transform: scale(0);
  }

  // note, `:has` needed only for Safari; it's wrapped in a "forgiving"
  // `:where` since the syntax isn't supported yet in Firefox.
  :host(:focus-within) .label,
  .handleContainer.hover .label,
  :where(:has(input:active)) .label {
    transform: scale(1);
  }

  .label::before,
  .label::after {
    position: absolute;
    display: block;
    content: '';
    background: inherit;
  }

  // triangle below label
  .label::before {
    // Note, sizing carefully estimated to create an ice cream cone shape.
    $_triangleSize: calc(var(--_label-container-height) / 2);
    inline-size: $_triangleSize;
    block-size: $_triangleSize;
    bottom: calc(var(--_label-container-height) / -10);
    transform: rotate(45deg);
  }

  // fits inside label and occludes top half of triangle.
  .label::after {
    inset: 0px;
    border-radius: inherit;
  }

  // must stack above the label's pseudo-elements.
  .labelContent {
    z-index: 1;
  }

  // native input styling
  // note, the input is what the user interacts with so it must render and
  // be clickable, but it is visually hidden via opacity: 0 and non-clickable
  // styled ui is shown instead and positioned accordingly.
  input[type='range'] {
    opacity: 0;
    -webkit-tap-highlight-color: transparent;
    position: absolute;
    box-sizing: border-box;
    // needed for firefox
    height: 100%;
    width: 100%;
    margin: 0;
    background: transparent;
    cursor: pointer;
    pointer-events: auto;
    appearance: none;
  }

  input[type='range']:focus {
    outline: none;
  }

  ::-webkit-slider-runnable-track {
    -webkit-appearance: none;
  }

  ::-moz-range-track {
    appearance: none;
  }

  ::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    // note, this is sized to align with thumb
    block-size: var(--_handle-height);
    inline-size: var(--_handle-width);
    opacity: 0;
    z-index: 2;
  }

  @include _get-safari-knob-translate('end');
  @include _get-safari-knob-translate('start');

  ::-moz-range-thumb {
    appearance: none;
    block-size: var(--_state-layer-size);
    inline-size: var(--_state-layer-size);
    transform: scaleX(0);
    opacity: 0;
    z-index: 2;
  }

  // Clip the inputs to the space left/right of the center point between the
  // values so the right input gets pointer events.
  $_clip-to-start: calc(
    var(--_state-layer-size) / 2 + (100% - var(--_state-layer-size)) *
      (
        var(--_start-fraction) +
          ((var(--_end-fraction) - var(--_start-fraction)) / 2)
      )
  );

  $_clip-to-end: calc(100% - $_clip-to-start);

  // clip left side of "start" input
  .ranged input.start {
    clip-path: inset(0 $_clip-to-end 0 0);
  }

  // in 'rtl', clip right side of "lesser" input
  .ranged input.start:dir(rtl) {
    clip-path: inset(0 0 0 $_clip-to-end);
  }

  // clip right side of "end" input
  .ranged input.end {
    clip-path: inset(0 0 0 $_clip-to-start);
  }

  // in 'rtl', clip left side of "greater" input
  .ranged input.end:dir(rtl) {
    clip-path: inset(0 $_clip-to-start 0 0);
  }

  .onTop {
    z-index: 1;
  }

  // Ripple
  .handle {
    @include ripple.theme(
      (
        hover-color: var(--_hover-state-layer-color),
        hover-opacity: var(--_hover-state-layer-opacity),
        pressed-color: var(--_pressed-state-layer-color),
        pressed-opacity: var(--_pressed-state-layer-opacity),
      )
    );
  }

  md-ripple {
    border-radius: 50%;
    height: var(--_state-layer-size);
    width: var(--_state-layer-size);
  }
}

// Returns a background-image with sized circular ticks of the given color.
@function _get-tick-image($color) {
  @return radial-gradient(
    circle at var(--_with-tick-marks-container-size) center,
    #{$color} 0,
    #{$color} calc(var(--_with-tick-marks-container-size) / 2),
    transparent calc(var(--_with-tick-marks-container-size) / 2)
  );
}

// Webkit on iOS requires _some_ size on the thumb. We want to make this the
// same as --_handle-size but also be centered on the handle.
//
// the layout is similar to this:
// [()---[()===========]----]
//
// where - is the native input and the == is the material track.
// at 0 we want to shift the native knob right (padding + knob-size / 2):
// [----[(())===========]----]
//
// at the end we want to shift the native knob left by the same amount:
// [----[===========(())]----]
//
// Therefore we can do `layout-shift - 2 * `percent-fraction` * `layout-shift`
// and in RTL we want to do the the same * -1
@mixin _get-safari-knob-translate($start-or-end) {
  input.#{$start-or-end}::-webkit-slider-thumb {
    // AKA `layout-shift` in the equations above
    --_track-and-knob-padding: calc(
      (var(--_state-layer-size) - var(--_handle-width)) / 2
    );
    --_x-translate: calc(
      var(--_track-and-knob-padding) - 2 * var(--_#{$start-or-end}-fraction) *
        var(--_track-and-knob-padding)
    );
    transform: translateX(var(--_x-translate));
  }

  input.#{$start-or-end}:dir(rtl)::-webkit-slider-thumb {
    transform: translateX(calc(-1 * var(--_x-translate)));
  }
}
