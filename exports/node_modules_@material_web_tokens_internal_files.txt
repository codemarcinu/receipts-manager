=== Directory: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\@material\web\tokens\internal ===


================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\@material\web\tokens\internal\_shape.scss
================================================================================

//
// Copyright 2024 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use 'sass:list';
@use 'sass:map';
@use 'sass:meta';
// go/keep-sorted end

/// Returns a map of 4 logical tokens (start-start, start-end, end-end,
/// and end-start) for each of the given shape tokens in the provided token
/// map.
///
/// @example scss
///   $tokens: ('container-shape': 16px 16px 0px 0px);
///   $new-tokens: shape.get-new-logical-shape-tokens(
///     $tokens,
///     'container-shape'
///   );
///   // (
///   //   'container-shape-start-start': 16px,
///   //   'container-shape-start-end': 16px,
///   //   'container-shape-end-end': 0px,
///   //   'container-shape-end-start': 0px,
///   // )
///
/// @param $tokens A Map of tokens.
/// @param $shape-tokens One or more shape tokens in the provided map. Each
///     shape token will add 4 logical shape tokens to the returned map.
/// @return A map with 4 logical tokens for each provided shape token.
@function get-new-logical-shape-tokens($tokens, $shape-tokens...) {
  $new-logical-tokens: ();
  $logical-suffixes: (
    // top-left
    'start-start',
    // top-right
    'start-end',
    // bottom-right
    'end-end',
    // bottom-left
    'end-start'
  );

  @each $shape-token in $shape-tokens {
    $shorthand-value: _expand-shorthand-to-list(map.get($tokens, $shape-token));

    @each $logical-suffix in $logical-suffixes {
      $logical-token: '#{$shape-token}-#{$logical-suffix}';
      $logical-index: list.index($logical-suffixes, $logical-suffix);

      $new-logical-tokens: map.set(
        $new-logical-tokens,
        $logical-token,
        list.nth($shorthand-value, $logical-index)
      );
    }
  }

  @return $new-logical-tokens;
}

@function _expand-shorthand-to-list($shorthand) {
  @if meta.type-of($shorthand) != 'list' or list.length($shorthand) == 1 {
    @return ($shorthand, $shorthand, $shorthand, $shorthand);
  }

  @if list.length($shorthand) == 2 {
    $top-left-and-bottom-right: list.nth($shorthand, 1);
    $top-right-and-bottom-left: list.nth($shorthand, 2);
    @return (
      $top-left-and-bottom-right,
      $top-right-and-bottom-left,
      $top-left-and-bottom-right,
      $top-right-and-bottom-left
    );
  }

  @if list.length($shorthand) == 3 {
    $top-left: list.nth($shorthand, 1);
    $top-right-and-bottom-left: list.nth($shorthand, 2);
    $bottom-right: list.nth($shorthand, 3);
    @return (
      $top-left,
      $top-right-and-bottom-left,
      $bottom-right,
      $top-right-and-bottom-left
    );
  }

  @return $shorthand;
}

================================================================================
File: C:\Users\marci\Documents\GitHub\receipts-manager\node_modules\@material\web\tokens\internal\_validate.scss
================================================================================

//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use 'sass:list';
@use 'sass:map';
@use 'sass:meta';
// go/keep-sorted end

/// Validates the Map returned from `tokens.md-comp-*-values()` functions.
///
/// Validation requires a `$values` Map and at least the `$supported-tokens`
/// keyword argument.
/// @example - scss
///   $tokens: validate.values(
///     md-comp-foo.values($deps, $exclude-hardcoded-values),
///     $supported-tokens: (),
///       'foo-color',
///       'foo-size',
///     ),
///   );
///
/// Additional keyword arguments for `$unsupported-tokens`, `$renamed-tokens`,
/// and `$new-tokens` are optional.
///
/// @param {Map} $values - The values Map returned from
///     `tokens.md-comp-*-values()` functions.
/// @param {List} $supported-tokens - Keyword argument for every token that is
///     supported.
/// @param {List} $unsupported-tokens [null] - Keyword argument for every token
///     that is not supported and should be removed.
/// @param {Map} $renamed-tokens [null] - Keyword argument for a Map whose keys
///     are token names and values are new token names to rename them to. The
///     new token name must appear in the `$supported-tokens` list.
/// @param {Map} $new-tokens [null] - Keyword argument for a Map whose keys
///     and values are new tokens to be added. They must also appear in the
///     `$supported-tokens` list.
/// @return {Map} The `tokens.md-comp-*-values()` Map with any unsupported
///     tokens removed, renamed tokens updated, and new tokens added.
@function values($values, $tokens...) {
  $tokens: meta.keywords($tokens);

  $renamed-tokens: map.get($tokens, 'renamed-tokens');
  @if $renamed-tokens {
    @if meta.type-of($renamed-tokens) != 'map' {
      @error 'validate.values($renamed-tokens) must be a map.';
    }

    @each $old-token, $new-token in $renamed-tokens {
      @if not map.has-key($values, $old-token) {
        @error 'validate.values($renamed-tokens: (\'#{$old-token}\': \'#{$new-token}\')) old-token in not the provided values.';
      }

      $values: map.set($values, $new-token, map.get($values, $old-token));
      $values: map.remove($values, $old-token);
    }
  }

  $unsupported-tokens: map.get($tokens, 'unsupported-tokens');
  @if $unsupported-tokens {
    @if meta.type-of($unsupported-tokens) != 'list' {
      @error 'validate.values($unsupported-tokens) must be a list.';
    }

    @each $unsupported-token in $unsupported-tokens {
      @if not map.has-key($values, $unsupported-token) {
        @error 'validate.values($unsupported-tokens: (\'#{$unsupported-token}\')) token is not in the provided values.';
      }

      $values: map.remove($values, $unsupported-token);
    }
  }

  $new-tokens: map.get($tokens, 'new-tokens');
  @if $new-tokens {
    @if meta.type-of($new-tokens) != 'map' {
      @error 'validate.values($new-tokens) must be a map.';
    }

    @each $new-token, $new-value in $new-tokens {
      @if map.has-key($values, $new-token) {
        @warn 'validate.values($new-tokens: (\'#{$new-token}\': \'#{$new-value}\')) already exists. Has it been added to tokens? If so, remove this new token.';
      }

      $values: map.set($values, $new-token, $new-value);
    }
  }

  $supported-tokens: map.get($tokens, 'supported-tokens');
  @if not $supported-tokens or meta.type-of($supported-tokens) != 'list' {
    @error 'validate.values() must include a $supported-tokens list.';
  }

  @each $token in map.keys($values) {
    @if list.index($supported-tokens, $token) == null {
      @error 'validate.values($supported-tokens) is missing the \'#{$token}\' token. Does it need adding to $unsupported-tokens?';
    }
  }

  @each $supported-token in $supported-tokens {
    @if not map.has-key($values, $supported-token) {
      @error 'The provided values are missing the supported \'#{$supported-token}\' token.';
    }
  }

  @return $values;
}
